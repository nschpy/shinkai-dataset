[
  {
    "input": "func isUserLoggedIn() -> Bool {\n    guard let token = UserDefaults.standard.string(forKey: \"authToken\") else { return false }\n    // Здесь могла бы быть логика проверки срока действия токена\n    return !token.isEmpty\n}",
    "output": "/// Проверяет, авторизован ли пользователь на основе токена в UserDefaults.\n/// - Returns: true, если токен существует и не истёк.\nfunc isUserLoggedIn() -> Bool {\n    guard let token = UserDefaults.standard.string(forKey: \"authToken\") else { return false }\n    // Здесь могла бы быть логика проверки срока действия токена\n    return !token.isEmpty\n}"
  },
  {
    "input": "func generateGreetingMessage(for name: String) -> String {\n    let hour = Calendar.current.component(.hour, from: Date())\n    switch hour {\n    case 6..<12: return \"Доброе утро, \\(name)\"\n    case 12..<18: return \"Добрый день, \\(name)\"\n    case 18..<23: return \"Добрый вечер, \\(name)\"\n    default: return \"Доброй ночи, \\(name)\"\n    }\n}",
    "output": "/// Формирует приветственное сообщение по времени суток.\n/// - Parameter name: Имя пользователя.\n/// - Returns: Персонализированное приветствие.\nfunc generateGreetingMessage(for name: String) -> String {\n    let hour = Calendar.current.component(.hour, from: Date())\n    switch hour {\n    case 6..<12: return \"Доброе утро, \\(name)\"\n    case 12..<18: return \"Добрый день, \\(name)\"\n    case 18..<23: return \"Добрый вечер, \\(name)\"\n    default: return \"Доброй ночи, \\(name)\"\n    }\n}"
  },
  {
    "input": "func formatCurrency(_ amount: Double) -> String {\n    let formatter = NumberFormatter()\n    formatter.numberStyle = .currency\n    formatter.currencySymbol = \"₽\"\n    formatter.locale = Locale(identifier: \"ru_RU\")\n    return formatter.string(from: NSNumber(value: amount)) ?? \"\\(amount) ₽\"\n}",
    "output": "/// Конвертирует сумму в рублях в форматированную строку с валютой.\n/// - Parameter amount: Сумма в рублях.\n/// - Returns: Строка с символом рубля.\nfunc formatCurrency(_ amount: Double) -> String {\n    let formatter = NumberFormatter()\n    formatter.numberStyle = .currency\n    formatter.currencySymbol = \"₽\"\n    formatter.locale = Locale(identifier: \"ru_RU\")\n    return formatter.string(from: NSNumber(value: amount)) ?? \"\\(amount) ₽\"\n}"
  },
  {
    "input": "func sendLocalPush(message: String) {\n    let content = UNMutableNotificationContent()\n    content.body = message\n    let trigger = UNTimeIntervalNotificationTrigger(timeInterval: 1, repeats: false)\n    let request = UNNotificationRequest(identifier: UUID().uuidString, content: content, trigger: trigger)\n    UNUserNotificationCenter.current().add(request)\n}",
    "output": "/// Отправляет push-уведомление с заданным текстом.\n/// - Parameter message: Текст уведомления.\nfunc sendLocalPush(message: String) {\n    let content = UNMutableNotificationContent()\n    content.body = message\n    let trigger = UNTimeIntervalNotificationTrigger(timeInterval: 1, repeats: false)\n    let request = UNNotificationRequest(identifier: UUID().uuidString, content: content, trigger: trigger)\n    UNUserNotificationCenter.current().add(request)\n}"
  },
  {
    "input": "func shouldShowOnboarding() -> Bool {\n    return !UserDefaults.standard.bool(forKey: \"onboardingShown\")\n}",
    "output": "/// Определяет, нужно ли показать onboarding на основе флага в хранилище.\n/// - Returns: true, если onboarding ещё не пройден.\nfunc shouldShowOnboarding() -> Bool {\n    return !UserDefaults.standard.bool(forKey: \"onboardingShown\")\n}"
  },
  {
    "input": "func saveLastViewedProduct(_ productId: String) {\n    UserDefaults.standard.set(productId, forKey: \"lastViewedProduct\")\n}",
    "output": "/// Сохраняет ID последнего просмотренного товара.\n/// - Parameter productId: ID товара.\nfunc saveLastViewedProduct(_ productId: String) {\n    UserDefaults.standard.set(productId, forKey: \"lastViewedProduct\")\n}"
  },
  {
    "input": "func shouldShowPromoBanner() -> Bool {\n    let lastShown = UserDefaults.standard.object(forKey: \"lastPromoShown\") as? Date ?? .distantPast\n    return Date().timeIntervalSince(lastShown) > 86400\n}",
    "output": "/// Оценивает, следует ли показать пользователю всплывающее предложение.\n/// - Returns: true, если пользователь не видел баннер более суток.\nfunc shouldShowPromoBanner() -> Bool {\n    let lastShown = UserDefaults.standard.object(forKey: \"lastPromoShown\") as? Date ?? .distantPast\n    return Date().timeIntervalSince(lastShown) > 86400\n}"
  },
  {
    "input": "func coordinatesToString(lat: Double, lon: Double) -> String {\n    return String(format: \"📍 %.4f, %.4f\", lat, lon)\n}",
    "output": "/// Преобразует координаты в строку для отображения на UI.\n/// - Parameters:\n///   - lat: Широта.\n///   - lon: Долгота.\n/// - Returns: Строка координат.\nfunc coordinatesToString(lat: Double, lon: Double) -> String {\n    return String(format: \"📍 %.4f, %.4f\", lat, lon)\n}"
  },
  {
    "input": "func isUserProfileComplete(profile: [String: String]) -> Bool {\n    let requiredKeys = [\"firstName\", \"lastName\", \"email\"]\n    return requiredKeys.allSatisfy { !(profile[$0]?.isEmpty ?? true) }\n}",
    "output": "/// Проверяет, заполнены ли все поля профиля пользователя.\n/// - Parameter profile: Словарь с данными профиля.\n/// - Returns: true, если все обязательные поля не пустые.\nfunc isUserProfileComplete(profile: [String: String]) -> Bool {\n    let requiredKeys = [\"firstName\", \"lastName\", \"email\"]\n    return requiredKeys.allSatisfy { !(profile[$0]?.isEmpty ?? true) }\n}"
  },
  {
    "input": "func isValidRussianPhoneNumber(_ phone: String) -> Bool {\n    let pattern = \"^\\\\+7\\\\d{10}$\"\n    return phone.range(of: pattern, options: .regularExpression) != nil\n}",
    "output": "/// Валидирует номер телефона на соответствие российскому формату.\n/// - Parameter phone: Строка номера.\n/// - Returns: true, если номер валиден.\nfunc isValidRussianPhoneNumber(_ phone: String) -> Bool {\n    let pattern = \"^\\\\+7\\\\d{10}$\"\n    return phone.range(of: pattern, options: .regularExpression) != nil\n}"
  },
  {
    "input": "func starsForRating(_ rating: Double) -> String {\n    let filledStars = Int(rating)\n    let emptyStars = 5 - filledStars\n    return String(repeating: \"★\", count: filledStars) + String(repeating: \"☆\", count: emptyStars)\n}",
    "output": "/// Преобразует рейтинг (от 0 до 5) в строку с эмодзи-звездами.\n/// - Parameter rating: Значение рейтинга.\n/// - Returns: Строка из звёзд.\nfunc starsForRating(_ rating: Double) -> String {\n    let filledStars = Int(rating)\n    let emptyStars = 5 - filledStars\n    return String(repeating: \"★\", count: filledStars) + String(repeating: \"☆\", count: emptyStars)\n}"
  },
  {
    "input": "func isInternetAvailable() -> Bool {\n    // Упрощённо, для примера — реальная реализация требует Reachability\n    return true\n}",
    "output": "/// Определяет, есть ли активная интернет-сессия.\n/// - Returns: true, если интернет доступен.\nfunc isInternetAvailable() -> Bool {\n    // Упрощённо, для примера — реальная реализация требует Reachability\n    return true\n}"
  },
  {
    "input": "func deliveryStatus(for deliveryDate: Date) -> String {\n    let calendar = Calendar.current\n    if calendar.isDateInToday(deliveryDate) {\n        return \"Сегодня\"\n    } else if calendar.isDateInTomorrow(deliveryDate) {\n        return \"Завтра\"\n    } else {\n        return \"Позже\"\n    }\n}",
    "output": "/// Сравнивает дату доставки с текущей датой и возвращает статус.\n/// - Parameter deliveryDate: Дата доставки.\n/// - Returns: Статус строки: \"Сегодня\", \"Завтра\", \"Позже\".\nfunc deliveryStatus(for deliveryDate: Date) -> String {\n    let calendar = Calendar.current\n    if calendar.isDateInToday(deliveryDate) {\n        return \"Сегодня\"\n    } else if calendar.isDateInTomorrow(deliveryDate) {\n        return \"Завтра\"\n    } else {\n        return \"Позже\"\n    }\n}"
  },
  {
    "input": "func hashtags(from tags: [String]) -> String {\n    return tags.map { \"#\\($0.lowercased())\" }.joined(separator: \" \")\n}",
    "output": "/// Преобразует список тегов в одну строку с хештегами.\n/// - Parameter tags: Список тегов.\n/// - Returns: Строка с хештегами.\nfunc hashtags(from tags: [String]) -> String {\n    return tags.map { \"#\\($0.lowercased())\" }.joined(separator: \" \")\n}"
  },
  {
    "input": "func saveScrollOffset(_ offset: Double) {\n    UserDefaults.standard.set(offset, forKey: \"productListScrollOffset\")\n}",
    "output": "/// Сохраняет текущую позицию скролла в списке товаров.\n/// - Parameter offset: Значение смещения.\nfunc saveScrollOffset(_ offset: Double) {\n    UserDefaults.standard.set(offset, forKey: \"productListScrollOffset\")\n}"
  },
  {
    "input": "func isWithinDeliveryZone(lat: Double, lon: Double) -> Bool {\n    let center = (lat: 55.75, lon: 37.61) // Москва\n    let radiusKm = 30.0\n    let distance = sqrt(pow(center.lat - lat, 2) + pow(center.lon - lon, 2)) * 111\n    return distance < radiusKm\n}",
    "output": "/// Проверяет, находится ли пользователь в зоне доставки (по координатам).\n/// - Parameters:\n///   - lat: Широта.\n///   - lon: Долгота.\n/// - Returns: true, если координаты входят в радиус.\nfunc isWithinDeliveryZone(lat: Double, lon: Double) -> Bool {\n    let center = (lat: 55.75, lon: 37.61) // Москва\n    let radiusKm = 30.0\n    let distance = sqrt(pow(center.lat - lat, 2) + pow(center.lon - lon, 2)) * 111\n    return distance < radiusKm\n}"
  },
  {
    "input": "func generateProductDeeplink(productId: String) -> URL? {\n    return URL(string: \"myapp://product/\\(productId)\")\n}",
    "output": "/// Генерирует URL для deeplink с заданным идентификатором товара.\n/// - Parameter productId: Идентификатор.\n/// - Returns: URL для перехода.\nfunc generateProductDeeplink(productId: String) -> URL? {\n    return URL(string: \"myapp://product/\\(productId)\")\n}"
  },
  {
    "input": "func hasNewSupportMessage(lastViewedId: String, newMessageId: String) -> Bool {\n    return lastViewedId != newMessageId\n}",
    "output": "/// Проверяет, просмотрел ли пользователь новое сообщение поддержки.\n/// - Parameter lastViewedId: Последний просмотренный ID.\n/// - Parameter newMessageId: ID нового сообщения.\n/// - Returns: true, если есть новое сообщение.\nfunc hasNewSupportMessage(lastViewedId: String, newMessageId: String) -> Bool {\n    return lastViewedId != newMessageId\n}"
  },
  {
    "input": "func progressPercentage(current: Double, target: Double) -> Int {\n    guard target > 0 else { return 0 }\n    return min(Int((current / target) * 100), 100)\n}",
    "output": "/// Вычисляет процент прогресса цели (например, накоплений).\n/// - Parameters:\n///   - current: Текущее значение.\n///   - target: Целевая сумма.\n/// - Returns: Процент от 0 до 100.\nfunc progressPercentage(current: Double, target: Double) -> Int {\n    guard target > 0 else { return 0 }\n    return min(Int((current / target) * 100), 100)\n}"
  },
  {
    "input": "func isUserLoggedIn() -> Bool {\n    guard let token = UserDefaults.standard.string(forKey: \"authToken\") else { return false }\n    // Здесь могла бы быть логика проверки срока действия токена\n    return !token.isEmpty\n}",
    "output": "/// Проверяет, авторизован ли пользователь на основе токена в UserDefaults.\n/// - Returns: true, если токен существует и не истёк.\nfunc isUserLoggedIn() -> Bool {\n    guard let token = UserDefaults.standard.string(forKey: \"authToken\") else { return false }\n    // Здесь могла бы быть логика проверки срока действия токена\n    return !token.isEmpty\n}"
  },
  {
    "input": "func generateGreetingMessage(for name: String) -> String {\n    let hour = Calendar.current.component(.hour, from: Date())\n    switch hour {\n    case 6..<12: return \"Доброе утро, \\(name)\"\n    case 12..<18: return \"Добрый день, \\(name)\"\n    case 18..<23: return \"Добрый вечер, \\(name)\"\n    default: return \"Доброй ночи, \\(name)\"\n    }\n}",
    "output": "/// Формирует приветственное сообщение по времени суток.\n/// - Parameter name: Имя пользователя.\n/// - Returns: Персонализированное приветствие.\nfunc generateGreetingMessage(for name: String) -> String {\n    let hour = Calendar.current.component(.hour, from: Date())\n    switch hour {\n    case 6..<12: return \"Доброе утро, \\(name)\"\n    case 12..<18: return \"Добрый день, \\(name)\"\n    case 18..<23: return \"Добрый вечер, \\(name)\"\n    default: return \"Доброй ночи, \\(name)\"\n    }\n}"
  },
  {
    "input": "func formatCurrency(_ amount: Double) -> String {\n    let formatter = NumberFormatter()\n    formatter.numberStyle = .currency\n    formatter.currencySymbol = \"₽\"\n    formatter.locale = Locale(identifier: \"ru_RU\")\n    return formatter.string(from: NSNumber(value: amount)) ?? \"\\(amount) ₽\"\n}",
    "output": "/// Конвертирует сумму в рублях в форматированную строку с валютой.\n/// - Parameter amount: Сумма в рублях.\n/// - Returns: Строка с символом рубля.\nfunc formatCurrency(_ amount: Double) -> String {\n    let formatter = NumberFormatter()\n    formatter.numberStyle = .currency\n    formatter.currencySymbol = \"₽\"\n    formatter.locale = Locale(identifier: \"ru_RU\")\n    return formatter.string(from: NSNumber(value: amount)) ?? \"\\(amount) ₽\"\n}"
  },
  {
    "input": "func sendLocalPush(message: String) {\n    let content = UNMutableNotificationContent()\n    content.body = message\n    let trigger = UNTimeIntervalNotificationTrigger(timeInterval: 1, repeats: false)\n    let request = UNNotificationRequest(identifier: UUID().uuidString, content: content, trigger: trigger)\n    UNUserNotificationCenter.current().add(request)\n}",
    "output": "/// Отправляет push-уведомление с заданным текстом.\n/// - Parameter message: Текст уведомления.\nfunc sendLocalPush(message: String) {\n    let content = UNMutableNotificationContent()\n    content.body = message\n    let trigger = UNTimeIntervalNotificationTrigger(timeInterval: 1, repeats: false)\n    let request = UNNotificationRequest(identifier: UUID().uuidString, content: content, trigger: trigger)\n    UNUserNotificationCenter.current().add(request)\n}"
  },
  {
    "input": "func shouldShowOnboarding() -> Bool {\n    return !UserDefaults.standard.bool(forKey: \"onboardingShown\")\n}",
    "output": "/// Определяет, нужно ли показать onboarding на основе флага в хранилище.\n/// - Returns: true, если onboarding ещё не пройден.\nfunc shouldShowOnboarding() -> Bool {\n    return !UserDefaults.standard.bool(forKey: \"onboardingShown\")\n}"
  },
  {
    "input": "func saveLastViewedProduct(_ productId: String) {\n    UserDefaults.standard.set(productId, forKey: \"lastViewedProduct\")\n}",
    "output": "/// Сохраняет ID последнего просмотренного товара.\n/// - Parameter productId: ID товара.\nfunc saveLastViewedProduct(_ productId: String) {\n    UserDefaults.standard.set(productId, forKey: \"lastViewedProduct\")\n}"
  },
  {
    "input": "func shouldShowPromoBanner() -> Bool {\n    let lastShown = UserDefaults.standard.object(forKey: \"lastPromoShown\") as? Date ?? .distantPast\n    return Date().timeIntervalSince(lastShown) > 86400\n}",
    "output": "/// Оценивает, следует ли показать пользователю всплывающее предложение.\n/// - Returns: true, если пользователь не видел баннер более суток.\nfunc shouldShowPromoBanner() -> Bool {\n    let lastShown = UserDefaults.standard.object(forKey: \"lastPromoShown\") as? Date ?? .distantPast\n    return Date().timeIntervalSince(lastShown) > 86400\n}"
  },
  {
    "input": "func coordinatesToString(lat: Double, lon: Double) -> String {\n    return String(format: \"📍 %.4f, %.4f\", lat, lon)\n}",
    "output": "/// Преобразует координаты в строку для отображения на UI.\n/// - Parameters:\n///   - lat: Широта.\n///   - lon: Долгота.\n/// - Returns: Строка координат.\nfunc coordinatesToString(lat: Double, lon: Double) -> String {\n    return String(format: \"📍 %.4f, %.4f\", lat, lon)\n}"
  },
  {
    "input": "func isUserProfileComplete(profile: [String: String]) -> Bool {\n    let requiredKeys = [\"firstName\", \"lastName\", \"email\"]\n    return requiredKeys.allSatisfy { !(profile[$0]?.isEmpty ?? true) }\n}",
    "output": "/// Проверяет, заполнены ли все поля профиля пользователя.\n/// - Parameter profile: Словарь с данными профиля.\n/// - Returns: true, если все обязательные поля не пустые.\nfunc isUserProfileComplete(profile: [String: String]) -> Bool {\n    let requiredKeys = [\"firstName\", \"lastName\", \"email\"]\n    return requiredKeys.allSatisfy { !(profile[$0]?.isEmpty ?? true) }\n}"
  },
  {
    "input": "func isValidRussianPhoneNumber(_ phone: String) -> Bool {\n    let pattern = \"^\\\\+7\\\\d{10}$\"\n    return phone.range(of: pattern, options: .regularExpression) != nil\n}",
    "output": "/// Валидирует номер телефона на соответствие российскому формату.\n/// - Parameter phone: Строка номера.\n/// - Returns: true, если номер валиден.\nfunc isValidRussianPhoneNumber(_ phone: String) -> Bool {\n    let pattern = \"^\\\\+7\\\\d{10}$\"\n    return phone.range(of: pattern, options: .regularExpression) != nil\n}"
  },
  {
    "input": "func starsForRating(_ rating: Double) -> String {\n    let filledStars = Int(rating)\n    let emptyStars = 5 - filledStars\n    return String(repeating: \"★\", count: filledStars) + String(repeating: \"☆\", count: emptyStars)\n}",
    "output": "/// Преобразует рейтинг (от 0 до 5) в строку с эмодзи-звездами.\n/// - Parameter rating: Значение рейтинга.\n/// - Returns: Строка из звёзд.\nfunc starsForRating(_ rating: Double) -> String {\n    let filledStars = Int(rating)\n    let emptyStars = 5 - filledStars\n    return String(repeating: \"★\", count: filledStars) + String(repeating: \"☆\", count: emptyStars)\n}"
  },
  {
    "input": "func isInternetAvailable() -> Bool {\n    // Упрощённо, для примера — реальная реализация требует Reachability\n    return true\n}",
    "output": "/// Определяет, есть ли активная интернет-сессия.\n/// - Returns: true, если интернет доступен.\nfunc isInternetAvailable() -> Bool {\n    // Упрощённо, для примера — реальная реализация требует Reachability\n    return true\n}"
  },
  {
    "input": "func deliveryStatus(for deliveryDate: Date) -> String {\n    let calendar = Calendar.current\n    if calendar.isDateInToday(deliveryDate) {\n        return \"Сегодня\"\n    } else if calendar.isDateInTomorrow(deliveryDate) {\n        return \"Завтра\"\n    } else {\n        return \"Позже\"\n    }\n}",
    "output": "/// Сравнивает дату доставки с текущей датой и возвращает статус.\n/// - Parameter deliveryDate: Дата доставки.\n/// - Returns: Статус строки: \"Сегодня\", \"Завтра\", \"Позже\".\nfunc deliveryStatus(for deliveryDate: Date) -> String {\n    let calendar = Calendar.current\n    if calendar.isDateInToday(deliveryDate) {\n        return \"Сегодня\"\n    } else if calendar.isDateInTomorrow(deliveryDate) {\n        return \"Завтра\"\n    } else {\n        return \"Позже\"\n    }\n}"
  },
  {
    "input": "func hashtags(from tags: [String]) -> String {\n    return tags.map { \"#\\($0.lowercased())\" }.joined(separator: \" \")\n}",
    "output": "/// Преобразует список тегов в одну строку с хештегами.\n/// - Parameter tags: Список тегов.\n/// - Returns: Строка с хештегами.\nfunc hashtags(from tags: [String]) -> String {\n    return tags.map { \"#\\($0.lowercased())\" }.joined(separator: \" \")\n}"
  },
  {
    "input": "func saveScrollOffset(_ offset: Double) {\n    UserDefaults.standard.set(offset, forKey: \"productListScrollOffset\")\n}",
    "output": "/// Сохраняет текущую позицию скролла в списке товаров.\n/// - Parameter offset: Значение смещения.\nfunc saveScrollOffset(_ offset: Double) {\n    UserDefaults.standard.set(offset, forKey: \"productListScrollOffset\")\n}"
  },
  {
    "input": "func isWithinDeliveryZone(lat: Double, lon: Double) -> Bool {\n    let center = (lat: 55.75, lon: 37.61) // Москва\n    let radiusKm = 30.0\n    let distance = sqrt(pow(center.lat - lat, 2) + pow(center.lon - lon, 2)) * 111\n    return distance < radiusKm\n}",
    "output": "/// Проверяет, находится ли пользователь в зоне доставки (по координатам).\n/// - Parameters:\n///   - lat: Широта.\n///   - lon: Долгота.\n/// - Returns: true, если координаты входят в радиус.\nfunc isWithinDeliveryZone(lat: Double, lon: Double) -> Bool {\n    let center = (lat: 55.75, lon: 37.61) // Москва\n    let radiusKm = 30.0\n    let distance = sqrt(pow(center.lat - lat, 2) + pow(center.lon - lon, 2)) * 111\n    return distance < radiusKm\n}"
  },
  {
    "input": "func generateProductDeeplink(productId: String) -> URL? {\n    return URL(string: \"myapp://product/\\(productId)\")\n}",
    "output": "/// Генерирует URL для deeplink с заданным идентификатором товара.\n/// - Parameter productId: Идентификатор.\n/// - Returns: URL для перехода.\nfunc generateProductDeeplink(productId: String) -> URL? {\n    return URL(string: \"myapp://product/\\(productId)\")\n}"
  },
  {
    "input": "func hasNewSupportMessage(lastViewedId: String, newMessageId: String) -> Bool {\n    return lastViewedId != newMessageId\n}",
    "output": "/// Проверяет, просмотрел ли пользователь новое сообщение поддержки.\n/// - Parameter lastViewedId: Последний просмотренный ID.\n/// - Parameter newMessageId: ID нового сообщения.\n/// - Returns: true, если есть новое сообщение.\nfunc hasNewSupportMessage(lastViewedId: String, newMessageId: String) -> Bool {\n    return lastViewedId != newMessageId\n}"
  },
  {
    "input": "func progressPercentage(current: Double, target: Double) -> Int {\n    guard target > 0 else { return 0 }\n    return min(Int((current / target) * 100), 100)\n}",
    "output": "/// Вычисляет процент прогресса цели (например, накоплений).\n/// - Parameters:\n///   - current: Текущее значение.\n///   - target: Целевая сумма.\n/// - Returns: Процент от 0 до 100.\nfunc progressPercentage(current: Double, target: Double) -> Int {\n    guard target > 0 else { return 0 }\n    return min(Int((current / target) * 100), 100)\n}"
  },
  {
    "input": "func termsAndConditionsURL() -> URL? {\n    let locale = Locale.current.languageCode ?? \"en\"\n    return URL(string: \"https://example.com/terms_\\(locale).html\")\n}",
    "output": "/// Возвращает ссылку на Terms & Conditions в зависимости от локали.\n/// - Returns: URL страницы условий использования.\nfunc termsAndConditionsURL() -> URL? {\n    let locale = Locale.current.languageCode ?? \"en\"\n    return URL(string: \"https://example.com/terms_\\(locale).html\")\n}"
  },
  {
    "input": "func isEventStarted(at date: Date) -> Bool {\n    return Date() >= date\n}",
    "output": "/// Проверяет, наступило ли время запланированного события.\n/// - Parameter date: Дата события.\n/// - Returns: true, если событие уже началось.\nfunc isEventStarted(at date: Date) -> Bool {\n    return Date() >= date\n}"
  },
  {
    "input": "func saveUserTheme(_ theme: String) {\n    UserDefaults.standard.set(theme, forKey: \"appTheme\")\n}",
    "output": "/// Сохраняет выбранную пользователем тему оформления.\n/// - Parameter theme: Название темы.\nfunc saveUserTheme(_ theme: String) {\n    UserDefaults.standard.set(theme, forKey: \"appTheme\")\n}"
  },
  {
    "input": "func getUserTheme() -> String? {\n    return UserDefaults.standard.string(forKey: \"appTheme\")\n}",
    "output": "/// Получает текущую тему оформления.\n/// - Returns: Название темы или nil.\nfunc getUserTheme() -> String? {\n    return UserDefaults.standard.string(forKey: \"appTheme\")\n}"
  },
  {
    "input": "func clearUserSession() {\n    let keys = [\"authToken\", \"userProfile\", \"lastViewedProduct\"]\n    keys.forEach { UserDefaults.standard.removeObject(forKey: $0) }\n}",
    "output": "/// Очищает сохранённые данные пользователя при выходе из аккаунта.\nfunc clearUserSession() {\n    let keys = [\"authToken\", \"userProfile\", \"lastViewedProduct\"]\n    keys.forEach { UserDefaults.standard.removeObject(forKey: $0) }\n}"
  },
  {
    "input": "func generateFeedbackTemplate() -> String {\n    let systemVersion = UIDevice.current.systemVersion\n    let model = UIDevice.current.model\n    return \"Устройство: \\(model)\\nВерсия iOS: \\(systemVersion)\\nВаш отзыв: \"\n}",
    "output": "/// Формирует строку обратной связи с информацией об устройстве.\n/// - Returns: Текст обратной связи.\nfunc generateFeedbackTemplate() -> String {\n    let systemVersion = UIDevice.current.systemVersion\n    let model = UIDevice.current.model\n    return \"Устройство: \\(model)\\nВерсия iOS: \\(systemVersion)\\nВаш отзыв: \"\n}"
  },
  {
    "input": "func hasReachedFreeLimit(count: Int) -> Bool {\n    let limit = 5\n    return count >= limit\n}",
    "output": "/// Проверяет, достиг ли пользователь лимита бесплатных действий.\n/// - Parameter count: Текущее количество действий.\n/// - Returns: true, если лимит достигнут.\nfunc hasReachedFreeLimit(count: Int) -> Bool {\n    let limit = 5\n    return count >= limit\n}"
  },
  {
    "input": "func formatOrderDate(_ date: Date) -> String {\n    let formatter = DateFormatter()\n    formatter.dateFormat = \"dd MMM yyyy\"\n    return formatter.string(from: date)\n}",
    "output": "/// Формирует строку даты для истории заказов.\n/// - Parameter date: Дата.\n/// - Returns: Строка формата \"dd MMM yyyy\".\nfunc formatOrderDate(_ date: Date) -> String {\n    let formatter = DateFormatter()\n    formatter.dateFormat = \"dd MMM yyyy\"\n    return formatter.string(from: date)\n}"
  },
  {
    "input": "func daysBetween(_ from: Date, _ to: Date) -> Int {\n    return Calendar.current.dateComponents([.day], from: from, to: to).day ?? 0\n}",
    "output": "/// Вычисляет количество дней между двумя датами.\n/// - Parameters:\n///   - from: Начальная дата.\n///   - to: Конечная дата.\n/// - Returns: Количество дней.\nfunc daysBetween(_ from: Date, _ to: Date) -> Int {\n    return Calendar.current.dateComponents([.day], from: from, to: to).day ?? 0\n}"
  },
  {
    "input": "func saveLastSeenBannerId(_ id: String) {\n    UserDefaults.standard.set(id, forKey: \"lastSeenBannerId\")\n}",
    "output": "/// Сохраняет ID последнего просмотренного баннера.\n/// - Parameter id: Идентификатор баннера.\nfunc saveLastSeenBannerId(_ id: String) {\n    UserDefaults.standard.set(id, forKey: \"lastSeenBannerId\")\n}"
  },
  {
    "input": "func shouldRefreshCache(since lastUpdate: Date) -> Bool {\n    return Date().timeIntervalSince(lastUpdate) > 6 * 3600\n}",
    "output": "/// Проверяет, следует ли обновить кешированные данные.\n/// - Parameter lastUpdate: Дата последнего обновления.\n/// - Returns: true, если прошло больше 6 часов.\nfunc shouldRefreshCache(since lastUpdate: Date) -> Bool {\n    return Date().timeIntervalSince(lastUpdate) > 6 * 3600\n}"
  },
  {
    "input": "func isUserLoggedIn() -> Bool {\n    guard let token = UserDefaults.standard.string(forKey: \"authToken\") else { return false }\n    // Здесь могла бы быть логика проверки срока действия токена\n    return !token.isEmpty\n}",
    "output": "/// Проверяет, авторизован ли пользователь на основе токена в UserDefaults.\n/// - Returns: true, если токен существует и не истёк.\nfunc isUserLoggedIn() -> Bool {\n    guard let token = UserDefaults.standard.string(forKey: \"authToken\") else { return false }\n    // Здесь могла бы быть логика проверки срока действия токена\n    return !token.isEmpty\n}"
  },
  {
    "input": "func isNewUser(registrationDate: Date) -> Bool {\n    return Date().timeIntervalSince(registrationDate) < 7 * 86400\n}",
    "output": "/// Проверяет, является ли пользователь новым (на основе даты регистрации).\n/// - Parameter registrationDate: Дата регистрации пользователя.\n/// - Returns: true, если пользователь зарегистрирован менее 7 дней назад.\nfunc isNewUser(registrationDate: Date) -> Bool {\n    return Date().timeIntervalSince(registrationDate) < 7 * 86400\n}"
  },
  {
    "input": "func getAppLaunchCount() -> Int {\n    return UserDefaults.standard.integer(forKey: \"launchCount\")\n}",
    "output": "/// Получает количество запусков приложения.\n/// - Returns: Количество запусков.\nfunc getAppLaunchCount() -> Int {\n    return UserDefaults.standard.integer(forKey: \"launchCount\")\n}"
  },
  {
    "input": "func incrementAppLaunchCount() {\n    let count = getAppLaunchCount() + 1\n    UserDefaults.standard.set(count, forKey: \"launchCount\")\n}",
    "output": "/// Увеличивает счётчик запусков приложения.\nfunc incrementAppLaunchCount() {\n    let count = getAppLaunchCount() + 1\n    UserDefaults.standard.set(count, forKey: \"launchCount\")\n}"
  },
  {
    "input": "func isFaceIDAvailable() -> Bool {\n    let context = LAContext()\n    var error: NSError?\n    return context.canEvaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, error: &error) && context.biometryType == .faceID\n}",
    "output": "/// Проверяет, доступен ли Face ID на устройстве.\n/// - Returns: true, если Face ID доступен.\nfunc isFaceIDAvailable() -> Bool {\n    let context = LAContext()\n    var error: NSError?\n    return context.canEvaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, error: &error) && context.biometryType == .faceID\n}"
  },
  {
    "input": "func monthName(for month: Int) -> String {\n    let formatter = DateFormatter()\n    formatter.locale = Locale(identifier: \"ru_RU\")\n    return formatter.monthSymbols[safe: month - 1] ?? \"\"\n}",
    "output": "/// Получает имя месяца на русском по номеру.\n/// - Parameter month: Номер месяца от 1 до 12.\n/// - Returns: Название месяца.\nfunc monthName(for month: Int) -> String {\n    let formatter = DateFormatter()\n    formatter.locale = Locale(identifier: \"ru_RU\")\n    return formatter.monthSymbols[safe: month - 1] ?? \"\"\n}"
  },
  {
    "input": "func ordersHistoryURL(for userId: String) -> URL? {\n    return URL(string: \"https://api.example.com/orders?user=\\(userId)\")\n}",
    "output": "/// Формирует URL для запроса истории заказов пользователя.\n/// - Parameter userId: Идентификатор пользователя.\n/// - Returns: URL с параметром userId.\nfunc ordersHistoryURL(for userId: String) -> URL? {\n    return URL(string: \"https://api.example.com/orders?user=\\(userId)\")\n}"
  },
  {
    "input": "func isDarkModeEnabled() -> Bool {\n    return UserDefaults.standard.bool(forKey: \"darkMode\")\n}",
    "output": "/// Получает текущее значение параметра \"darkMode\".\n/// - Returns: true, если включена тёмная тема.\nfunc isDarkModeEnabled() -> Bool {\n    return UserDefaults.standard.bool(forKey: \"darkMode\")\n}"
  },
  {
    "input": "func isLocationAccessGranted() -> Bool {\n    return CLLocationManager.authorizationStatus() == .authorizedWhenInUse || CLLocationManager.authorizationStatus() == .authorizedAlways\n}",
    "output": "/// Проверяет, есть ли доступ к геолокации.\n/// - Returns: true, если доступ разрешён.\nfunc isLocationAccessGranted() -> Bool {\n    return CLLocationManager.authorizationStatus() == .authorizedWhenInUse || CLLocationManager.authorizationStatus() == .authorizedAlways\n}"
  },
  {
    "input": "func formatTime(seconds: Int) -> String {\n    return String(format: \"%02d:%02d\", seconds / 60, seconds % 60)\n}",
    "output": "/// Преобразует секунды в строку формата \"мм:сс\".\n/// - Parameter seconds: Количество секунд.\n/// - Returns: Форматированная строка.\nfunc formatTime(seconds: Int) -> String {\n    return String(format: \"%02d:%02d\", seconds / 60, seconds % 60)\n}"
  },
  {
    "input": "func isPinAttemptsLimitExceeded(_ attempts: Int) -> Bool {\n    return attempts >= 3\n}",
    "output": "/// Проверяет, достигнуто ли максимальное количество попыток ввода PIN-кода.\n/// - Parameter attempts: Количество попыток.\n/// - Returns: true, если лимит превышен.\nfunc isPinAttemptsLimitExceeded(_ attempts: Int) -> Bool {\n    return attempts >= 3\n}"
  },
  {
    "input": "func deliveryStatusText(for status: String) -> String {\n    switch status {\n    case \"pending\": return \"Ожидает обработки\"\n    case \"shipped\": return \"Отправлено\"\n    case \"delivered\": return \"Доставлено\"\n    default: return \"Неизвестно\"\n    }\n}",
    "output": "/// Генерирует строку статуса доставки по текущему этапу.\n/// - Parameter status: Текущий статус.\n/// - Returns: Строковое описание.\nfunc deliveryStatusText(for status: String) -> String {\n    switch status {\n    case \"pending\": return \"Ожидает обработки\"\n    case \"shipped\": return \"Отправлено\"\n    case \"delivered\": return \"Доставлено\"\n    default: return \"Неизвестно\"\n    }\n}"
  },
  {
    "input": "func resetAppData() {\n    if let appDomain = Bundle.main.bundleIdentifier {\n        UserDefaults.standard.removePersistentDomain(forName: appDomain)\n    }\n}",
    "output": "/// Удаляет все элементы UserDefaults для сброса приложения.\nfunc resetAppData() {\n    if let appDomain = Bundle.main.bundleIdentifier {\n        UserDefaults.standard.removePersistentDomain(forName: appDomain)\n    }\n}"
  },
  {
    "input": "func pingServer(completion: @escaping (Bool) -> Void) {\n    let url = URL(string: \"https://api.example.com/ping\")!\n    URLSession.shared.dataTask(with: url) { _, response, error in\n        let httpResponse = response as? HTTPURLResponse\n        completion(httpResponse?.statusCode == 200 && error == nil)\n    }.resume()\n}",
    "output": "/// Проверяет, работает ли сервер API.\n/// - Parameter completion: Замыкание с результатом доступности.\nfunc pingServer(completion: @escaping (Bool) -> Void) {\n    let url = URL(string: \"https://api.example.com/ping\")!\n    URLSession.shared.dataTask(with: url) { _, response, error in\n        let httpResponse = response as? HTTPURLResponse\n        completion(httpResponse?.statusCode == 200 && error == nil)\n    }.resume()\n}"
  },
  {
    "input": "func savePreferredLanguage(_ languageCode: String) {\n    UserDefaults.standard.set(languageCode, forKey: \"preferredLanguage\")\n}",
    "output": "/// Сохраняет предпочитаемый язык пользователя.\n/// - Parameter languageCode: Код языка (например, \"ru\", \"en\").\nfunc savePreferredLanguage(_ languageCode: String) {\n    UserDefaults.standard.set(languageCode, forKey: \"preferredLanguage\")\n}"
  },
  {
    "input": "func getPreferredLanguage() -> String {\n    return UserDefaults.standard.string(forKey: \"preferredLanguage\") ?? \"ru\"\n}",
    "output": "/// Получает предпочитаемый язык пользователя.\n/// - Returns: Код языка или \"ru\" по умолчанию.\nfunc getPreferredLanguage() -> String {\n    return UserDefaults.standard.string(forKey: \"preferredLanguage\") ?? \"ru\"\n}"
  },
  {
    "input": "func isNonIntegerNumber(_ text: String) -> Bool {\n    if let number = Double(text) {\n        return floor(number) != number\n    }\n    return false\n}",
    "output": "/// Проверяет, является ли строка числовым значением, которое не является целым числом.\n/// - Parameter text: Входная строка.\n/// - Returns: true, если строка представляет число с плавающей точкой, false — целое число или не число.\nfunc isNonIntegerNumber(_ text: String) -> Bool {\n    if let number = Double(text) {\n        return floor(number) != number\n    }\n    return false\n}"
  },
  {
    "input": "func repeatCharacter(_ character: Character, count: Int) -> String {\n    return String(repeating: String(character), count: count)\n}",
    "output": "/// Генерирует строку, содержащую повторяющийся символ определённое количество раз.\n/// - Parameters:\n///   - character: Символ для повторения.\n///   - count: Количество повторений.\n/// - Returns: Строка с повторяющимися символами.\nfunc repeatCharacter(_ character: Character, count: Int) -> String {\n    return String(repeating: String(character), count: count)\n}"
  },
  {
    "input": "func isUniqueString(_ text: String, in array: [String]) -> Bool {\n    return array.filter { $0 == text }.count == 1\n}",
    "output": "/// Проверяет, является ли строка уникальной в массиве строк.\n/// - Parameters:\n///   - text: Строка для проверки.\n///   - array: Массив строк.\n/// - Returns: true, если строка встречается в массиве только один раз.\nfunc isUniqueString(_ text: String, in array: [String]) -> Bool {\n    return array.filter { $0 == text }.count == 1\n}"
  },
  {
    "input": "func roundedNumber(from text: String, decimals: Int) -> Double? {\n    guard let number = Double(text) else { return nil }\n    return round(number * pow(10, Double(decimals))) / pow(10, Double(decimals))\n}",
    "output": "/// Преобразует строку в число с заданным округлением до определённого числа знаков после запятой.\n/// - Parameters:\n///   - text: Входная строка.\n///   - decimals: Количество знаков после запятой.\n/// - Returns: Округлённое число.\nfunc roundedNumber(from text: String, decimals: Int) -> Double? {\n    guard let number = Double(text) else { return nil }\n    return round(number * pow(10, Double(decimals))) / pow(10, Double(decimals))\n}"
  },
  {
    "input": "func extractDigitsInOrder(from text: String) -> String {\n    return text.filter { $0.isNumber }\n}",
    "output": "/// Возвращает строку, содержащую все цифры из строки в порядке их появления.\n/// - Parameter text: Входная строка.\n/// - Returns: Строка, содержащая только цифры.\nfunc extractDigitsInOrder(from text: String) -> String {\n    return text.filter { $0.isNumber }\n}"
  },
  {
    "input": "func toCobolCase(_ text: String) -> String {\n    let words = text.split(separator: \" \").map { $0.lowercased() }\n    guard let first = words.first else { return \"\" }\n    return [first] + words.dropFirst().map { $0.capitalized }.joined(separator: \" \")\n}",
    "output": "/// Переводит строку в \"кобольдский\" регистр (каждое слово с маленькой буквы, кроме первого).\n/// - Parameter text: Входная строка.\n/// - Returns: Строка в \"кобольдском\" регистре.\nfunc toCobolCase(_ text: String) -> String {\n    let words = text.split(separator: \" \").map { $0.lowercased() }\n    guard let first = words.first else { return \"\" }\n    return [first] + words.dropFirst().map { $0.capitalized }.joined(separator: \" \")\n}"
  },
  {
    "input": "func removeCharactersFromString(_ text: String, charactersToRemove: String) -> String {\n    return text.filter { !charactersToRemove.contains($0) }\n}",
    "output": "/// Возвращает строку с удалением всех символов, которые встречаются в другой строке.\n/// - Parameters:\n///   - text: Входная строка.\n///   - charactersToRemove: Строка с символами для удаления.\n/// - Returns: Строка без указанных символов.\nfunc removeCharactersFromString(_ text: String, charactersToRemove: String) -> String {\n    return text.filter { !charactersToRemove.contains($0) }\n}"
  },
  {
    "input": "func isWholeNumber(_ text: String) -> Bool {\n    return Int(text) != nil\n}",
    "output": "/// Проверяет, является ли строка полным числом без десятичной точки.\n/// - Parameter text: Входная строка.\n/// - Returns: true, если строка представляет целое число.\nfunc isWholeNumber(_ text: String) -> Bool {\n    return Int(text) != nil\n}"
  },
  {
    "input": "func containsSubstring(_ substring: String, in text: String) -> Bool {\n    return text.contains(substring)\n}",
    "output": "/// Проверяет, является ли строка подстрокой другой строки.\n/// - Parameters:\n///   - substring: Подстрока для проверки.\n///   - text: Исходная строка.\n/// - Returns: true, если подстрока найдена в строке.\nfunc containsSubstring(_ substring: String, in text: String) -> Bool {\n    return text.contains(substring)\n}"
  },
  {
    "input": "func stringToCapitalizedWords(_ text: String) -> [String] {\n    return text.split(separator: \" \").map { $0.capitalized }\n}",
    "output": "/// Преобразует строку в список слов с учётом заглавных букв (каждое новое слово начинается с заглавной буквы).\n/// - Parameter text: Входная строка.\n/// - Returns: Массив слов с учётом заглавных букв.\nfunc stringToCapitalizedWords(_ text: String) -> [String] {\n    return text.split(separator: \" \").map { $0.capitalized }\n}"
  },
  {
    "input": "func alternatingCase(_ text: String) -> String {\n    return String(text.enumerated().map { (index, character) in\n        index % 2 == 0 ? character.lowercased() : character.uppercased()\n    })\n}",
    "output": "/// Преобразует строку в строку с чередующимися буквами в верхнем и нижнем регистрах.\n/// - Parameter text: Входная строка.\n/// - Returns: Строка с чередующимися заглавными и строчными буквами.\nfunc alternatingCase(_ text: String) -> String {\n    return String(text.enumerated().map { (index, character) in\n        index % 2 == 0 ? character.lowercased() : character.uppercased()\n    })\n}"
  },
  {
    "input": "func indexOfSubstring(_ substring: String, in text: String) -> Int? {\n    return text.range(of: substring)?.lowerBound.utf16Offset(in: text)\n}",
    "output": "/// Возвращает индекс первого вхождения подстроки в строку.\n/// - Parameters:\n///   - substring: Подстрока для поиска.\n///   - text: Исходная строка.\n/// - Returns: Индекс первого вхождения подстроки или nil, если не найдено.\nfunc indexOfSubstring(_ substring: String, in text: String) -> Int? {\n    return text.range(of: substring)?.lowerBound.utf16Offset(in: text)\n}"
  },
  {
    "input": "func isAlphaOnlyPalindrome(_ text: String) -> Bool {\n    let cleaned = text.lowercased().filter { $0.isLetter }\n    return cleaned == String(cleaned.reversed())\n}",
    "output": "/// Проверяет, является ли строка палиндромом, учитывая только алфавитные символы и игнорируя регистр.\n/// - Parameter text: Входная строка.\n/// - Returns: true, если строка является палиндромом.\nfunc isAlphaOnlyPalindrome(_ text: String) -> Bool {\n    let cleaned = text.lowercased().filter { $0.isLetter }\n    return cleaned == String(cleaned.reversed())\n}"
  },
  {
    "input": "func extractUppercaseLetters(from text: String) -> String {\n    return text.filter { $0.isUppercase }\n}",
    "output": "/// Возвращает строку, содержащую только заглавные буквы из исходной строки.\n/// - Parameter text: Входная строка.\n/// - Returns: Строка, содержащая только заглавные буквы.\nfunc extractUppercaseLetters(from text: String) -> String {\n    return text.filter { $0.isUppercase }\n}"
  },
  {
    "input": "func isBinaryNumber(_ text: String) -> Bool {\n    return text.allSatisfy { $0 == \"0\" || $0 == \"1\" }\n}",
    "output": "/// Возвращает true, если строка является числовым значением в двоичной системе.\n/// - Parameter text: Входная строка.\n/// - Returns: true, если строка является двоичным числом.\nfunc isBinaryNumber(_ text: String) -> Bool {\n    return text.allSatisfy { $0 == \"0\" || $0 == \"1\" }\n}"
  },
  {
    "input": "func capitalizeFirstLetter(_ text: String) -> String {\n    guard let first = text.first else { return text }\n    return first.uppercased() + text.dropFirst()\n}",
    "output": "/// Возвращает строку с первым символом, преобразованным в заглавную букву.\n/// - Parameter text: Входная строка.\n/// - Returns: Строка с первым символом в верхнем регистре.\nfunc capitalizeFirstLetter(_ text: String) -> String {\n    guard let first = text.first else { return text }\n    return first.uppercased() + text.dropFirst()\n}"
  },
  {
    "input": "func stringToCharArray(_ text: String) -> [Character] {\n    return Array(text)\n}",
    "output": "/// Преобразует строку в массив, разбивая по каждому символу.\n/// - Parameter text: Входная строка.\n/// - Returns: Массив символов.\nfunc stringToCharArray(_ text: String) -> [Character] {\n    return Array(text)\n}"
  },
  {
    "input": "func repeatString(_ text: String, count: Int) -> String {\n    return String(repeating: text, count: count)\n}",
    "output": "/// Возвращает строку, которая является результатом повторения строкового значения несколько раз.\n/// - Parameters:\n///   - text: Входная строка.\n///   - count: Количество повторений.\n/// - Returns: Повторённая строка.\nfunc repeatString(_ text: String, count: Int) -> String {\n    return String(repeating: text, count: count)\n}"
  },
  {
    "input": "func isValidTime(_ text: String) -> Bool {\n    let pattern = \"^(2[0-3]|[01]?[0-9]):([0-5]?[0-9])$\"\n    return matchesRegex(text, pattern: pattern)\n}",
    "output": "/// Проверяет, является ли строка представлением действительного времени в формате \"HH:mm\".\n/// - Parameter text: Входная строка.\n/// - Returns: true, если строка является временем в формате \"HH:mm\".\nfunc isValidTime(_ text: String) -> Bool {\n    let pattern = \"^(2[0-3]|[01]?[0-9]):([0-5]?[0-9])$\"\n    return matchesRegex(text, pattern: pattern)\n}"
  },
  {
    "input": "func extractDigitsAndDashes(from text: String) -> String {\n    return text.filter { $0.isNumber || $0 == \"-\" }\n}",
    "output": "/// Возвращает строку, состоящую только из цифр и символов тире, если они присутствуют в строке.\n/// - Parameter text: Входная строка.\n/// - Returns: Строка с цифрами и тире.\nfunc extractDigitsAndDashes(from text: String) -> String {\n    return text.filter { $0.isNumber || $0 == \"-\" }\n}"
  },
  {
    "input": "func lowercaseLettersWithoutNumbers(from text: String) -> String {\n    return text.filter { $0.isLetter }.lowercased()\n}",
    "output": "/// Возвращает все символы строки в нижнем регистре, кроме чисел.\n/// - Parameter text: Входная строка.\n/// - Returns: Строка с буквами в нижнем регистре.\nfunc lowercaseLettersWithoutNumbers(from text: String) -> String {\n    return text.filter { $0.isLetter }.lowercased()\n}"
  },
  {
    "input": "func allStringsHaveEqualLength(_ array: [String]) -> Bool {\n    guard let firstLength = array.first?.count else { return true }\n    return array.allSatisfy { $0.count == firstLength }\n}",
    "output": "/// Проверяет, все ли строки в массиве имеют одинаковую длину.\n/// - Parameter array: Массив строк.\n/// - Returns: true, если все строки одинаковой длины.\nfunc allStringsHaveEqualLength(_ array: [String]) -> Bool {\n    guard let firstLength = array.first?.count else { return true }\n    return array.allSatisfy { $0.count == firstLength }\n}"
  },
  {
    "input": "func splitStringByCharacter(_ text: String, separator: Character) -> [String] {\n    return text.split(separator: separator).map { String($0) }\n}",
    "output": "/// Преобразует строку в список строк, разделённых определённым символом.\n/// - Parameters:\n///   - text: Входная строка.\n///   - separator: Символ для разделения.\n/// - Returns: Массив строк.\nfunc splitStringByCharacter(_ text: String, separator: Character) -> [String] {\n    return text.split(separator: separator).map { String($0) }\n}"
  },
  {
    "input": "func isHexadecimalNumber(_ text: String) -> Bool {\n    let pattern = \"^[0-9A-Fa-f]+$\"\n    return matchesRegex(text, pattern: pattern)\n}",
    "output": "/// Проверяет, является ли строка числовым значением в шестнадцатеричной системе.\n/// - Parameter text: Входная строка.\n/// - Returns: true, если строка является шестнадцатеричным числом.\nfunc isHexadecimalNumber(_ text: String) -> Bool {\n    let pattern = \"^[0-9A-Fa-f]+$\"\n    return matchesRegex(text, pattern: pattern)\n}"
  },
  {
    "input": "func stringToDate(_ text: String) -> Date? {\n    let formatter = DateFormatter()\n    formatter.dateFormat = \"yyyy-MM-dd HH:mm:ss\"\n    return formatter.date(from: text)\n}",
    "output": "/// Преобразует строку в дату с учётом времени в формате \"yyyy-MM-dd HH:mm:ss\".\n/// - Parameter text: Входная строка.\n/// - Returns: Дата, если строка соответствует формату.\nfunc stringToDate(_ text: String) -> Date? {\n    let formatter = DateFormatter()\n    formatter.dateFormat = \"yyyy-MM-dd HH:mm:ss\"\n    return formatter.date(from: text)\n}"
  },
  {
    "input": "func cleanString(_ text: String) -> String {\n    let charactersToRemove = CharacterSet.whitespacesAndNewlines.union(.punctuationCharacters)\n    return text.filter { !charactersToRemove.contains($0.unicodeScalars.first!) }\n}",
    "output": "/// Преобразует строку в строку с удалёнными пробелами, знаками препинания и символами новой строки.\n/// - Parameter text: Входная строка.\n/// - Returns: Строка без пробелов и знаков препинания.\nfunc cleanString(_ text: String) -> String {\n    let charactersToRemove = CharacterSet.whitespacesAndNewlines.union(.punctuationCharacters)\n    return text.filter { !charactersToRemove.contains($0.unicodeScalars.first!) }\n}"
  },
  {
    "input": "func stringToNumberWithBase(_ text: String, base: Int) -> Int? {\n    return Int(text, radix: base)\n}",
    "output": "/// Преобразует строку в число с использованием заданной базы (например, 2 для двоичной системы).\n/// - Parameters:\n///   - text: Входная строка.\n///   - base: База числа.\n/// - Returns: Число в заданной системе счисления.\nfunc stringToNumberWithBase(_ text: String, base: Int) -> Int? {\n    return Int(text, radix: base)\n}"
  },
  {
    "input": "func countUniqueCharacters(in text: String) -> Int {\n    return Set(text).count\n}",
    "output": "/// Преобразует строку в массив символов и возвращает количество уникальных символов.\n/// - Parameter text: Входная строка.\n/// - Returns: Количество уникальных символов.\nfunc countUniqueCharacters(in text: String) -> Int {\n    return Set(text).count\n}"
  },
  {
    "input": "func uniqueCharactersOnly(in text: String) -> String {\n    let characterCount = text.reduce(into: [:]) { counts, char in counts[char, default: 0] += 1 }\n    return String(text.filter { characterCount[$0] == 1 })\n}",
    "output": "/// Возвращает строку, состоящую из символов, которые встречаются в строке не более одного раза.\n/// - Parameter text: Входная строка.\n/// - Returns: Строка с уникальными символами.\nfunc uniqueCharactersOnly(in text: String) -> String {\n    let characterCount = text.reduce(into: [:]) { counts, char in counts[char, default: 0] += 1 }\n    return String(text.filter { characterCount[$0] == 1 })\n}"
  },
  {
    "input": "func isValidEmail(_ text: String) -> Bool {\n    let emailRegex = \"^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\\\.[A-Za-z]{2,}$\"\n    return matchesRegex(text, pattern: emailRegex)\n}",
    "output": "/// Проверяет, является ли строка строкой, представляющей корректный email-адрес.\n/// - Parameter text: Входная строка.\n/// - Returns: true, если строка — корректный email.\nfunc isValidEmail(_ text: String) -> Bool {\n    let emailRegex = \"^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\\\.[A-Za-z]{2,}$\"\n    return matchesRegex(text, pattern: emailRegex)\n}"
  },
  {
    "input": "func extractNumbersFromString(_ text: String) -> String {\n    return text.filter { $0.isNumber }\n}",
    "output": "/// Возвращает строку, которая является результатом склеивания всех чисел из строки.\n/// - Parameter text: Входная строка.\n/// - Returns: Строка, содержащая только числа из исходной строки.\nfunc extractNumbersFromString(_ text: String) -> String {\n    return text.filter { $0.isNumber }\n}"
  },
  {
    "input": "func stringToPercentage(_ text: String, precision: Int) -> String? {\n    guard let number = Double(text) else { return nil }\n    let percentage = number * 100\n    return String(format: \"%.\\(precision)f%%\", percentage)\n}",
    "output": "/// Преобразует строку с числовым значением в проценты.\n/// - Parameters:\n///   - text: Входная строка.\n///   - precision: Количество знаков после запятой.\n/// - Returns: Строка с процентным значением.\nfunc stringToPercentage(_ text: String, precision: Int) -> String? {\n    guard let number = Double(text) else { return nil }\n    let percentage = number * 100\n    return String(format: \"%.\\(precision)f%%\", percentage)\n}"
  },
  {
    "input": "func alternatingUpperAndLowerCase(_ text: String) -> String {\n    return String(text.enumerated().map { (index, char) in\n        index % 2 == 0 ? char.lowercased() : char.uppercased()\n    })\n}",
    "output": "/// Возвращает строку, где символы чередуются между верхним и нижним регистром.\n/// - Parameter text: Входная строка.\n/// - Returns: Строка с чередующимися буквами.\nfunc alternatingUpperAndLowerCase(_ text: String) -> String {\n    return String(text.enumerated().map { (index, char) in\n        index % 2 == 0 ? char.lowercased() : char.uppercased()\n    })\n}"
  },
  {
    "input": "func isNumeric(_ text: String) -> Bool {\n    return Double(text) != nil\n}",
    "output": "/// Проверяет, является ли строка числовым значением, включая десятичную точку.\n/// - Parameter text: Входная строка.\n/// - Returns: true, если строка является числом.\nfunc isNumeric(_ text: String) -> Bool {\n    return Double(text) != nil\n}"
  },
  {
    "input": "func reverseArray<T>(_ array: [T]) -> [T] {\n    return array.reversed()\n}",
    "output": "/// Возвращает элементы массива в обратном порядке.\n/// - Parameter array: Массив.\n/// - Returns: Массив в обратном порядке.\nfunc reverseArray<T>(_ array: [T]) -> [T] {\n    return array.reversed()\n}"
  },
  {
    "input": "func randomElementFromDictionary<Key, Value>(_ dictionary: [Key: Value]) -> (Key, Value)? where Key: Hashable {\n    return dictionary.randomElement()\n}",
    "output": "/// Генерирует случайный элемент из словаря по его значениям.\n/// - Parameter dictionary: Словарь.\n/// - Returns: Случайный элемент словаря.\nfunc randomElementFromDictionary<Key, Value>(_ dictionary: [Key: Value]) -> (Key, Value)? where Key: Hashable {\n    return dictionary.randomElement()\n}"
  },
  {
    "input": "func keysWithMinValues<Key, Value>(_ dictionary: [Key: Value]) -> [Key] where Key: Hashable, Value: Comparable {\n    guard let minValue = dictionary.values.min() else { return [] }\n    return dictionary.filter { $0.value == minValue }.map { $0.key }\n}",
    "output": "/// Возвращает ключи из словаря, которые связаны с минимальными значениями.\n/// - Parameter dictionary: Словарь.\n/// - Returns: Ключи с минимальными значениями.\nfunc keysWithMinValues<Key, Value>(_ dictionary: [Key: Value]) -> [Key] where Key: Hashable, Value: Comparable {\n    guard let minValue = dictionary.values.min() else { return [] }\n    return dictionary.filter { $0.value == minValue }.map { $0.key }\n}"
  },
  {
    "input": "func isFutureDate(_ date: Date) -> Bool {\n    return date > Date()\n}",
    "output": "/// Проверяет, является ли переданная дата в будущем относительно текущей.\n/// - Parameter date: Дата для проверки.\n/// - Returns: `true`, если дата в будущем.\nfunc isFutureDate(_ date: Date) -> Bool {\n    return date > Date()\n}"
  },
  {
    "input": "func stringToAlphabeticCharArray(_ str: String) -> [Character] {\n    return str.filter { $0.isLetter }\n}",
    "output": "/// Преобразует строку в массив символов, фильтруя только буквы.\n/// - Parameter str: Входная строка.\n/// - Returns: Массив символов, содержащих только буквы.\nfunc stringToAlphabeticCharArray(_ str: String) -> [Character] {\n    return str.filter { $0.isLetter }\n}"
  },
  {
    "input": "func daysBetweenDates(startDate: Date, endDate: Date) -> Int {\n    return Calendar.current.dateComponents([.day], from: startDate, to: endDate).day ?? 0\n}",
    "output": "/// Находит разницу между двумя датами в днях.\n/// - Parameters:\n///   - startDate: Начальная дата.\n///   - endDate: Конечная дата.\n/// - Returns: Количество дней между датами.\nfunc daysBetweenDates(startDate: Date, endDate: Date) -> Int {\n    return Calendar.current.dateComponents([.day], from: startDate, to: endDate).day ?? 0\n}"
  },
  {
    "input": "func sumOfNumbersInString(_ str: String) -> Int {\n    let numbers = str.split(separator: \" \").compactMap { Int($0) }\n    return numbers.reduce(0, +)\n}",
    "output": "/// Преобразует строку в массив чисел, разделенных пробелами, и возвращает сумму.\n/// - Parameter str: Входная строка.\n/// - Returns: Сумма чисел в строке.\nfunc sumOfNumbersInString(_ str: String) -> Int {\n    let numbers = str.split(separator: \" \").compactMap { Int($0) }\n    return numbers.reduce(0, +)\n}"
  }
]
