[
  {
    "input": "func add(_ a: Int, _ b: Int) -> Int {\n    return a + b\n}",
    "output": "/// Суммирует два числа.\n/// - Parameters:\n///   - a: Первое число.\n///   - b: Второе число.\n/// - Returns: Сумма a и b.\nfunc add(_ a: Int, _ b: Int) -> Int {\n    return a + b\n}"
  },
  {
    "input": "func average(_ a: Double, _ b: Double, _ c: Double) -> Double {\n    return (a + b + c) / 3\n}",
    "output": "/// Вычисляет среднее трех чисел.\n/// - Parameters:\n///   - a: Первое число.\n///   - b: Второе число.\n///   - c: Третье число.\n/// - Returns: Среднее значение.\nfunc average(_ a: Double, _ b: Double, _ c: Double) -> Double {\n    return (a + b + c) / 3\n}"
  },
  {
    "input": "func isPalindrome(_ str: String) -> Bool {\n    let cleaned = str.lowercased().filter { $0.isLetter }\n    return cleaned == String(cleaned.reversed())\n}",
    "output": "/// Проверяет, является ли строка палиндромом.\n/// - Parameter str: Входная строка.\n/// - Returns: `true`, если строка палиндром.\nfunc isPalindrome(_ str: String) -> Bool {\n    let cleaned = str.lowercased().filter { $0.isLetter }\n    return cleaned == String(cleaned.reversed())\n}"
  },
  {
    "input": "func concatenate(_ a: String, _ b: String) -> String {\n    return a + b\n}",
    "output": "/// Объединяет две строки.\n/// - Parameters:\n///   - a: Первая строка.\n///   - b: Вторая строка.\n/// - Returns: Объединенная строка.\nfunc concatenate(_ a: String, _ b: String) -> String {\n    return a + b\n}"
  },
  {
    "input": "func isDivisible(_ number: Int, by divisor: Int) -> Bool {\n    return number % divisor == 0\n}",
    "output": "/// Проверяет, делится ли число нацело.\n/// - Parameters:\n///   - number: Число.\n///   - divisor: Делитель.\n/// - Returns: `true`, если делится без остатка.\nfunc isDivisible(_ number: Int, by divisor: Int) -> Bool {\n    return number % divisor == 0\n}"
  },
  {
    "input": "func rectangleArea(length: Double, width: Double) -> Double {\n    return length * width\n}",
    "output": "/// Вычисляет площадь прямоугольника.\n/// - Parameters:\n///   - length: Длина.\n///   - width: Ширина.\n/// - Returns: Площадь.\nfunc rectangleArea(length: Double, width: Double) -> Double {\n    return length * width\n}"
  },
  {
    "input": "func celsiusToFahrenheit(_ celsius: Double) -> Double {\n    return celsius * 9/5 + 32\n}",
    "output": "/// Конвертирует градусы Цельсия в Фаренгейты.\n/// - Parameter celsius: Температура в Цельсиях.\n/// - Returns: Температура в Фаренгейтах.\nfunc celsiusToFahrenheit(_ celsius: Double) -> Double {\n    return celsius * 9/5 + 32\n}"
  },
  {
    "input": "func maxOfThree(_ a: Int, _ b: Int, _ c: Int) -> Int {\n    return max(a, max(b, c))\n}",
    "output": "/// Находит максимальное из трех чисел.\n/// - Parameters:\n///   - a: Первое число.\n///   - b: Второе число.\n///   - c: Третье число.\n/// - Returns: Максимальное число.\nfunc maxOfThree(_ a: Int, _ b: Int, _ c: Int) -> Int {\n    return max(a, max(b, c))\n}"
  },
  {
    "input": "func isEven(_ number: Int) -> Bool {\n    return number % 2 == 0\n}",
    "output": "/// Проверяет четность числа.\n/// - Parameter number: Число.\n/// - Returns: `true`, если число четное.\nfunc isEven(_ number: Int) -> Bool {\n    return number % 2 == 0\n}"
  },
  {
    "input": "func power(_ base: Double, _ exponent: Double) -> Double {\n    return pow(base, exponent)\n}",
    "output": "/// Возводит число в степень.\n/// - Parameters:\n///   - base: Основание.\n///   - exponent: Показатель степени.\n/// - Returns: Результат возведения в степень.\nfunc power(_ base: Double, _ exponent: Double) -> Double {\n    return pow(base, exponent)\n}"
  },
  {
    "input": "func countCharacters(_ str: String) -> Int {\n    return str.count\n}",
    "output": "/// Считает количество символов в строке.\n/// - Parameter str: Входная строка.\n/// - Returns: Количество символов.\nfunc countCharacters(_ str: String) -> Int {\n    return str.count\n}"
  },
  {
    "input": "func reversedArray<T>(_ array: [T]) -> [T] {\n    return array.reversed()\n}",
    "output": "/// Переворачивает массив.\n/// - Parameter array: Входной массив.\n/// - Returns: Перевернутый массив.\nfunc reversedArray<T>(_ array: [T]) -> [T] {\n    return array.reversed()\n}"
  },
  {
    "input": "func contains<T: Equatable>(_ array: [T], _ element: T) -> Bool {\n    return array.contains(element)\n}",
    "output": "/// Проверяет наличие элемента в массиве.\n/// - Parameters:\n///   - array: Массив.\n///   - element: Искомый элемент.\n/// - Returns: `true`, если элемент найден.\nfunc contains<T: Equatable>(_ array: [T], _ element: T) -> Bool {\n    return array.contains(element)\n}"
  },
  {
    "input": "func combineArrays<T>(_ a: [T], _ b: [T]) -> [T] {\n    return a + b\n}",
    "output": "/// Объединяет два массива.\n/// - Parameters:\n///   - a: Первый массив.\n///   - b: Второй массив.\n/// - Returns: Объединенный массив.\nfunc combineArrays<T>(_ a: [T], _ b: [T]) -> [T] {\n    return a + b\n}"
  },
  {
    "input": "func countVowels(_ str: String) -> Int {\n    let vowels: Set<Character> = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    return str.lowercased().filter { vowels.contains($0) }.count\n}",
    "output": "/// Считает количество гласных в строке.\n/// - Parameter str: Входная строка.\n/// - Returns: Число гласных.\nfunc countVowels(_ str: String) -> Int {\n    let vowels: Set<Character> = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    return str.lowercased().filter { vowels.contains($0) }.count\n}"
  },
  {
    "input": "func removeSpaces(_ str: String) -> String {\n    return str.replacingOccurrences(of: \" \", with: \"\")\n}",
    "output": "/// Удаляет пробелы из строки.\n/// - Parameter str: Входная строка.\n/// - Returns: Строка без пробелов.\nfunc removeSpaces(_ str: String) -> String {\n    return str.replacingOccurrences(of: \" \", with: \"\")\n}"
  },
  {
    "input": "func squaredNumbers(_ numbers: [Double]) -> [Double] {\n    return numbers.map { $0 * $0 }\n}",
    "output": "/// Возводит элементы массива в квадрат.\n/// - Parameter numbers: Массив чисел.\n/// - Returns: Массив квадратов.\nfunc squaredNumbers(_ numbers: [Double]) -> [Double] {\n    return numbers.map { $0 * $0 }\n}"
  },
  {
    "input": "func isLeapYear(_ year: Int) -> Bool {\n    return (year % 4 == 0 && year % 100 != 0) || year % 400 == 0\n}",
    "output": "/// Проверяет, является ли год високосным.\n/// - Parameter year: Год.\n/// - Returns: `true`, если високосный.\nfunc isLeapYear(_ year: Int) -> Bool {\n    return (year % 4 == 0 && year % 100 != 0) || year % 400 == 0\n}"
  },
  {
    "input": "func factorial(_ n: Int) -> Int {\n    return n == 0 ? 1 : n * factorial(n - 1)\n}",
    "output": "/// Вычисляет факториал числа.\n/// - Parameter n: Число.\n/// - Returns: Факториал.\nfunc factorial(_ n: Int) -> Int {\n    return n == 0 ? 1 : n * factorial(n - 1)\n}"
  },
  {
    "input": "func isPrime(_ number: Int) -> Bool {\n    guard number > 1 else { return false }\n    for i in 2..<number {\n        if number % i == 0 { return false }\n    }\n    return true\n}",
    "output": "/// Проверяет, является ли число простым.\n/// - Parameter number: Число.\n/// - Returns: `true`, если число простое.\nfunc isPrime(_ number: Int) -> Bool {\n    guard number > 1 else { return false }\n    for i in 2..<number {\n        if number % i == 0 { return false }\n    }\n    return true\n}"
  },
  {
    "input": "func convertMinutes(_ minutes: Int) -> (hours: Int, minutes: Int) {\n    return (minutes / 60, minutes % 60)\n}",
    "output": "/// Конвертирует минуты в часы и минуты.\n/// - Parameter minutes: Общее количество минут.\n/// - Returns: Кортеж (часы, минуты).\nfunc convertMinutes(_ minutes: Int) -> (hours: Int, minutes: Int) {\n    return (minutes / 60, minutes % 60)\n}"
  },
  {
    "input": "func gcd(_ a: Int, _ b: Int) -> Int {\n    var (x, y) = (a, b)\n    while y != 0 {\n        (x, y) = (y, x % y)\n    }\n    return x\n}",
    "output": "/// Находит НОД двух чисел.\n/// - Parameters:\n///   - a: Первое число.\n///   - b: Второе число.\n/// - Returns: Наибольший общий делитель.\nfunc gcd(_ a: Int, _ b: Int) -> Int {\n    var (x, y) = (a, b)\n    while y != 0 {\n        (x, y) = (y, x % y)\n    }\n    return x\n}"
  },
  {
    "input": "func lcm(_ a: Int, _ b: Int) -> Int {\n    return (a * b) / gcd(a, b)\n}",
    "output": "/// Находит НОК двух чисел.\n/// - Parameters:\n///   - a: Первое число.\n///   - b: Второе число.\n/// - Returns: Наименьшее общее кратное.\nfunc lcm(_ a: Int, _ b: Int) -> Int {\n    return (a * b) / gcd(a, b)\n}"
  },
  {
    "input": "func allUnique<T: Hashable>(_ array: [T]) -> Bool {\n    return Set(array).count == array.count\n}",
    "output": "/// Проверяет уникальность элементов массива.\n/// - Parameter array: Массив.\n/// - Returns: `true`, если все элементы уникальны.\nfunc allUnique<T: Hashable>(_ array: [T]) -> Bool {\n    return Set(array).count == array.count\n}"
  },
  {
    "input": "func capitalizeFirstLetter(_ str: String) -> String {\n    guard !str.isEmpty else { return str }\n    return str.prefix(1).uppercased() + str.dropFirst()\n}",
    "output": "/// Капитализирует первую букву строки.\n/// - Parameter str: Входная строка.\n/// - Returns: Строка с заглавной первой буквой.\nfunc capitalizeFirstLetter(_ str: String) -> String {\n    guard !str.isEmpty else { return str }\n    return str.prefix(1).uppercased() + str.dropFirst()\n}"
  },
  {
    "input": "func countCharacter(_ str: String, _ char: Character) -> Int {\n    return str.filter { $0 == char }.count\n}",
    "output": "/// Считает количество заданного символа в строке.\n/// - Parameters:\n///   - str: Строка.\n///   - char: Искомый символ.\n/// - Returns: Количество вхождений.\nfunc countCharacter(_ str: String, _ char: Character) -> Int {\n    return str.filter { $0 == char }.count\n}"
  },
  {
    "input": "func extractNumbers(_ str: String) -> [Int] {\n    return str.compactMap { Int(String($0)) }\n}",
    "output": "/// Извлекает цифры из строки.\n/// - Parameter str: Входная строка.\n/// - Returns: Массив цифр.\nfunc extractNumbers(_ str: String) -> [Int] {\n    return str.compactMap { Int(String($0)) }\n}"
  },
  {
    "input": "func isSorted(_ array: [Int]) -> Bool {\n    return array == array.sorted()\n}",
    "output": "/// Проверяет отсортирован ли массив.\n/// - Parameter array: Массив чисел.\n/// - Returns: `true`, если отсортирован.\nfunc isSorted(_ array: [Int]) -> Bool {\n    return array == array.sorted()\n}"
  },
  {
    "input": "func greeting(_ name: String) -> String {\n    return \"Hello, \\(name)!\"\n}",
    "output": "/// Генерирует приветствие.\n/// - Parameter name: Имя.\n/// - Returns: Приветственная строка.\nfunc greeting(_ name: String) -> String {\n    return \"Hello, \\(name)!\"\n}"
  },
  {
    "input": "func randomNumber(min: Int, max: Int) -> Int {\n    return Int.random(in: min...max)\n}",
    "output": "/// Генерирует случайное число в диапазоне.\n/// - Parameters:\n///   - min: Минимальное значение.\n///   - max: Максимальное значение.\n/// - Returns: Случайное число.\nfunc randomNumber(min: Int, max: Int) -> Int {\n    return Int.random(in: min...max)\n}"
  },
  {
    "input": "func isSquare(_ a: Int, of b: Int) -> Bool {\n    return a * a == b\n}",
    "output": "/// Проверяет, является ли число квадратом другого.\n/// - Parameters:\n///   - a: Число.\n///   - b: Возможный квадрат.\n/// - Returns: `true`, если b = a².\nfunc isSquare(_ a: Int, of b: Int) -> Bool {\n    return a * a == b\n}"
  },
  {
    "input": "func sumArray(_ numbers: [Double]) -> Double {\n    return numbers.reduce(0, +)\n}",
    "output": "/// Суммирует элементы массива.\n/// - Parameter numbers: Массив чисел.\n/// - Returns: Сумма элементов.\nfunc sumArray(_ numbers: [Double]) -> Double {\n    return numbers.reduce(0, +)\n}"
  },
  {
    "input": "func findMin(_ numbers: [Int]) -> Int {\n    return numbers.min() ?? 0\n}",
    "output": "/// Находит минимальный элемент массива.\n/// - Parameter numbers: Массив чисел.\n/// - Returns: Минимальное значение.\nfunc findMin(_ numbers: [Int]) -> Int {\n    return numbers.min() ?? 0\n}"
  },
  {
    "input": "func stringToArray(_ str: String) -> [Character] {\n    return Array(str)\n}",
    "output": "/// Преобразует строку в массив символов.\n/// - Parameter str: Входная строка.\n/// - Returns: Массив символов.\nfunc stringToArray(_ str: String) -> [Character] {\n    return Array(str)\n}"
  },
  {
    "input": "func replaceSubstring(_ original: String, _ old: String, _ new: String) -> String {\n    return original.replacingOccurrences(of: old, with: new)\n}",
    "output": "/// Заменяет подстроку в строке.\n/// - Parameters:\n///   - original: Исходная строка.\n///   - old: Заменяемая подстрока.\n///   - new: Новая подстрока.\n/// - Returns: Модифицированная строка.\nfunc replaceSubstring(_ original: String, _ old: String, _ new: String) -> String {\n    return original.replacingOccurrences(of: old, with: new)\n}"
  },
  {
    "input": "func isBlank(_ str: String) -> Bool {\n    return str.trimmingCharacters(in: .whitespaces).isEmpty\n}",
    "output": "/// Проверяет пустую строку или пробелы.\n/// - Parameter str: Входная строка.\n/// - Returns: `true`, если строка пуста или содержит только пробелы.\nfunc isBlank(_ str: String) -> Bool {\n    return str.trimmingCharacters(in: .whitespaces).isEmpty\n}"
  },
  {
    "input": "func areAnagrams(_ a: String, _ b: String) -> Bool {\n    return a.lowercased().sorted() == b.lowercased().sorted()\n}",
    "output": "/// Проверяет анаграммы.\n/// - Parameters:\n///   - a: Первая строка.\n///   - b: Вторая строка.\n/// - Returns: `true`, если строки - анаграммы.\nfunc areAnagrams(_ a: String, _ b: String) -> Bool {\n    return a.lowercased().sorted() == b.lowercased().sorted()\n}"
  },
  {
    "input": "func decimalToBinary(_ decimal: Int) -> String {\n    return String(decimal, radix: 2)\n}",
    "output": "/// Конвертирует десятичное число в двоичное.\n/// - Parameter decimal: Десятичное число.\n/// - Returns: Двоичная строка.\nfunc decimalToBinary(_ decimal: Int) -> String {\n    return String(decimal, radix: 2)\n}"
  },
  {
    "input": "func isValidEmail(_ email: String) -> Bool {\n    let pattern = \"[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\\\.[A-Za-z]{2,64}\"\n    return email.range(of: pattern, options: .regularExpression) != nil\n}",
    "output": "/// Проверяет валидность email.\n/// - Parameter email: Строка с email.\n/// - Returns: `true`, если email валиден.\nfunc isValidEmail(_ email: String) -> Bool {\n    let pattern = \"[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\\\.[A-Za-z]{2,64}\"\n    return email.range(of: pattern, options: .regularExpression) != nil\n}"
  },
  {
    "input": "func calculateBMI(weight: Double, height: Double) -> Double {\n    return weight / (height * height)\n}",
    "output": "/// Вычисляет индекс массы тела (ИМТ).\n/// - Parameters:\n///   - weight: Вес в кг.\n///   - height: Рост в метрах.\n/// - Returns: Значение ИМТ.\nfunc calculateBMI(weight: Double, height: Double) -> Double {\n    return weight / (height * height)\n}"
  },
  {
    "input": "func metersToKilometers(_ meters: Double) -> Double {\n    return meters / 1000\n}",
    "output": "/// Конвертирует метры в километры.\n/// - Parameter meters: Значение в метрах.\n/// - Returns: Значение в километрах.\nfunc metersToKilometers(_ meters: Double) -> Double {\n    return meters / 1000\n}"
  },
  {
    "input": "func formatCurrency(_ number: Double, currency: String, locale: Locale = .current) -> String? {\n    let formatter = NumberFormatter()\n    formatter.numberStyle = .currency\n    formatter.currencyCode = currency\n    formatter.locale = locale\n    return formatter.string(from: NSNumber(value: number))\n}",
    "output": "/// Форматирует число как валюту.\n/// - Parameters:\n///   - number: Число.\n///   - currency: Код валюты (например, \"USD\").\n///   - locale: Локаль (по умолчанию текущая).\n/// - Returns: Отформатированная строка.\nfunc formatCurrency(_ number: Double, currency: String, locale: Locale = .current) -> String? {\n    let formatter = NumberFormatter()\n    formatter.numberStyle = .currency\n    formatter.currencyCode = currency\n    formatter.locale = locale\n    return formatter.string(from: NSNumber(value: number))\n}"
  },
  {
    "input": "func containsCaseInsensitive(_ str: String, _ substring: String) -> Bool {\n    return str.lowercased().contains(substring.lowercased())\n}",
    "output": "/// Проверяет вхождение подстроки без учета регистра.\n/// - Parameters:\n///   - str: Строка.\n///   - substring: Подстрока.\n/// - Returns: `true`, если содержит.\nfunc containsCaseInsensitive(_ str: String, _ substring: String) -> Bool {\n    return str.lowercased().contains(substring.lowercased())\n}"
  },
  {
    "input": "func removeHTMLTags(_ html: String) -> String {\n    return html.replacingOccurrences(of: \"<[^>]+>\", with: \"\", options: .regularExpression)\n}",
    "output": "/// Удаляет HTML теги из строки.\n/// - Parameter html: HTML строка.\n/// - Returns: Текст без тегов.\nfunc removeHTMLTags(_ html: String) -> String {\n    return html.replacingOccurrences(of: \"<[^>]+>\", with: \"\", options: .regularExpression)\n}"
  },
  {
    "input": "func countWords(_ str: String) -> Int {\n    return str.components(separatedBy: .whitespacesAndNewlines).filter { !$0.isEmpty }.count\n}",
    "output": "/// Считает количество слов в строке.\n/// - Parameter str: Входная строка.\n/// - Returns: Число слов.\nfunc countWords(_ str: String) -> Int {\n    return str.components(separatedBy: .whitespacesAndNewlines).filter { !$0.isEmpty }.count\n}"
  },
  {
    "input": "func sortStringsAlphabetically(_ strings: [String]) -> [String] {\n    return strings.sorted()\n}",
    "output": "/// Сортирует массив строк по алфавиту.\n/// - Parameter strings: Массив строк.\n/// - Returns: Отсортированный массив.\nfunc sortStringsAlphabetically(_ strings: [String]) -> [String] {\n    return strings.sorted()\n}"
  },
  {
    "input": "func dictionaryToTuples<T: Hashable, U>(_ dict: [T: U]) -> [(T, U)] {\n    return Array(dict)\n}",
    "output": "/// Преобразует словарь в массив кортежей.\n/// - Parameter dict: Входной словарь.\n/// - Returns: Массив кортежей (ключ, значение).\nfunc dictionaryToTuples<T: Hashable, U>(_ dict: [T: U]) -> [(T, U)] {\n    return Array(dict)\n}"
  },
  {
    "input": "func allSatisfy<T>(_ array: [T], _ condition: (T) -> Bool) -> Bool {\n    return array.allSatisfy(condition)\n}",
    "output": "/// Проверяет условие для всех элементов массива.\n/// - Parameters:\n///   - array: Массив.\n///   - condition: Условие (замыкание).\n/// - Returns: `true`, если все элементы удовлетворяют условию.\nfunc allSatisfy<T>(_ array: [T], _ condition: (T) -> Bool) -> Bool {\n    return array.allSatisfy(condition)\n}"
  },
  {
    "input": "func romanToInt(_ roman: String) -> Int {\n    let values: [Character: Int] = [\"I\":1, \"V\":5, \"X\":10, \"L\":50, \"C\":100, \"D\":500, \"M\":1000]\n    var total = 0\n    var prev = 0\n    for char in roman.reversed() {\n        let value = values[char] ?? 0\n        total += (value >= prev) ? value : -value\n        prev = value\n    }\n    return total\n}",
    "output": "/// Конвертирует римские цифры в целое число.\n/// - Parameter roman: Римское число.\n/// - Returns: Целое число.\nfunc romanToInt(_ roman: String) -> Int {\n    let values: [Character: Int] = [\"I\":1, \"V\":5, \"X\":10, \"L\":50, \"C\":100, \"D\":500, \"M\":1000]\n    var total = 0\n    var prev = 0\n    for char in roman.reversed() {\n        let value = values[char] ?? 0\n        total += (value >= prev) ? value : -value\n        prev = value\n    }\n    return total\n}"
  },
  {
    "input": "func calculateTax(amount: Double, taxRate: Double) -> Double {\n    return amount * taxRate / 100\n}",
    "output": "/// Вычисляет сумму налога.\n/// - Parameters:\n///   - amount: Сумма.\n///   - taxRate: Процент налога.\n/// - Returns: Сумма налога.\nfunc calculateTax(amount: Double, taxRate: Double) -> Double {\n    return amount * taxRate / 100\n}"
  },
  {
    "input": "func isSubset<T: Hashable>(_ subset: [T], of set: [T]) -> Bool {\n    let setSet = Set(set)\n    return subset.allSatisfy { setSet.contains($0) }\n}",
    "output": "/// Проверяет, является ли массив подмножеством.\n/// - Parameters:\n///   - subset: Подмножество.\n///   - set: Основное множество.\n/// - Returns: `true`, если subset содержится в set.\nfunc isSubset<T: Hashable>(_ subset: [T], of set: [T]) -> Bool {\n    let setSet = Set(set)\n    return subset.allSatisfy { setSet.contains($0) }\n}"
  },
  {
    "input": "func arrayAverage(_ numbers: [Double]) -> Double {\n    return numbers.reduce(0, +) / Double(numbers.count)\n}",
    "output": "/// Вычисляет среднее значение массива.\n/// - Parameter numbers: Массив чисел.\n/// - Returns: Среднее значение.\nfunc arrayAverage(_ numbers: [Double]) -> Double {\n    return numbers.reduce(0, +) / Double(numbers.count)\n}"
  },
  {
    "input": "func mostFrequent<T: Hashable>(_ array: [T]) -> T? {\n    let counts = array.reduce(into: [:]) { $0[$1, default:0] += 1 }\n    return counts.max { $0.value < $1.value }?.key\n}",
    "output": "/// Находит наиболее частый элемент массива.\n/// - Parameter array: Массив.\n/// - Returns: Самый частый элемент.\nfunc mostFrequent<T: Hashable>(_ array: [T]) -> T? {\n    let counts = array.reduce(into: [:]) { $0[$1, default:0] += 1 }\n    return counts.max { $0.value < $1.value }?.key\n}"
  },
  {
    "input": "func toCamelCase(_ str: String) -> String {\n    let parts = str.components(separatedBy: CharacterSet.alphanumerics.inverted)\n    guard let first = parts.first else { return \"\" }\n    let rest = parts.dropFirst().map { $0.capitalized }\n    return first + rest.joined()\n}",
    "output": "/// Преобразует строку в CamelCase.\n/// - Parameter str: Входная строка.\n/// - Returns: Строка в CamelCase.\nfunc toCamelCase(_ str: String) -> String {\n    let parts = str.components(separatedBy: CharacterSet.alphanumerics.inverted)\n    guard let first = parts.first else { return \"\" }\n    let rest = parts.dropFirst().map { $0.capitalized }\n    return first + rest.joined()\n}"
  },
  {
    "input": "func caesarCipher(_ str: String, shift: Int, encrypt: Bool) -> String {\n    let shift = encrypt ? shift : 26 - shift\n    return String(str.unicodeScalars.map { c in\n        if c.isASCII && c.isLetter {\n            let base = c.value >= 65 && c.value <= 90 ? 65 : 97\n            return Character(UnicodeScalar((Int(c.value) - base + shift) % 26 + base)!)\n        }\n        return Character(c)\n    })\n}",
    "output": "/// Шифрует строку шифром Цезаря.\n/// - Parameters:\n///   - str: Исходная строка.\n///   - shift: Сдвиг.\n///   - encrypt: true - шифрование, false - дешифровка.\n/// - Returns: Результирующая строка.\nfunc caesarCipher(_ str: String, shift: Int, encrypt: Bool) -> String {\n    let shift = encrypt ? shift : 26 - shift\n    return String(str.unicodeScalars.map { c in\n        if c.isASCII && c.isLetter {\n            let base = c.value >= 65 && c.value <= 90 ? 65 : 97\n            return Character(UnicodeScalar((Int(c.value) - base + shift) % 26 + base)!)\n        }\n        return Character(c)\n    })\n}"
  },
  {
    "input": "func isBalancedParentheses(_ str: String) -> Bool {\n    var stack = 0\n    for char in str {\n        if char == \"(\" { stack += 1 }\n        else if char == \")\" {\n            stack -= 1\n            if stack < 0 { return false }\n        }\n    }\n    return stack == 0\n}",
    "output": "/// Проверяет баланс скобок в строке.\n/// - Parameter str: Входная строка.\n/// - Returns: `true`, если скобки сбалансированы.\nfunc isBalancedParentheses(_ str: String) -> Bool {\n    var stack = 0\n    for char in str {\n        if char == \"(\" { stack += 1 }\n        else if char == \")\" {\n            stack -= 1\n            if stack < 0 { return false }\n        }\n    }\n    return stack == 0\n}"
  },
  {
    "input": "func kmhToMs(_ kmh: Double) -> Double {\n    return kmh * 1000 / 3600\n}",
    "output": "/// Конвертирует км/ч в м/с.\n/// - Parameter kmh: Скорость в км/ч.\n/// - Returns: Скорость в м/с.\nfunc kmhToMs(_ kmh: Double) -> Double {\n    return kmh * 1000 / 3600\n}"
  },
  {
    "input": "func generateUUID() -> String {\n    return UUID().uuidString\n}",
    "output": "/// Генерирует UUID.\n/// - Returns: Строка UUID.\nfunc generateUUID() -> String {\n    return UUID().uuidString\n}"
  },
  {
    "input": "func isValidPhone(_ phone: String) -> Bool {\n    let pattern = \"^\\\\+?\\\\d{10,}$\"\n    return phone.range(of: pattern, options: .regularExpression) != nil\n}",
    "output": "/// Проверяет валидность номера телефона (простая проверка).\n/// - Parameter phone: Номер телефона.\n/// - Returns: `true`, если номер валиден.\nfunc isValidPhone(_ phone: String) -> Bool {\n    let pattern = \"^\\\\+?\\\\d{10,}$\"\n    return phone.range(of: pattern, options: .regularExpression) != nil\n}"
  },
  {
    "input": "func distance(x1: Double, y1: Double, x2: Double, y2: Double) -> Double {\n    return sqrt(pow(x2 - x1, 2) + pow(y2 - y1, 2))\n}",
    "output": "/// Вычисляет расстояние между двумя точками.\n/// - Parameters:\n///   - x1: X координата первой точки.\n///   - y1: Y координата первой точки.\n///   - x2: X координата второй точки.\n///   - y2: Y координата второй точки.\n/// - Returns: Евклидово расстояние.\nfunc distance(x1: Double, y1: Double, x2: Double, y2: Double) -> Double {\n    return sqrt(pow(x2 - x1, 2) + pow(y2 - y1, 2))\n}"
  },
  {
    "input": "func convertTemperature(_ value: Double, from: String, to: String) -> Double {\n    switch (from.uppercased(), to.uppercased()) {\n    case (\"C\", \"F\"): return value * 9/5 + 32\n    case (\"C\", \"K\"): return value + 273.15\n    case (\"F\", \"C\"): return (value - 32) * 5/9\n    case (\"F\", \"K\"): return (value - 32) * 5/9 + 273.15\n    case (\"K\", \"C\"): return value - 273.15\n    case (\"K\", \"F\"): return (value - 273.15) * 9/5 + 32\n    default: return value\n    }\n}",
    "output": "/// Конвертирует температуру между шкалами.\n/// - Parameters:\n///   - value: Исходное значение.\n///   - from: Исходная шкала (C, F, K).\n///   - to: Целевая шкала (C, F, K).\n/// - Returns: Конвертированное значение.\nfunc convertTemperature(_ value: Double, from: String, to: String) -> Double {\n    switch (from.uppercased(), to.uppercased()) {\n    case (\"C\", \"F\"): return value * 9/5 + 32\n    case (\"C\", \"K\"): return value + 273.15\n    case (\"F\", \"C\"): return (value - 32) * 5/9\n    case (\"F\", \"K\"): return (value - 32) * 5/9 + 273.15\n    case (\"K\", \"C\"): return value - 273.15\n    case (\"K\", \"F\"): return (value - 273.15) * 9/5 + 32\n    default: return value\n    }\n}"
  },
  {
    "input": "func isPowerOfTwo(_ number: Int) -> Bool {\n    return number > 0 && (number & (number - 1)) == 0\n}",
    "output": "/// Проверяет, является ли число степенью двойки.\n/// - Parameter number: Число.\n/// - Returns: `true`, если число - степень двойки.\nfunc isPowerOfTwo(_ number: Int) -> Bool {\n    return number > 0 && (number & (number - 1)) == 0\n}"
  },
  {
    "input": "func daysBetween(date1: Date, date2: Date) -> Int {\n    return Calendar.current.dateComponents([.day], from: date1, to: date2).day ?? 0\n}",
    "output": "/// Считает разницу в днях между двумя датами.\n/// - Parameters:\n///   - date1: Первая дата.\n///   - date2: Вторая дата.\n/// - Returns: Количество дней.\nfunc daysBetween(date1: Date, date2: Date) -> Int {\n    return Calendar.current.dateComponents([.day], from: date1, to: date2).day ?? 0\n}"
  },
  {
    "input": "func isNumeric(_ str: String) -> Bool {\n    return Double(str) != nil\n}",
    "output": "/// Проверяет, является ли строка числом.\n/// - Parameter str: Входная строка.\n/// - Returns: `true`, если строка может быть конвертирована в число.\nfunc isNumeric(_ str: String) -> Bool {\n    return Double(str) != nil\n}"
  },
  {
    "input": "func polygonPerimeter(_ sides: Double...) -> Double {\n    return sides.reduce(0, +)\n}",
    "output": "/// Вычисляет периметр многоугольника.\n/// - Parameter sides: Длины сторон.\n/// - Returns: Сумма длин сторон.\nfunc polygonPerimeter(_ sides: Double...) -> Double {\n    return sides.reduce(0, +)\n}"
  },
  {
    "input": "func hasDuplicates<T: Hashable>(_ array: [T]) -> Bool {\n    return Set(array).count != array.count\n}",
    "output": "/// Проверяет наличие дубликатов в массиве.\n/// - Parameter array: Массив.\n/// - Returns: `true`, если есть дубликаты.\nfunc hasDuplicates<T: Hashable>(_ array: [T]) -> Bool {\n    return Set(array).count != array.count\n}"
  },
  {
    "input": "func sumOfDigits(_ number: Int) -> Int {\n    return String(number).compactMap { Int(String($0)) }.reduce(0, +)\n}",
    "output": "/// Считает сумму цифр числа.\n/// - Parameter number: Число.\n/// - Returns: Сумма цифр.\nfunc sumOfDigits(_ number: Int) -> Int {\n    return String(number).compactMap { Int(String($0)) }.reduce(0, +)\n}"
  },
  {
    "input": "func joinArray(_ array: [String], separator: String) -> String {\n    return array.joined(separator: separator)\n}",
    "output": "/// Объединяет массив строк в строку с разделителем.\n/// - Parameters:\n///   - array: Массив строк.\n///   - separator: Разделитель.\n/// - Returns: Объединенная строка.\nfunc joinArray(_ array: [String], separator: String) -> String {\n    return array.joined(separator: separator)\n}"
  },
  {
    "input": "func fibonacci(_ n: Int) -> Int {\n    guard n > 1 else { return n }\n    return fibonacci(n-1) + fibonacci(n-2)\n}",
    "output": "/// Вычисляет n-е число Фибоначчи.\n/// - Parameter n: Порядковый номер.\n/// - Returns: Число Фибоначчи.\nfunc fibonacci(_ n: Int) -> Int {\n    guard n > 1 else { return n }\n    return fibonacci(n-1) + fibonacci(n-2)\n}"
  },
  {
    "input": "func secondsToTime(_ totalSeconds: Int) -> (hours: Int, minutes: Int, seconds: Int) {\n    return (totalSeconds / 3600, (totalSeconds % 3600) / 60, totalSeconds % 60)\n}",
    "output": "/// Конвертирует секунды в часы, минуты и секунды.\n/// - Parameter totalSeconds: Общее количество секунд.\n/// - Returns: Кортеж (часы, минуты, секунды).\nfunc secondsToTime(_ totalSeconds: Int) -> (hours: Int, minutes: Int, seconds: Int) {\n    return (totalSeconds / 3600, (totalSeconds % 3600) / 60, totalSeconds % 60)\n}"
  },
  {
    "input": "func countConsonants(_ str: String) -> Int {\n    let vowels: Set<Character> = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    return str.lowercased().filter { $0.isLetter && !vowels.contains($0) }.count\n}",
    "output": "/// Считает количество согласных в строке.\n/// - Parameter str: Входная строка.\n/// - Returns: Количество согласных.\nfunc countConsonants(_ str: String) -> Int {\n    let vowels: Set<Character> = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    return str.lowercased().filter { $0.isLetter && !vowels.contains($0) }.count\n}"
  },
  {
    "input": "func isPointInCircle(x: Double, y: Double, centerX: Double, centerY: Double, radius: Double) -> Bool {\n    return pow(x - centerX, 2) + pow(y - centerY, 2) <= pow(radius, 2)\n}",
    "output": "/// Проверяет, находится ли точка внутри круга.\n/// - Parameters:\n///   - x: X координата точки.\n///   - y: Y координата точки.\n///   - centerX: X координата центра круга.\n///   - centerY: Y координата центра круга.\n///   - radius: Радиус круга.\n/// - Returns: `true`, если точка внутри круга.\nfunc isPointInCircle(x: Double, y: Double, centerX: Double, centerY: Double, radius: Double) -> Bool {\n    return pow(x - centerX, 2) + pow(y - centerY, 2) <= pow(radius, 2)\n}"
  },
  {
    "input": "func matrixDeterminant(a: Double, b: Double, c: Double, d: Double) -> Double {\n    return a * d - b * c\n}",
    "output": "/// Вычисляет детерминант матрицы 2x2.\n/// - Parameters:\n///   - a: Элемент a11.\n///   - b: Элемент a12.\n///   - c: Элемент a21.\n///   - d: Элемент a22.\n/// - Returns: Детерминант.\nfunc matrixDeterminant(a: Double, b: Double, c: Double, d: Double) -> Double {\n    return a * d - b * c\n}"
  },
  {
    "input": "func binaryToDecimal(_ binary: String) -> Int? {\n    return Int(binary, radix: 2)\n}",
    "output": "/// Конвертирует двоичную строку в десятичное число.\n/// - Parameter binary: Двоичная строка.\n/// - Returns: Десятичное число.\nfunc binaryToDecimal(_ binary: String) -> Int? {\n    return Int(binary, radix: 2)\n}"
  },
  {
    "input": "func secondLargest(_ numbers: [Int]) -> Int? {\n    let sorted = numbers.sorted(by: >)\n    return sorted.count >= 2 ? sorted[1] : nil\n}",
    "output": "/// Находит второй по величине элемент массива.\n/// - Parameter numbers: Массив чисел.\n/// - Returns: Второй максимальный элемент.\nfunc secondLargest(_ numbers: [Int]) -> Int? {\n    let sorted = numbers.sorted(by: >)\n    return sorted.count >= 2 ? sorted[1] : nil\n}"
  },
  {
    "input": "func isPangram(_ str: String) -> Bool {\n    let letters = str.lowercased().filter { $0.isLetter }\n    return Set(letters).count >= 26\n}",
    "output": "/// Проверяет, является ли строка панграммой.\n/// - Parameter str: Входная строка.\n/// - Returns: `true`, если содержит все буквы алфавита.\nfunc isPangram(_ str: String) -> Bool {\n    let letters = str.lowercased().filter { $0.isLetter }\n    return Set(letters).count >= 26\n}"
  },
  {
    "input": "func applyDiscount(price: Double, discount: Double) -> Double {\n    return price * (1 - discount / 100)\n}",
    "output": "/// Вычисляет цену со скидкой.\n/// - Parameters:\n///   - price: Исходная цена.\n///   - discount: Процент скидки.\n/// - Returns: Цена после скидки.\nfunc applyDiscount(price: Double, discount: Double) -> Double {\n    return price * (1 - discount / 100)\n}"
  },
  {
    "input": "func degreesToRadians(_ degrees: Double) -> Double {\n    return degrees * .pi / 180\n}",
    "output": "/// Конвертирует градусы в радианы.\n/// - Parameter degrees: Угол в градусах.\n/// - Returns: Угол в радианах.\nfunc degreesToRadians(_ degrees: Double) -> Double {\n    return degrees * .pi / 180\n}"
  },
  {
    "input": "func isTriangle(_ a: Double, _ b: Double, _ c: Double) -> Bool {\n    return a + b > c && a + c > b && b + c > a\n}",
    "output": "/// Проверяет, могут ли три числа быть сторонами треугольника.\n/// - Parameters:\n///   - a: Первая сторона.\n///   - b: Вторая сторона.\n///   - c: Третья сторона.\n/// - Returns: `true`, если выполняется неравенство треугольника.\nfunc isTriangle(_ a: Double, _ b: Double, _ c: Double) -> Bool {\n    return a + b > c && a + c > b && b + c > a\n}"
  },
  {
    "input": "func heronsFormula(a: Double, b: Double, c: Double) -> Double? {\n    guard isTriangle(a, b, c) else { return nil }\n    let s = (a + b + c) / 2\n    return sqrt(s * (s - a) * (s - b) * (s - c))\n}",
    "output": "/// Вычисляет площадь треугольника по формуле Герона.\n/// - Parameters:\n///   - a: Первая сторона.\n///   - b: Вторая сторона.\n///   - c: Третья сторона.\n/// - Returns: Площадь треугольника.\nfunc heronsFormula(a: Double, b: Double, c: Double) -> Double? {\n    guard isTriangle(a, b, c) else { return nil }\n    let s = (a + b + c) / 2\n    return sqrt(s * (s - a) * (s - b) * (s - c))\n}"
  },
  {
    "input": "func generatePassword(_ length: Int) -> String {\n    let chars = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()\"\n    return String((0..<length).map { _ in chars.randomElement()! })\n}",
    "output": "/// Генерирует случайный пароль.\n/// - Parameter length: Длина пароля.\n/// - Returns: Случайный пароль.\nfunc generatePassword(_ length: Int) -> String {\n    let chars = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()\"\n    return String((0..<length).map { _ in chars.randomElement()! })\n}"
  },
  {
    "input": "func isSymmetric<T: Equatable>(_ array: [T]) -> Bool {\n    return array == array.reversed()\n}",
    "output": "/// Проверяет, является ли массив симметричным.\n/// - Parameter array: Массив.\n/// - Returns: `true`, если массив симметричен.\nfunc isSymmetric<T: Equatable>(_ array: [T]) -> Bool {\n    return array == array.reversed()\n}"
  },
  {
    "input": "func toSnakeCase(_ str: String) -> String {\n    return str.lowercased().replacingOccurrences(of: \" \", with: \"_\")\n}",
    "output": "/// Преобразует строку в snake_case.\n/// - Parameter str: Входная строка.\n/// - Returns: Строка в snake_case.\nfunc toSnakeCase(_ str: String) -> String {\n    return str.lowercased().replacingOccurrences(of: \" \", with: \"_\")\n}"
  },
  {
    "input": "func endsWith(_ str: String, _ suffix: String) -> Bool {\n    return str.hasSuffix(suffix)\n}",
    "output": "/// Проверяет, заканчивается ли строка суффиксом.\n/// - Parameters:\n///   - str: Строка.\n///   - suffix: Суффикс.\n/// - Returns: `true`, если строка заканчивается суффиксом.\nfunc endsWith(_ str: String, _ suffix: String) -> Bool {\n    return str.hasSuffix(suffix)\n}"
  },
  {
    "input": "func countSentences(_ str: String) -> Int {\n    return str.components(separatedBy: CharacterSet.sentenceTerminators).filter { !$0.isEmpty }.count\n}",
    "output": "/// Считает количество предложений в строке.\n/// - Parameter str: Входная строка.\n/// - Returns: Количество предложений.\nfunc countSentences(_ str: String) -> Int {\n    return str.components(separatedBy: CharacterSet.sentenceTerminators).filter { !$0.isEmpty }.count\n}"
  },
  {
    "input": "func extractDomain(_ url: String) -> String? {\n    return URL(string: url)?.host\n}",
    "output": "/// Извлекает домен из URL.\n/// - Parameter url: URL строка.\n/// - Returns: Домен или nil.\nfunc extractDomain(_ url: String) -> String? {\n    return URL(string: url)?.host\n}"
  },
  {
    "input": "func isAscending(_ array: [Int]) -> Bool {\n    return array == array.sorted()\n}",
    "output": "/// Проверяет, отсортирован ли массив по возрастанию.\n/// - Parameter array: Массив чисел.\n/// - Returns: `true`, если массив отсортирован.\nfunc isAscending(_ array: [Int]) -> Bool {\n    return array == array.sorted()\n}"
  },
  {
    "input": "func weightedSum(values: [Double], weights: [Double]) -> Double {\n    return zip(values, weights).map(*).reduce(0, +)\n}",
    "output": "/// Вычисляет взвешенную сумму.\n/// - Parameters:\n///   - values: Массив значений.\n///   - weights: Массив весов.\n/// - Returns: Взвешенная сумма.\nfunc weightedSum(values: [Double], weights: [Double]) -> Double {\n    return zip(values, weights).map(*).reduce(0, +)\n}"
  },
  {
    "input": "func canFormPalindrome(_ str: String) -> Bool {\n    let counts = str.filter { $0.isLetter }.reduce(into: [:]) { $0[$1, default:0] += 1 }\n    let oddCounts = counts.values.filter { $0 % 2 != 0 }.count\n    return oddCounts <= 1\n}",
    "output": "/// Проверяет, можно ли прочитать строку как палиндром.\n/// - Parameter str: Входная строка.\n/// - Returns: `true`, если возможен палиндром.\nfunc canFormPalindrome(_ str: String) -> Bool {\n    let counts = str.filter { $0.isLetter }.reduce(into: [:]) { $0[$1, default:0] += 1 }\n    let oddCounts = counts.values.filter { $0 % 2 != 0 }.count\n    return oddCounts <= 1\n}"
  },
  {
    "input": "func percentageChange(old: Double, new: Double) -> Double {\n    return ((new - old) / old) * 100\n}",
    "output": "/// Вычисляет процентное изменение между двумя числами.\n/// - Parameters:\n///   - old: Исходное значение.\n///   - new: Новое значение.\n/// - Returns: Процент изменения.\nfunc percentageChange(old: Double, new: Double) -> Double {\n    return ((new - old) / old) * 100\n}"
  },
  {
    "input": "func isPositive(_ number: Double) -> Bool {\n    return number > 0\n}",
    "output": "/// Проверяет, является ли число положительным.\n/// - Parameter number: Число.\n/// - Returns: `true`, если число положительное.\nfunc isPositive(_ number: Double) -> Bool {\n    return number > 0\n}"
  },
  {
    "input": "func hectaresToSquareMeters(_ hectares: Double) -> Double {\n    return hectares * 10000\n}",
    "output": "/// Конвертирует гектары в квадратные метры.\n/// - Parameter hectares: Значение в гектарах.\n/// - Returns: Значение в квадратных метрах.\nfunc hectaresToSquareMeters(_ hectares: Double) -> Double {\n    return hectares * 10000\n}"
  },
  {
    "input": "func median(_ numbers: [Double]) -> Double {\n    let sorted = numbers.sorted()\n    let mid = sorted.count / 2\n    return sorted.count % 2 == 0 ? (sorted[mid] + sorted[mid-1]) / 2 : sorted[mid]\n}",
    "output": "/// Находит медиану массива.\n/// - Parameter numbers: Массив чисел.\n/// - Returns: Медиана.\nfunc median(_ numbers: [Double]) -> Double {\n    let sorted = numbers.sorted()\n    let mid = sorted.count / 2\n    return sorted.count % 2 == 0 ? (sorted[mid] + sorted[mid-1]) / 2 : sorted[mid]\n}"
  },
  {
    "input": "func areElementsUnique<T: Hashable>(_ array: [T]) -> Bool {\n    return Set(array).count == array.count\n}",
    "output": "/// Проверяет уникальность элементов массива.\n/// - Parameter array: Массив.\n/// - Returns: `true`, если все элементы уникальны.\nfunc areElementsUnique<T: Hashable>(_ array: [T]) -> Bool {\n    return Set(array).count == array.count\n}"
  },
  {
    "input": "func vectorAddition(_ a: [Double], _ b: [Double]) -> [Double]? {\n    guard a.count == b.count else { return nil }\n    return zip(a, b).map(+)\n}",
    "output": "/// Суммирует два вектора.\n/// - Parameters:\n///   - a: Первый вектор.\n///   - b: Второй вектор.\n/// - Returns: Сумма векторов.\nfunc vectorAddition(_ a: [Double], _ b: [Double]) -> [Double]? {\n    guard a.count == b.count else { return nil }\n    return zip(a, b).map(+)\n}"
  },
  {
    "input": "func convertTo24HourFormat(_ time12: String) -> String? {\n    let formatter = DateFormatter()\n    formatter.dateFormat = \"hh:mm a\"\n    guard let date = formatter.date(from: time12) else { return nil }\n    formatter.dateFormat = \"HH:mm\"\n    return formatter.string(from: date)\n}",
    "output": "/// Конвертирует время из 12-часового формата в 24-часовой.\n/// - Parameter time12: Время в формате \"hh:mm AM/PM\".\n/// - Returns: Время в формате \"HH:mm\".\nfunc convertTo24HourFormat(_ time12: String) -> String? {\n    let formatter = DateFormatter()\n    formatter.dateFormat = \"hh:mm a\"\n    guard let date = formatter.date(from: time12) else { return nil }\n    formatter.dateFormat = \"HH:mm\"\n    return formatter.string(from: date)\n}"
  },
  {
    "input": "func isValidUsername(_ username: String) -> Bool {\n    return username.range(of: \"^[a-zA-Z0-9]+$\", options: .regularExpression) != nil\n}",
    "output": "/// Проверяет валидность имени пользователя.\n/// - Parameter username: Имя пользователя.\n/// - Returns: `true`, если имя валидно (только буквы и цифры).\nfunc isValidUsername(_ username: String) -> Bool {\n    return username.range(of: \"^[a-zA-Z0-9]+$\", options: .regularExpression) != nil\n}"
  },
  {
    "input": "func geometricMean(_ numbers: [Double]) -> Double {\n    let product = numbers.reduce(1, *)\n    return pow(product, 1/Double(numbers.count))\n}",
    "output": "/// Вычисляет среднее геометрическое.\n/// - Parameter numbers: Массив чисел.\n/// - Returns: Среднее геометрическое.\nfunc geometricMean(_ numbers: [Double]) -> Double {\n    let product = numbers.reduce(1, *)\n    return pow(product, 1/Double(numbers.count))\n}"
  },
  {
    "input": "func isPerfectNumber(_ number: Int) -> Bool {\n    guard number > 0 else { return false }\n    var sum = 0\n    for i in 1..<number {\n        if number % i == 0 { sum += i }\n    }\n    return sum == number\n}",
    "output": "/// Проверяет, является ли число совершенным.\n/// - Parameter number: Число.\n/// - Returns: `true`, если число совершенное.\nfunc isPerfectNumber(_ number: Int) -> Bool {\n    guard number > 0 else { return false }\n    var sum = 0\n    for i in 1..<number {\n        if number % i == 0 { sum += i }\n    }\n    return sum == number\n}"
  },
  {
    "input": "func romanToArabic(_ roman: String) -> Int {\n    let values: [Character: Int] = [\"I\":1, \"V\":5, \"X\":10, \"L\":50, \"C\":100, \"D\":500, \"M\":1000]\n    var total = 0\n    var prevValue = 0\n    for char in roman.reversed() {\n        let value = values[char] ?? 0\n        total += (value >= prevValue) ? value : -value\n        prevValue = value\n    }\n    return total\n}",
    "output": "/// Конвертирует римские цифры в арабские.\n/// - Parameter roman: Римское число.\n/// - Returns: Арабское число.\nfunc romanToArabic(_ roman: String) -> Int {\n    let values: [Character: Int] = [\"I\":1, \"V\":5, \"X\":10, \"L\":50, \"C\":100, \"D\":500, \"M\":1000]\n    var total = 0\n    var prevValue = 0\n    for char in roman.reversed() {\n        let value = values[char] ?? 0\n        total += (value >= prevValue) ? value : -value\n        prevValue = value\n    }\n    return total\n}"
  },
  {
    "input": "func combinations(n: Int, k: Int) -> Int {\n    func factorial(_ num: Int) -> Int {\n        return (1...num).reduce(1, *)\n    }\n    return factorial(n) / (factorial(k) * factorial(n - k))\n}",
    "output": "/// Вычисляет количество комбинаций.\n/// - Parameters:\n///   - n: Общее количество элементов.\n///   - k: Размер комбинации.\n/// - Returns: Число комбинаций C(n, k).\nfunc combinations(n: Int, k: Int) -> Int {\n    func factorial(_ num: Int) -> Int {\n        return (1...num).reduce(1, *)\n    }\n    return factorial(n) / (factorial(k) * factorial(n - k))\n}"
  },
  {
    "input": "func isValidIPv4(_ ip: String) -> Bool {\n    let parts = ip.components(separatedBy: \".\")\n    guard parts.count == 4 else { return false }\n    for part in parts {\n        guard let num = Int(part), (0...255).contains(num) else { return false }\n    }\n    return true\n}",
    "output": "/// Проверяет, является ли строка IPv4 адресом.\n/// - Parameter ip: Строка с адресом.\n/// - Returns: `true`, если адрес валиден.\nfunc isValidIPv4(_ ip: String) -> Bool {\n    let parts = ip.components(separatedBy: \".\")\n    guard parts.count == 4 else { return false }\n    for part in parts {\n        guard let num = Int(part), (0...255).contains(num) else { return false }\n    }\n    return true\n}"
  },
  {
    "input": "func stringToDate(_ dateString: String, format: String) -> Date? {\n    let formatter = DateFormatter()\n    formatter.dateFormat = format\n    return formatter.date(from: dateString)\n}",
    "output": "/// Преобразует строку в дату.\n/// - Parameters:\n///   - dateString: Строка с датой.\n///   - format: Формат даты (например, \"yyyy-MM-dd\").\n/// - Returns: Объект Date.\nfunc stringToDate(_ dateString: String, format: String) -> Date? {\n    let formatter = DateFormatter()\n    formatter.dateFormat = format\n    return formatter.date(from: dateString)\n}"
  },
  {
    "input": "func countOccurrences(of substring: String, in str: String) -> Int {\n    return str.components(separatedBy: substring).count - 1\n}",
    "output": "/// Считает количество вхождений подстроки.\n/// - Parameters:\n///   - str: Строка.\n///   - substring: Подстрока.\n/// - Returns: Количество вхождений.\nfunc countOccurrences(of substring: String, in str: String) -> Int {\n    return str.components(separatedBy: substring).count - 1\n}"
  },
  {
    "input": "func hammingDistance(_ a: String, _ b: String) -> Int? {\n    guard a.count == b.count else { return nil }\n    return zip(a, b).filter { $0 != $1 }.count\n}",
    "output": "/// Вычисляет расстояние Хэмминга между двумя строками.\n/// - Parameters:\n///   - a: Первая строка.\n///   - b: Вторая строка.\n/// - Returns: Расстояние Хэмминга или nil при разной длине.\nfunc hammingDistance(_ a: String, _ b: String) -> Int? {\n    guard a.count == b.count else { return nil }\n    return zip(a, b).filter { $0 != $1 }.count\n}"
  },
  {
    "input": "func permutations<T>(_ elements: [T]) -> [[T]] {\n    guard elements.count > 1 else { return [elements] }\n    return elements.indices.flatMap { i -> [[T]] in\n        var rest = elements\n        let elem = rest.remove(at: i)\n        return permutations(rest).map { [elem] + $0 }\n    }\n}",
    "output": "/// Генерирует все перестановки массива.\n/// - Parameter elements: Входной массив.\n/// - Returns: Массив всех перестановок.\nfunc permutations<T>(_ elements: [T]) -> [[T]] {\n    guard elements.count > 1 else { return [elements] }\n    return elements.indices.flatMap { i -> [[T]] in\n        var rest = elements\n        let elem = rest.remove(at: i)\n        return permutations(rest).map { [elem] + $0 }\n    }\n}"
  },
  {
    "input": "func quickSort<T: Comparable>(_ array: [T]) -> [T] {\n    guard array.count > 1 else { return array }\n    let pivot = array[array.count/2]\n    let less = array.filter { $0 < pivot }\n    let equal = array.filter { $0 == pivot }\n    let greater = array.filter { $0 > pivot }\n    return quickSort(less) + equal + quickSort(greater)\n}",
    "output": "/// Реализует алгоритм быстрой сортировки (quicksort).\n/// - Parameter array: Входной массив.\n/// - Returns: Отсортированный массив.\nfunc quickSort<T: Comparable>(_ array: [T]) -> [T] {\n    guard array.count > 1 else { return array }\n    let pivot = array[array.count/2]\n    let less = array.filter { $0 < pivot }\n    let equal = array.filter { $0 == pivot }\n    let greater = array.filter { $0 > pivot }\n    return quickSort(less) + equal + quickSort(greater)\n}"
  },
  {
    "input": "func mergeSort<T: Comparable>(_ array: [T]) -> [T] {\n    guard array.count > 1 else { return array }\n    let mid = array.count / 2\n    let left = mergeSort(Array(array[0..<mid]))\n    let right = mergeSort(Array(array[mid...]))\n    return merge(left, right)\n}",
    "output": "/// Реализует сортировку слиянием (merge sort).\n/// - Parameter array: Входной массив.\n/// - Returns: Отсортированный массив.\nfunc mergeSort<T: Comparable>(_ array: [T]) -> [T] {\n    guard array.count > 1 else { return array }\n    let mid = array.count / 2\n    let left = mergeSort(Array(array[0..<mid]))\n    let right = mergeSort(Array(array[mid...]))\n    return merge(left, right)\n}"
  },
  {
    "input": "func binarySearch<T: Comparable>(_ array: [T], _ target: T) -> Int? {\n    var low = 0, high = array.count - 1\n    while low <= high {\n        let mid = (low + high) / 2\n        if array[mid] == target { return mid }\n        array[mid] < target ? (low = mid + 1) : (high = mid - 1)\n    }\n    return nil\n}",
    "output": "/// Выполняет двоичный поиск в отсортированном массиве.\n/// - Parameters:\n///   - array: Отсортированный массив.\n///   - target: Искомый элемент.\n/// - Returns: Индекс элемента или nil.\nfunc binarySearch<T: Comparable>(_ array: [T], _ target: T) -> Int? {\n    var low = 0, high = array.count - 1\n    while low <= high {\n        let mid = (low + high) / 2\n        if array[mid] == target { return mid }\n        array[mid] < target ? (low = mid + 1) : (high = mid - 1)\n    }\n    return nil\n}"
  },
  {
    "input": "func isBalancedBrackets(_ str: String) -> Bool {\n    let pairs: [Character: Character] = [\")\": \"(\", \"]\": \"[\", \"}",
    "output": "/// Проверяет баланс скобок разных типов (круглые, квадратные, фигурные).\n/// - Parameter str: Входная строка.\n/// - Returns: `true`, если скобки сбалансированы.\nfunc isBalancedBrackets(_ str: String) -> Bool {\n    let pairs: [Character: Character] = [\")\": \"(\", \"]\": \"[\", \"}"
  },
  {
    "input": "func toRoman(_ number: Int) -> String {\n    let values = [(1000, \"M\"), (900, \"CM\"), (500, \"D\"), (400, \"CD\"),\n                  (100, \"C\"), (90, \"XC\"), (50, \"L\"), (40, \"XL\"),\n                  (10, \"X\"), (9, \"IX\"), (5, \"V\"), (4, \"IV\"), (1, \"I\")]\n    var result = \"\"\n    var n = number\n    for (value, symbol) in values {\n        while n >= value {\n            result += symbol\n            n -= value\n        }\n    }\n    return result\n}",
    "output": "/// Конвертирует число в римскую систему счисления.\n/// - Parameter number: Число от 1 до 3999.\n/// - Returns: Римское число в виде строки.\nfunc toRoman(_ number: Int) -> String {\n    let values = [(1000, \"M\"), (900, \"CM\"), (500, \"D\"), (400, \"CD\"),\n                  (100, \"C\"), (90, \"XC\"), (50, \"L\"), (40, \"XL\"),\n                  (10, \"X\"), (9, \"IX\"), (5, \"V\"), (4, \"IV\"), (1, \"I\")]\n    var result = \"\"\n    var n = number\n    for (value, symbol) in values {\n        while n >= value {\n            result += symbol\n            n -= value\n        }\n    }\n    return result\n}"
  },
  {
    "input": "func gcdOfArray(_ numbers: [Int]) -> Int {\n    return numbers.reduce(numbers[0]) { gcd($0, $1) }\n}",
    "output": "/// Вычисляет НОД для массива чисел.\n/// - Parameter numbers: Массив чисел.\n/// - Returns: Наибольший общий делитель.\nfunc gcdOfArray(_ numbers: [Int]) -> Int {\n    return numbers.reduce(numbers[0]) { gcd($0, $1) }\n}"
  },
  {
    "input": "func dijkstra(graph: [[Int]], start: Int) -> [Int] {\n    let n = graph.count\n    var distances = Array(repeating: Int.max, count: n)\n    var visited = Array(repeating: false, count: n)\n    distances[start] = 0\n    \n    for _ in 0..<n {\n        let u = (0..<n).filter { !visited[$0] }.min { distances[$0] < distances[$1] }!\n        visited[u] = true\n        for v in 0..<n {\n            if graph[u][v] > 0 && !visited[v] {\n                distances[v] = min(distances[v], distances[u] + graph[u][v])\n            }\n        }\n    }\n    return distances\n}",
    "output": "/// Реализует алгоритм Дейкстры для поиска кратчайшего пути.\n/// - Parameters:\n///   - graph: Матрица смежности.\n///   - start: Начальная вершина.\n/// - Returns: Массив расстояний до вершин.\nfunc dijkstra(graph: [[Int]], start: Int) -> [Int] {\n    let n = graph.count\n    var distances = Array(repeating: Int.max, count: n)\n    var visited = Array(repeating: false, count: n)\n    distances[start] = 0\n    \n    for _ in 0..<n {\n        let u = (0..<n).filter { !visited[$0] }.min { distances[$0] < distances[$1] }!\n        visited[u] = true\n        for v in 0..<n {\n            if graph[u][v] > 0 && !visited[v] {\n                distances[v] = min(distances[v], distances[u] + graph[u][v])\n            }\n        }\n    }\n    return distances\n}"
  },
  {
    "input": "func luhnCheck(_ number: String) -> Bool {\n    let digits = number.compactMap { $0.wholeNumberValue }.reversed()\n    var sum = 0\n    for (index, digit) in digits.enumerated() {\n        sum += index % 2 == 1 ? (digit * 2).digits.reduce(0, +) : digit\n    }\n    return sum % 10 == 0\n}",
    "output": "/// Проверяет валидность номера кредитной карты с помощью алгоритма Луна.\n/// - Parameter number: Номер карты.\n/// - Returns: `true`, если номер валиден.\nfunc luhnCheck(_ number: String) -> Bool {\n    let digits = number.compactMap { $0.wholeNumberValue }.reversed()\n    var sum = 0\n    for (index, digit) in digits.enumerated() {\n        sum += index % 2 == 1 ? (digit * 2).digits.reduce(0, +) : digit\n    }\n    return sum % 10 == 0\n}"
  },
  {
    "input": "func hexToRGB(_ hex: String) -> (r: Int, g: Int, b: Int)? {\n    guard hex.hasPrefix(\"#\"), hex.count == 7 else { return nil }\n    let values = hex.dropFirst().chunked(into: 2).compactMap { Int($0, radix: 16) }\n    guard values.count == 3 else { return nil }\n    return (values[0], values[1], values[2])\n}",
    "output": "/// Преобразует HEX-строку в RGB-значения.\n/// - Parameter hex: HEX-строка (формат: \"#FFFFFF\").\n/// - Returns: Кортеж (red, green, blue) или nil при ошибке.\nfunc hexToRGB(_ hex: String) -> (r: Int, g: Int, b: Int)? {\n    guard hex.hasPrefix(\"#\"), hex.count == 7 else { return nil }\n    let values = hex.dropFirst().chunked(into: 2).compactMap { Int($0, radix: 16) }\n    guard values.count == 3 else { return nil }\n    return (values[0], values[1], values[2])\n}"
  },
  {
    "input": "func bubbleSort<T: Comparable>(_ array: [T]) -> [T] {\n    var arr = array\n    for i in 0..<arr.count {\n        for j in 1..<arr.count - i {\n            if arr[j-1] > arr[j] { arr.swapAt(j-1, j) }\n        }\n    }\n    return arr\n}",
    "output": "/// Реализует алгоритм сортировки пузырьком.\n/// - Parameter array: Входной массив.\n/// - Returns: Отсортированный массив.\nfunc bubbleSort<T: Comparable>(_ array: [T]) -> [T] {\n    var arr = array\n    for i in 0..<arr.count {\n        for j in 1..<arr.count - i {\n            if arr[j-1] > arr[j] { arr.swapAt(j-1, j) }\n        }\n    }\n    return arr\n}"
  },
  {
    "input": "func insertionSort<T: Comparable>(_ array: [T]) -> [T] {\n    var arr = array\n    for i in 1..<arr.count {\n        var j = i\n        while j > 0 && arr[j] < arr[j-1] {\n            arr.swapAt(j, j-1)\n            j -= 1\n        }\n    }\n    return arr\n}",
    "output": "/// Реализует алгоритм сортировки вставками.\n/// - Parameter array: Входной массив.\n/// - Returns: Отсортированный массив.\nfunc insertionSort<T: Comparable>(_ array: [T]) -> [T] {\n    var arr = array\n    for i in 1..<arr.count {\n        var j = i\n        while j > 0 && arr[j] < arr[j-1] {\n            arr.swapAt(j, j-1)\n            j -= 1\n        }\n    }\n    return arr\n}"
  },
  {
    "input": "func isBipartite(graph: [[Int]], start: Int) -> Bool {\n    var colors = Array(repeating: -1, count: graph.count)\n    var queue = [start]\n    colors[start] = 0\n    \n    while !queue.isEmpty {\n        let u = queue.removeFirst()\n        for v in 0..<graph.count {\n            if graph[u][v] == 1 {\n                if colors[v] == -1 {\n                    colors[v] = 1 - colors[u]\n                    queue.append(v)\n                } else if colors[v] == colors[u] {\n                    return false\n                }\n            }\n        }\n    }\n    return true\n}",
    "output": "/// Проверяет, является ли граф двудольным.\n/// - Parameters:\n///   - graph: Матрица смежности.\n///   - start: Начальная вершина.\n/// - Returns: `true`, если граф двудольный.\nfunc isBipartite(graph: [[Int]], start: Int) -> Bool {\n    var colors = Array(repeating: -1, count: graph.count)\n    var queue = [start]\n    colors[start] = 0\n    \n    while !queue.isEmpty {\n        let u = queue.removeFirst()\n        for v in 0..<graph.count {\n            if graph[u][v] == 1 {\n                if colors[v] == -1 {\n                    colors[v] = 1 - colors[u]\n                    queue.append(v)\n                } else if colors[v] == colors[u] {\n                    return false\n                }\n            }\n        }\n    }\n    return true\n}"
  },
  {
    "input": "func xorEncrypt(_ str: String, key: String) -> String? {\n    let data = str.data(using: .utf8)!\n    let keyData = key.data(using: .utf8)!\n    var encrypted = [UInt8]()\n    for (i, byte) in data.enumerated() {\n        encrypted.append(byte ^ keyData[i % keyData.count])\n    }\n    return Data(encrypted).base64EncodedString()\n}",
    "output": "/// Шифрует строку с использованием XOR-шифрования.\n/// - Parameters:\n///   - str: Исходная строка.\n///   - key: Ключ шифрования.\n/// - Returns: Зашифрованная строка в Base64.\nfunc xorEncrypt(_ str: String, key: String) -> String? {\n    let data = str.data(using: .utf8)!\n    let keyData = key.data(using: .utf8)!\n    var encrypted = [UInt8]()\n    for (i, byte) in data.enumerated() {\n        encrypted.append(byte ^ keyData[i % keyData.count])\n    }\n    return Data(encrypted).base64EncodedString()\n}"
  },
  {
    "input": "func runLengthEncoding(_ str: String) -> String {\n    guard !str.isEmpty else { return \"\" }\n    var result = \"\"\n    var currentChar = str.first!\n    var count = 1\n    for char in str.dropFirst() {\n        if char == currentChar {\n            count += 1\n        } else {\n            result += \"\\(count)\\(currentChar)\"\n            currentChar = char\n            count = 1\n        }\n    }\n    result += \"\\(count)\\(currentChar)\"\n    return result\n}",
    "output": "/// Реализует алгоритм RLE (Run-Length Encoding).\n/// - Parameter str: Входная строка.\n/// - Returns: Сжатая строка.\nfunc runLengthEncoding(_ str: String) -> String {\n    guard !str.isEmpty else { return \"\" }\n    var result = \"\"\n    var currentChar = str.first!\n    var count = 1\n    for char in str.dropFirst() {\n        if char == currentChar {\n            count += 1\n        } else {\n            result += \"\\(count)\\(currentChar)\"\n            currentChar = char\n            count = 1\n        }\n    }\n    result += \"\\(count)\\(currentChar)\"\n    return result\n}"
  },
  {
    "input": "func lcmOfArray(_ numbers: [Int]) -> Int {\n    numbers.reduce(1) { lcm($0, $1) }\n}",
    "output": "/// Находит НОК (наименьшее общее кратное) для массива чисел.\n/// - Parameter numbers: Массив чисел.\n/// - Returns: НОК.\nfunc lcmOfArray(_ numbers: [Int]) -> Int {\n    numbers.reduce(1) { lcm($0, $1) }\n}"
  },
  {
    "input": "func formatMinutes(_ minutes: Int) -> String {\n    let hours = minutes / 60\n    let mins = minutes % 60\n    return String(format: \"%02d:%02d\", hours, mins)\n}",
    "output": "/// Конвертирует минуты в формат \"часы:минуты\".\n/// - Parameter minutes: Общее количество минут.\n/// - Returns: Строка формата \"HH:mm\".\nfunc formatMinutes(_ minutes: Int) -> String {\n    let hours = minutes / 60\n    let mins = minutes % 60\n    return String(format: \"%02d:%02d\", hours, mins)\n}"
  },
  {
    "input": "func isPowerOfThree(_ n: Int) -> Bool {\n    guard n > 0 else { return false }\n    var num = n\n    while num % 3 == 0 { num /= 3 }\n    return num == 1\n}",
    "output": "/// Проверяет, является ли число степенью тройки.\n/// - Parameter n: Число.\n/// - Returns: `true`, если число является степенью тройки.\nfunc isPowerOfThree(_ n: Int) -> Bool {\n    guard n > 0 else { return false }\n    var num = n\n    while num % 3 == 0 { num /= 3 }\n    return num == 1\n}"
  },
  {
    "input": "func clockAngle(hour: Int, minute: Int) -> Double {\n    let hourAngle = Double((hour % 12) * 30 + minute / 2)\n    let minuteAngle = Double(minute * 6)\n    return abs(hourAngle - minuteAngle)\n}",
    "output": "/// Вычисляет угол между часовой и минутной стрелкой.\n/// - Parameters:\n///   - hour: Час (0-23).\n///   - minute: Минута (0-59).\n/// - Returns: Угол в градусах.\nfunc clockAngle(hour: Int, minute: Int) -> Double {\n    let hourAngle = Double((hour % 12) * 30 + minute / 2)\n    let minuteAngle = Double(minute * 6)\n    return abs(hourAngle - minuteAngle)\n}"
  },
  {
    "input": "func kadaneAlgorithm(_ array: [Int]) -> Int {\n    var maxCurrent = array[0], maxGlobal = array[0]\n    for num in array.dropFirst() {\n        maxCurrent = max(num, maxCurrent + num)\n        maxGlobal = max(maxGlobal, maxCurrent)\n    }\n    return maxGlobal\n}",
    "output": "/// Реализует алгоритм Кадане для поиска максимальной подмассива.\n/// - Parameter array: Массив чисел.\n/// - Returns: Максимальная сумма подмассива.\nfunc kadaneAlgorithm(_ array: [Int]) -> Int {\n    var maxCurrent = array[0], maxGlobal = array[0]\n    for num in array.dropFirst() {\n        maxCurrent = max(num, maxCurrent + num)\n        maxGlobal = max(maxGlobal, maxCurrent)\n    }\n    return maxGlobal\n}"
  },
  {
    "input": "func toSnakeCase(_ str: String) -> String {\n    str.lowercased().replacingOccurrences(of: \" \", with: \"_\")\n}",
    "output": "/// Преобразует строку в \"змейный регистр\" (snake_case).\n/// - Parameter str: Входная строка.\n/// - Returns: Строка в snake_case.\nfunc toSnakeCase(_ str: String) -> String {\n    str.lowercased().replacingOccurrences(of: \" \", with: \"_\")\n}"
  },
  {
    "input": "func isGregorianLeapYear(_ year: Int) -> Bool {\n    (year % 4 == 0 && year % 100 != 0) || year % 400 == 0\n}",
    "output": "/// Проверяет, является ли год високосным по григорианскому календарю.\n/// - Parameter year: Год.\n/// - Returns: `true`, если високосный.\nfunc isGregorianLeapYear(_ year: Int) -> Bool {\n    (year % 4 == 0 && year % 100 != 0) || year % 400 == 0\n}"
  },
  {
    "input": "func sumRomanDigits(_ roman: String) -> Int {\n    let values: [Character: Int] = [\"I\":1, \"V\":5, \"X\":10, \"L\":50, \"C\":100, \"D\":500, \"M\":1000]\n    return roman.reduce(0) { $0 + (values[$1] ?? 0) }\n}",
    "output": "/// Вычисляет сумму Римских цифр в строке.\n/// - Parameter roman: Римское число.\n/// - Returns: Сумма цифр (без учета правил вычитания).\nfunc sumRomanDigits(_ roman: String) -> Int {\n    let values: [Character: Int] = [\"I\":1, \"V\":5, \"X\":10, \"L\":50, \"C\":100, \"D\":500, \"M\":1000]\n    return roman.reduce(0) { $0 + (values[$1] ?? 0) }\n}"
  },
  {
    "input": "func sieveOfEratosthenes(_ n: Int) -> [Int] {\n    guard n >= 2 else { return [] }\n    var sieve = Array(repeating: true, count: n+1)\n    sieve[0] = false\n    sieve[1] = false\n    for i in 2...Int(Double(n).squareRoot()) {\n        if sieve[i] {\n            for j in stride(from: i*i, through: n, by: i) {\n                sieve[j] = false\n            }\n        }\n    }\n    return sieve.enumerated().filter { $0.element }.map { $0.offset }\n}",
    "output": "/// Генерирует массив простых чисел до N (решето Эратосфена).\n/// - Parameter n: Верхняя граница.\n/// - Returns: Массив простых чисел.\nfunc sieveOfEratosthenes(_ n: Int) -> [Int] {\n    guard n >= 2 else { return [] }\n    var sieve = Array(repeating: true, count: n+1)\n    sieve[0] = false\n    sieve[1] = false\n    for i in 2...Int(Double(n).squareRoot()) {\n        if sieve[i] {\n            for j in stride(from: i*i, through: n, by: i) {\n                sieve[j] = false\n            }\n        }\n    }\n    return sieve.enumerated().filter { $0.element }.map { $0.offset }\n}"
  },
  {
    "input": "func findPeakElement(_ array: [Int]) -> Int? {\n    guard !array.isEmpty else { return nil }\n    for i in 0..<array.count {\n        let prev = i > 0 ? array[i-1] : Int.min\n        let next = i < array.count-1 ? array[i+1] : Int.min\n        if array[i] >= prev && array[i] >= next { return i }\n    }\n    return nil\n}",
    "output": "/// Находит индекс Пикового элемента в массиве.\n/// - Parameter array: Массив чисел.\n/// - Returns: Индекс элемента, который больше соседей.\nfunc findPeakElement(_ array: [Int]) -> Int? {\n    guard !array.isEmpty else { return nil }\n    for i in 0..<array.count {\n        let prev = i > 0 ? array[i-1] : Int.min\n        let next = i < array.count-1 ? array[i+1] : Int.min\n        if array[i] >= prev && array[i] >= next { return i }\n    }\n    return nil\n}"
  },
  {
    "input": "func bfsShortestPath(grid: [[Int]], start: (Int, Int), end: (Int, Int)) -> Int? {\n    // Реализация с использованием очереди и проверки соседних клеток\n}",
    "output": "/// Реализует алгоритм BFS для поиска кратчайшего пути в матрице.\n/// - Parameters:\n///   - grid: Матрица (0 - пусто, 1 - препятствие).\n///   - start: Начальная точка (x, y).\n///   - end: Конечная точка (x, y).\n/// - Returns: Длина кратчайшего пути или nil.\nfunc bfsShortestPath(grid: [[Int]], start: (Int, Int), end: (Int, Int)) -> Int? {\n    // Реализация с использованием очереди и проверки соседних клеток\n}"
  },
  {
    "input": "func decimalToHex(_ decimal: Int) -> String {\n    String(format: \"%02X\", decimal)\n}",
    "output": "/// Конвертирует десятичное число в шестнадцатеричное.\n/// - Parameter decimal: Десятичное число.\n/// - Returns: HEX-строка.\nfunc decimalToHex(_ decimal: Int) -> String {\n    String(format: \"%02X\", decimal)\n}"
  },
  {
    "input": "func variance(_ numbers: [Double]) -> Double {\n    let mean = numbers.reduce(0, +) / Double(numbers.count)\n    return numbers.reduce(0) { $0 + pow($1 - mean, 2) } / Double(numbers.count)\n}",
    "output": "/// Вычисляет дисперсию массива чисел.\n/// - Parameter numbers: Массив чисел.\n/// - Returns: Дисперсия.\nfunc variance(_ numbers: [Double]) -> Double {\n    let mean = numbers.reduce(0, +) / Double(numbers.count)\n    return numbers.reduce(0) { $0 + pow($1 - mean, 2) } / Double(numbers.count)\n}"
  },
  {
    "input": "func isBinaryPalindrome(_ number: Int) -> Bool {\n    let binary = String(number, radix: 2)\n    return binary == String(binary.reversed())\n}",
    "output": "/// Проверяет, является ли число палиндромом в двоичной системе.\n/// - Parameter number: Число.\n/// - Returns: `true`, если двоичное представление - палиндром.\nfunc isBinaryPalindrome(_ number: Int) -> Bool {\n    let binary = String(number, radix: 2)\n    return binary == String(binary.reversed())\n}"
  },
  {
    "input": "func selectionSort<T: Comparable>(_ array: [T]) -> [T] {\n    var arr = array\n    for i in 0..<arr.count {\n        var minIndex = i\n        for j in i+1..<arr.count where arr[j] < arr[minIndex] {\n            minIndex = j\n        }\n        arr.swapAt(i, minIndex)\n    }\n    return arr\n}",
    "output": "/// Реализует сортировку выбором (selection sort).\n/// - Parameter array: Входной массив.\n/// - Returns: Отсортированный массив.\nfunc selectionSort<T: Comparable>(_ array: [T]) -> [T] {\n    var arr = array\n    for i in 0..<arr.count {\n        var minIndex = i\n        for j in i+1..<arr.count where arr[j] < arr[minIndex] {\n            minIndex = j\n        }\n        arr.swapAt(i, minIndex)\n    }\n    return arr\n}"
  },
  {
    "input": "func isNumberPalindrome(_ number: Int) -> Bool {\n    let str = String(number)\n    return str == String(str.reversed())\n}",
    "output": "/// Проверяет, является ли число палиндромом в десятичной системе.\n/// - Parameter number: Число.\n/// - Returns: `true`, если число читается одинаково слева направо и справа налево.\nfunc isNumberPalindrome(_ number: Int) -> Bool {\n    let str = String(number)\n    return str == String(str.reversed())\n}"
  },
  {
    "input": "func floydCycleDetection<T>(_ head: ListNode<T>?) -> Bool {\n    var slow = head, fast = head\n    while fast?.next != nil {\n        slow = slow?.next\n        fast = fast?.next?.next\n        if slow === fast { return true }\n    }\n    return false\n}",
    "output": "/// Реализует алгоритм Флойда для обнаружения цикла в связном списке.\n/// - Parameter head: Голова связного списка.\n/// - Returns: `true`, если цикл обнаружен.\nfunc floydCycleDetection<T>(_ head: ListNode<T>?) -> Bool {\n    var slow = head, fast = head\n    while fast?.next != nil {\n        slow = slow?.next\n        fast = fast?.next?.next\n        if slow === fast { return true }\n    }\n    return false\n}"
  },
  {
    "input": "func convertTemperature(_ value: Double, from: String, to: String) -> Double {\n    let kelvin: Double\n    switch from.uppercased() {\n    case \"C\": kelvin = value + 273.15\n    case \"F\": kelvin = (value - 32) * 5/9 + 273.15\n    case \"K\": kelvin = value\n    case \"R\": kelvin = value * 5/9\n    default: return value\n    }\n    \n    switch to.uppercased() {\n    case \"C\": return kelvin - 273.15\n    case \"F\": return (kelvin - 273.15) * 9/5 + 32\n    case \"K\": return kelvin\n    case \"R\": return kelvin * 9/5\n    default: return value\n    }\n}",
    "output": "/// Конвертирует температуру между произвольными шкалами.\n/// - Parameters:\n///   - value: Исходное значение.\n///   - from: Исходная шкала (\"C\", \"F\", \"K\", \"R\" для Ранкина).\n///   - to: Целевая шкала.\n/// - Returns: Конвертированное значение.\nfunc convertTemperature(_ value: Double, from: String, to: String) -> Double {\n    let kelvin: Double\n    switch from.uppercased() {\n    case \"C\": kelvin = value + 273.15\n    case \"F\": kelvin = (value - 32) * 5/9 + 273.15\n    case \"K\": kelvin = value\n    case \"R\": kelvin = value * 5/9\n    default: return value\n    }\n    \n    switch to.uppercased() {\n    case \"C\": return kelvin - 273.15\n    case \"F\": return (kelvin - 273.15) * 9/5 + 32\n    case \"K\": return kelvin\n    case \"R\": return kelvin * 9/5\n    default: return value\n    }\n}"
  },
  {
    "input": "func exponentialMovingAverage(_ prices: [Double], period: Int) -> [Double] {\n    guard !prices.isEmpty, period > 0 else { return [] }\n    let multiplier = 2.0 / (Double(period) + 1.0)\n    var ema = [prices[0]]\n    for price in prices.dropFirst() {\n        let newEMA = (price - ema.last!) * multiplier + ema.last!\n        ema.append(newEMA)\n    }\n    return ema\n}",
    "output": "/// Вычисляет экспоненциальное скользящее среднее (EMA).\n/// - Parameters:\n///   - prices: Массив цен.\n///   - period: Период сглаживания.\n/// - Returns: Массив значений EMA.\nfunc exponentialMovingAverage(_ prices: [Double], period: Int) -> [Double] {\n    guard !prices.isEmpty, period > 0 else { return [] }\n    let multiplier = 2.0 / (Double(period) + 1.0)\n    var ema = [prices[0]]\n    for price in prices.dropFirst() {\n        let newEMA = (price - ema.last!) * multiplier + ema.last!\n        ema.append(newEMA)\n    }\n    return ema\n}"
  },
  {
    "input": "func areParenthesesBalanced(_ str: String) -> Bool {\n    let pairs: [Character: Character] = [\")\": \"(\", \"]\": \"[\", \"}",
    "output": "/// Проверяет валидность скобок с несколькими типами (включая вложенные).\n/// - Parameter str: Входная строка.\n/// - Returns: `true`, если все скобки правильно вложены.\nfunc areParenthesesBalanced(_ str: String) -> Bool {\n    let pairs: [Character: Character] = [\")\": \"(\", \"]\": \"[\", \"}"
  },
  {
    "input": "func binaryExponentiation(_ base: Int, _ exponent: Int) -> Int {\n    guard exponent >= 0 else { return 0 }\n    var result = 1\n    var n = exponent\n    var a = base\n    while n > 0 {\n        if n % 2 == 1 { result *= a }\n        a *= a\n        n /= 2\n    }\n    return result\n}",
    "output": "/// Реализует алгоритм бинарного возведения в степень.\n/// - Parameters:\n///   - base: Основание.\n///   - exponent: Показатель степени.\n/// - Returns: Результат возведения в степень.\nfunc binaryExponentiation(_ base: Int, _ exponent: Int) -> Int {\n    guard exponent >= 0 else { return 0 }\n    var result = 1\n    var n = exponent\n    var a = base\n    while n > 0 {\n        if n % 2 == 1 { result *= a }\n        a *= a\n        n /= 2\n    }\n    return result\n}"
  },
  {
    "input": "func primeFactors(_ number: Int) -> [Int] {\n    var n = number\n    var factors = [Int]()\n    var divisor = 2\n    while divisor * divisor <= n {\n        while n % divisor == 0 {\n            factors.append(divisor)\n            n /= divisor\n        }\n        divisor += divisor == 2 ? 1 : 2\n    }\n    if n > 1 { factors.append(n) }\n    return factors\n}",
    "output": "/// Находит все простые делители числа.\n/// - Parameter number: Число (>1).\n/// - Returns: Массив простых делителей.\nfunc primeFactors(_ number: Int) -> [Int] {\n    var n = number\n    var factors = [Int]()\n    var divisor = 2\n    while divisor * divisor <= n {\n        while n % divisor == 0 {\n            factors.append(divisor)\n            n /= divisor\n        }\n        divisor += divisor == 2 ? 1 : 2\n    }\n    if n > 1 { factors.append(n) }\n    return factors\n}"
  },
  {
    "input": "func huffmanCoding(_ str: String) -> [Character: String] {\n    let frequency = str.reduce(into: [:]) { $0[$1, default: 0] += 1 }\n    var heap = frequency.map { Node(char: $0.key, freq: $0.value) }.sorted { $0.freq < $1.freq }\n    \n    while heap.count > 1 {\n        let left = heap.removeFirst()\n        let right = heap.removeFirst()\n        let merged = Node(freq: left.freq + right.freq, left: left, right: right)\n        heap.insert(merged, at: heap.firstIndex { $0.freq > merged.freq } ?? heap.endIndex)\n    }\n    \n    var codes = [Character: String]()\n    func traverse(_ node: Node?, code: String) {\n        guard let node = node else { return }\n        if let char = node.char {\n            codes[char] = code\n            return\n        }\n        traverse(node.left, code: code + \"0\")\n        traverse(node.right, code: code + \"1\")\n    }\n    traverse(heap.first, code: \"\")\n    return codes\n}",
    "output": "/// Реализует алгоритм Хаффмана для кодирования строки.\n/// - Parameter str: Входная строка.\n/// - Returns: Словарь с кодами символов.\nfunc huffmanCoding(_ str: String) -> [Character: String] {\n    let frequency = str.reduce(into: [:]) { $0[$1, default: 0] += 1 }\n    var heap = frequency.map { Node(char: $0.key, freq: $0.value) }.sorted { $0.freq < $1.freq }\n    \n    while heap.count > 1 {\n        let left = heap.removeFirst()\n        let right = heap.removeFirst()\n        let merged = Node(freq: left.freq + right.freq, left: left, right: right)\n        heap.insert(merged, at: heap.firstIndex { $0.freq > merged.freq } ?? heap.endIndex)\n    }\n    \n    var codes = [Character: String]()\n    func traverse(_ node: Node?, code: String) {\n        guard let node = node else { return }\n        if let char = node.char {\n            codes[char] = code\n            return\n        }\n        traverse(node.left, code: code + \"0\")\n        traverse(node.right, code: code + \"1\")\n    }\n    traverse(heap.first, code: \"\")\n    return codes\n}"
  },
  {
    "input": "func polygonArea(_ points: [(x: Double, y: Double)]) -> Double {\n    let n = points.count\n    var area = 0.0\n    for i in 0..<n {\n        let j = (i + 1) % n\n        area += points[i].x * points[j].y\n        area -= points[j].x * points[i].y\n    }\n    return abs(area) / 2.0\n}",
    "output": "/// Вычисляет площадь многоугольника по формуле шнуровки.\n/// - Parameter points: Массив точек (x, y).\n/// - Returns: Площадь многоугольника.\nfunc polygonArea(_ points: [(x: Double, y: Double)]) -> Double {\n    let n = points.count\n    var area = 0.0\n    for i in 0..<n {\n        let j = (i + 1) % n\n        area += points[i].x * points[j].y\n        area -= points[j].x * points[i].y\n    }\n    return abs(area) / 2.0\n}"
  },
  {
    "input": "func isAutomorphicNumber(_ number: Int) -> Bool {\n    let square = number * number\n    return String(square).hasSuffix(String(number))\n}",
    "output": "/// Проверяет, является ли число автоморфным (оканчивается на квадрат самого себя).\n/// - Parameter number: Число.\n/// - Returns: `true`, если автоморфное.\nfunc isAutomorphicNumber(_ number: Int) -> Bool {\n    let square = number * number\n    return String(square).hasSuffix(String(number))\n}"
  },
  {
    "input": "func zAlgorithm(_ str: String) -> [Int] {\n    let n = str.count\n    var z = [Int](repeating: 0, count: n)\n    var l = 0, r = 0\n    let chars = Array(str)\n    \n    for i in 1..<n {\n        if i <= r {\n            z[i] = min(r - i + 1, z[i - l])\n        }\n        while i + z[i] < n && chars[z[i]] == chars[i + z[i]] {\n            z[i] += 1\n        }\n        if i + z[i] - 1 > r {\n            l = i\n            r = i + z[i] - 1\n        }\n    }\n    z[0] = n\n    return z\n}",
    "output": "/// Реализует алгоритм Z-функции для строки.\n/// - Parameter str: Входная строка.\n/// - Returns: Z-массив.\nfunc zAlgorithm(_ str: String) -> [Int] {\n    let n = str.count\n    var z = [Int](repeating: 0, count: n)\n    var l = 0, r = 0\n    let chars = Array(str)\n    \n    for i in 1..<n {\n        if i <= r {\n            z[i] = min(r - i + 1, z[i - l])\n        }\n        while i + z[i] < n && chars[z[i]] == chars[i + z[i]] {\n            z[i] += 1\n        }\n        if i + z[i] - 1 > r {\n            l = i\n            r = i + z[i] - 1\n        }\n    }\n    z[0] = n\n    return z\n}"
  },
  {
    "input": "func numberToWords(_ number: Int) -> String {\n    let units = [\"\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"]\n    let teens = [\"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\"]\n    let tens = [\"\", \"ten\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"]\n    \n    func convertChunk(_ n: Int) -> String {\n        var result = \"\"\n        let hundred = n / 100\n        let remainder = n % 100\n        if hundred > 0 { result += \"\\(units[hundred]) hundred \" }\n        if remainder >= 20 {\n            result += \"\\(tens[remainder/10]) \"\n            if remainder%10 != 0 { result += \"\\(units[remainder%10])\" }\n        } else if remainder >= 10 {\n            result += teens[remainder-10]\n        } else if remainder > 0 {\n            result += units[remainder]\n        }\n        return result.trimmingCharacters(in: .whitespaces)\n    }\n    \n    guard number != 0 else { return \"zero\" }\n    var result = \"\"\n    let million = (number / 1_000_000) % 1_000\n    let thousand = (number / 1_000) % 1_000\n    let remainder = number % 1_000\n    \n    if million > 0 { result += \"\\(convertChunk(million)) million \" }\n    if thousand > 0 { result += \"\\(convertChunk(thousand)) thousand \" }\n    if remainder > 0 { result += convertChunk(remainder) }\n    \n    return result.trimmingCharacters(in: .whitespaces)\n}",
    "output": "/// Конвертирует целое число в слова (английский язык).\n/// - Parameter number: Число (0 ≤ number ≤ 999,999,999).\n/// - Returns: Число прописью.\nfunc numberToWords(_ number: Int) -> String {\n    let units = [\"\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"]\n    let teens = [\"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\"]\n    let tens = [\"\", \"ten\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"]\n    \n    func convertChunk(_ n: Int) -> String {\n        var result = \"\"\n        let hundred = n / 100\n        let remainder = n % 100\n        if hundred > 0 { result += \"\\(units[hundred]) hundred \" }\n        if remainder >= 20 {\n            result += \"\\(tens[remainder/10]) \"\n            if remainder%10 != 0 { result += \"\\(units[remainder%10])\" }\n        } else if remainder >= 10 {\n            result += teens[remainder-10]\n        } else if remainder > 0 {\n            result += units[remainder]\n        }\n        return result.trimmingCharacters(in: .whitespaces)\n    }\n    \n    guard number != 0 else { return \"zero\" }\n    var result = \"\"\n    let million = (number / 1_000_000) % 1_000\n    let thousand = (number / 1_000) % 1_000\n    let remainder = number % 1_000\n    \n    if million > 0 { result += \"\\(convertChunk(million)) million \" }\n    if thousand > 0 { result += \"\\(convertChunk(thousand)) thousand \" }\n    if remainder > 0 { result += convertChunk(remainder) }\n    \n    return result.trimmingCharacters(in: .whitespaces)\n}"
  },
  {
    "input": "func aStarPathfinding(grid: [[Int]], start: (x: Int, y: Int), end: (x: Int, y: Int)) -> [(x: Int, y: Int)]? {\n    // Реализация с приоритетной очередью и эвристикой Манхэттена\n    return nil\n}",
    "output": "/// Реализует алгоритм А* для поиска пути в сетке.\n/// - Parameters:\n///   - grid: 2D массив (0 - проходимо, 1 - препятствие).\n///   - start: Начальная точка (x, y).\n///   - end: Конечная точка (x, y).\n/// - Returns: Кратчайший путь как массив точек.\nfunc aStarPathfinding(grid: [[Int]], start: (x: Int, y: Int), end: (x: Int, y: Int)) -> [(x: Int, y: Int)]? {\n    // Реализация с приоритетной очередью и эвристикой Манхэттена\n    return nil\n}"
  },
  {
    "input": "func crc32Checksum(data: Data) -> UInt32 {\n    var crc: UInt32 = 0xFFFFFFFF\n    let table: [UInt32] = (0...255).map { i in\n        var c = UInt32(i)\n        for _ in 0..<8 {\n            c = (c & 1) != 0 ? (0xEDB88320 ^ (c >> 1)) : (c >> 1)\n        }\n        return c\n    }\n    \n    for byte in data {\n        crc = table[Int((crc ^ UInt32(byte)) & 0xFF)] ^ (crc >> 8)\n    }\n    return crc ^ 0xFFFFFFFF\n}",
    "output": "/// Вычисляет CRC32 контрольную сумму для данных.\n/// - Parameter data: Входные данные.\n/// - Returns: Контрольная сумма.\nfunc crc32Checksum(data: Data) -> UInt32 {\n    var crc: UInt32 = 0xFFFFFFFF\n    let table: [UInt32] = (0...255).map { i in\n        var c = UInt32(i)\n        for _ in 0..<8 {\n            c = (c & 1) != 0 ? (0xEDB88320 ^ (c >> 1)) : (c >> 1)\n        }\n        return c\n    }\n    \n    for byte in data {\n        crc = table[Int((crc ^ UInt32(byte)) & 0xFF)] ^ (crc >> 8)\n    }\n    return crc ^ 0xFFFFFFFF\n}"
  },
  {
    "input": "func isPermutation(_ array: [Int]) -> Bool {\n    let n = array.count\n    let expected = Set(1...n)\n    return Set(array) == expected\n}",
    "output": "/// Проверяет, является ли массив перестановкой чисел от 1 до N.\n/// - Parameter array: Входной массив.\n/// - Returns: `true`, если является перестановкой.\nfunc isPermutation(_ array: [Int]) -> Bool {\n    let n = array.count\n    let expected = Set(1...n)\n    return Set(array) == expected\n}"
  },
  {
    "input": "func lanczosAlgorithm(matrix: [[Double]]) -> [Double] {\n    // Реализация метода Ланцоша для больших разреженных матриц\n    return []\n}",
    "output": "/// Реализует алгоритм Ланцоша для приближенного вычисления собственных значений.\n/// - Parameter matrix: Квадратная матрица.\n/// - Returns: Приближенные собственные значения.\nfunc lanczosAlgorithm(matrix: [[Double]]) -> [Double] {\n    // Реализация метода Ланцоша для больших разреженных матриц\n    return []\n}"
  },
  {
    "input": "func soundexCode(_ str: String) -> String {\n    let mapping: [Character: String] = [\n        \"B\":\"1\", \"F\":\"1\", \"P\":\"1\", \"V\":\"1\",\n        \"C\":\"2\", \"G\":\"2\", \"J\":\"2\", \"K\":\"2\", \"Q\":\"2\", \"S\":\"2\", \"X\":\"2\", \"Z\":\"2\",\n        \"D\":\"3\", \"T\":\"3\",\n        \"L\":\"4\",\n        \"M\":\"5\", \"N\":\"5\",\n        \"R\":\"6\"\n    ]\n    \n    var code = \"\"\n    let chars = str.uppercased().filter { $0.isLetter }\n    guard !chars.isEmpty else { return \"\" }\n    \n    code.append(chars.first!)\n    var prev = mapping[chars.first!] ?? \"\"\n    \n    for char in chars.dropFirst() {\n        guard code.count < 4 else { break }\n        let current = mapping[char] ?? \"\"\n        if current != prev && !current.isEmpty {\n            code += current\n        }\n        prev = current\n    }\n    \n    return code.padding(toLength: 4, withPad: \"0\", startingAt: 0)\n}",
    "output": "/// Преобразует строку в звуковой код (Soundex).\n/// - Parameter str: Входная строка.\n/// - Returns: Код Soundex (формат: A123).\nfunc soundexCode(_ str: String) -> String {\n    let mapping: [Character: String] = [\n        \"B\":\"1\", \"F\":\"1\", \"P\":\"1\", \"V\":\"1\",\n        \"C\":\"2\", \"G\":\"2\", \"J\":\"2\", \"K\":\"2\", \"Q\":\"2\", \"S\":\"2\", \"X\":\"2\", \"Z\":\"2\",\n        \"D\":\"3\", \"T\":\"3\",\n        \"L\":\"4\",\n        \"M\":\"5\", \"N\":\"5\",\n        \"R\":\"6\"\n    ]\n    \n    var code = \"\"\n    let chars = str.uppercased().filter { $0.isLetter }\n    guard !chars.isEmpty else { return \"\" }\n    \n    code.append(chars.first!)\n    var prev = mapping[chars.first!] ?? \"\"\n    \n    for char in chars.dropFirst() {\n        guard code.count < 4 else { break }\n        let current = mapping[char] ?? \"\"\n        if current != prev && !current.isEmpty {\n            code += current\n        }\n        prev = current\n    }\n    \n    return code.padding(toLength: 4, withPad: \"0\", startingAt: 0)\n}"
  },
  {
    "input": "func factorialDigitSum(_ n: Int) -> Int {\n    guard n > 0 else { return 1 }\n    var factorial = [1]\n    for i in 1...n {\n        var carry = 0\n        for j in 0..<factorial.count {\n            let product = factorial[j] * i + carry\n            factorial[j] = product % 10\n            carry = product / 10\n        }\n        while carry > 0 {\n            factorial.append(carry % 10)\n            carry /= 10\n        }\n    }\n    return factorial.reduce(0, +)\n}",
    "output": "/// Вычисляет сумму цифр факториала числа.\n/// - Parameter n: Число (n ≥ 0).\n/// - Returns: Сумма цифр n!.\nfunc factorialDigitSum(_ n: Int) -> Int {\n    guard n > 0 else { return 1 }\n    var factorial = [1]\n    for i in 1...n {\n        var carry = 0\n        for j in 0..<factorial.count {\n            let product = factorial[j] * i + carry\n            factorial[j] = product % 10\n            carry = product / 10\n        }\n        while carry > 0 {\n            factorial.append(carry % 10)\n            carry /= 10\n        }\n    }\n    return factorial.reduce(0, +)\n}"
  },
  {
    "input": "func isArmstrongNumber(_ number: Int) -> Bool {\n    let digits = String(number).compactMap { Int(String($0)) }\n    let power = digits.count\n    return digits.map { Int(pow(Double($0), Double(power)) }.reduce(0, +) == number\n}",
    "output": "/// Проверяет, является ли число числом Армстронга.\n/// - Parameter number: Число.\n/// - Returns: true, если сумма цифр в степени количества цифр равна числу.\nfunc isArmstrongNumber(_ number: Int) -> Bool {\n    let digits = String(number).compactMap { Int(String($0)) }\n    let power = digits.count\n    return digits.map { Int(pow(Double($0), Double(power)) }.reduce(0, +) == number\n}"
  },
  {
    "input": "func rgbToHex(r: Int, g: Int, b: Int) -> String {\n    return String(format: \"#%02X%02X%02X\", r, g, b)\n}",
    "output": "/// Конвертирует RGB в HEX-формат.\n/// - Parameters:\n///   - r: Красный (0-255).\n///   - g: Зеленый (0-255).\n///   - b: Синий (0-255).\n/// - Returns: HEX-строка.\nfunc rgbToHex(r: Int, g: Int, b: Int) -> String {\n    return String(format: \"#%02X%02X%02X\", r, g, b)\n}"
  },
  {
    "input": "func compoundInterest(principal: Double, rate: Double, years: Int, compounds: Int) -> Double {\n    return principal * pow(1 + rate / Double(compounds), Double(compounds * years))\n}",
    "output": "/// Вычисляет периодическую доходность по сложным процентам.\n/// - Parameters:\n///   - principal: Начальная сумма.\n///   - rate: Годовая процентная ставка.\n///   - years: Количество лет.\n///   - compounds: Начислений в год.\n/// - Returns: Итоговая сумма.\nfunc compoundInterest(principal: Double, rate: Double, years: Int, compounds: Int) -> Double {\n    return principal * pow(1 + rate / Double(compounds), Double(compounds * years))\n}"
  },
  {
    "input": "func isValidISBN10(_ isbn: String) -> Bool {\n    let cleaned = isbn.replacingOccurrences(of: \"-\", with: \"\")\n    guard cleaned.count == 10 else { return false }\n    \n    var sum = 0\n    for (i, char) in cleaned.enumerated() {\n        guard let digit = char.isNumber ? Int(String(char)) : (i == 9 && char == \"X\" ? 10 : nil) else { return false }\n        sum += digit * (10 - i)\n    }\n    return sum % 11 == 0\n}",
    "output": "/// Проверяет валидность ISBN-10.\n/// - Parameter isbn: Строка ISBN.\n/// - Returns: true, если контрольная сумма совпадает.\nfunc isValidISBN10(_ isbn: String) -> Bool {\n    let cleaned = isbn.replacingOccurrences(of: \"-\", with: \"\")\n    guard cleaned.count == 10 else { return false }\n    \n    var sum = 0\n    for (i, char) in cleaned.enumerated() {\n        guard let digit = char.isNumber ? Int(String(char)) : (i == 9 && char == \"X\" ? 10 : nil) else { return false }\n        sum += digit * (10 - i)\n    }\n    return sum % 11 == 0\n}"
  },
  {
    "input": "func angleBetweenVectors(x1: Double, y1: Double, x2: Double, y2: Double) -> Double {\n    let dot = x1*x2 + y1*y2\n    let mag1 = sqrt(x1*x1 + y1*y1)\n    let mag2 = sqrt(x2*x2 + y2*y2)\n    return acos(dot / (mag1 * mag2))\n}",
    "output": "/// Вычисляет угол между векторами в радианах.\n/// - Parameters:\n///   - (x1, y1): Первый вектор.\n///   - (x2, y2): Второй вектор.\n/// - Returns: Угол между векторами.\nfunc angleBetweenVectors(x1: Double, y1: Double, x2: Double, y2: Double) -> Double {\n    let dot = x1*x2 + y1*y2\n    let mag1 = sqrt(x1*x1 + y1*y1)\n    let mag2 = sqrt(x2*x2 + y2*y2)\n    return acos(dot / (mag1 * mag2))\n}"
  },
  {
    "input": "func md5Hash(_ string: String) -> String {\n    let data = Data(string.utf8)\n    var hash = [UInt8](repeating: 0, count: Int(CC_MD5_DIGEST_LENGTH))\n    _ = data.withUnsafeBytes { CC_MD5($0.baseAddress, CC_LONG(data.count), &hash) }\n    return hash.map { String(format: \"%02hhx\", $0) }.joined()\n}",
    "output": "/// Генерирует MD5-хеш строки.\n/// - Parameter string: Входная строка.\n/// - Returns: Хеш в виде строки.\nfunc md5Hash(_ string: String) -> String {\n    let data = Data(string.utf8)\n    var hash = [UInt8](repeating: 0, count: Int(CC_MD5_DIGEST_LENGTH))\n    _ = data.withUnsafeBytes { CC_MD5($0.baseAddress, CC_LONG(data.count), &hash) }\n    return hash.map { String(format: \"%02hhx\", $0) }.joined()\n}"
  },
  {
    "input": "func isMagicSquare(_ matrix: [[Int]]) -> Bool {\n    guard matrix.count == 3, matrix.allSatisfy({ $0.count == 3 }) else { return false }\n    let magicSum = 15 // Для традиционного магического квадрата 3x3\n    let diag1 = matrix[0][0] + matrix[1][1] + matrix[2][2]\n    let diag2 = matrix[0][2] + matrix[1][1] + matrix[2][0]\n    guard diag1 == magicSum, diag2 == magicSum else { return false }\n    \n    for i in 0..<3 {\n        let rowSum = matrix[i].reduce(0, +)\n        let colSum = matrix[0][i] + matrix[1][i] + matrix[2][i]\n        guard rowSum == magicSum, colSum == magicSum else { return false }\n    }\n    return true\n}",
    "output": "/// Проверяет магический квадрат 3x3.\n/// - Parameter matrix: Матрица 3x3.\n/// - Returns: true, если суммы строк, столбцов и диагоналей равны.\nfunc isMagicSquare(_ matrix: [[Int]]) -> Bool {\n    guard matrix.count == 3, matrix.allSatisfy({ $0.count == 3 }) else { return false }\n    let magicSum = 15 // Для традиционного магического квадрата 3x3\n    let diag1 = matrix[0][0] + matrix[1][1] + matrix[2][2]\n    let diag2 = matrix[0][2] + matrix[1][1] + matrix[2][0]\n    guard diag1 == magicSum, diag2 == magicSum else { return false }\n    \n    for i in 0..<3 {\n        let rowSum = matrix[i].reduce(0, +)\n        let colSum = matrix[0][i] + matrix[1][i] + matrix[2][i]\n        guard rowSum == magicSum, colSum == magicSum else { return false }\n    }\n    return true\n}"
  },
  {
    "input": "func polynomialCoefficients(roots: [Double]) -> [Double] {\n    var coefficients = [1.0]\n    for root in roots {\n        coefficients = zip(coefficients + [0], [0] + coefficients).map { $0 - root * $1 }\n    }\n    return coefficients\n}",
    "output": "/// Вычисляет полиномиальные коэффициенты.\n/// - Parameter roots: Корни полинома.\n/// - Returns: Коэффициенты полинома.\nfunc polynomialCoefficients(roots: [Double]) -> [Double] {\n    var coefficients = [1.0]\n    for root in roots {\n        coefficients = zip(coefficients + [0], [0] + coefficients).map { $0 - root * $1 }\n    }\n    return coefficients\n}"
  },
  {
    "input": "func isApocalypseYear(_ year: Int) -> Bool {\n    guard year > 1 else { return false }\n    for i in 2..<Int(sqrt(Double(year))) + 1 {\n        if year % i == 0 { return false }\n    }\n    return true\n}",
    "output": "/// Проверяет, является ли год годом апокалипсиса (простое число).\n/// - Parameter year: Год.\n/// - Returns: true, если год - простое число.\nfunc isApocalypseYear(_ year: Int) -> Bool {\n    guard year > 1 else { return false }\n    for i in 2..<Int(sqrt(Double(year))) + 1 {\n        if year % i == 0 { return false }\n    }\n    return true\n}"
  },
  {
    "input": "func ellipseArea(a: Double, b: Double) -> Double {\n    return .pi * a * b\n}",
    "output": "/// Вычисляет площадь эллипса.\n/// - Parameters:\n///   - a: Большая полуось.\n///   - b: Малая полуось.\n/// - Returns: Площадь эллипса.\nfunc ellipseArea(a: Double, b: Double) -> Double {\n    return .pi * a * b\n}"
  },
  {
    "input": "func convertSpeed(_ value: Double, from: String, to: String) -> Double {\n    let inMps: Double\n    switch from.lowercased() {\n    case \"km/h\": inMps = value / 3.6\n    case \"mph\": inMps = value * 0.44704\n    default: inMps = value\n    }\n    \n    switch to.lowercased() {\n    case \"km/h\": return inMps * 3.6\n    case \"mph\": return inMps / 0.44704\n    default: return inMps\n    }\n}",
    "output": "/// Конвертирует скорость между единицами измерения.\n/// - Parameters:\n///   - value: Значение.\n///   - from: Исходные единицы (\"km/h\", \"m/s\", \"mph\").\n///   - to: Целевые единицы.\n/// - Returns: Конвертированная скорость.\nfunc convertSpeed(_ value: Double, from: String, to: String) -> Double {\n    let inMps: Double\n    switch from.lowercased() {\n    case \"km/h\": inMps = value / 3.6\n    case \"mph\": inMps = value * 0.44704\n    default: inMps = value\n    }\n    \n    switch to.lowercased() {\n    case \"km/h\": return inMps * 3.6\n    case \"mph\": return inMps / 0.44704\n    default: return inMps\n    }\n}"
  },
  {
    "input": "func groupAnagrams(_ words: [String]) -> [[String]] {\n    let groups = Dictionary(grouping: words) { String($0.sorted()) }\n    return Array(groups.values.filter { $0.count > 1 })\n}",
    "output": "/// Находит анаграммные группы в массиве слов.\n/// - Parameter words: Массив слов.\n/// - Returns: Массив групп анаграмм.\nfunc groupAnagrams(_ words: [String]) -> [[String]] {\n    let groups = Dictionary(grouping: words) { String($0.sorted()) }\n    return Array(groups.values.filter { $0.count > 1 })\n}"
  },
  {
    "input": "func normalizeVector(x: Double, y: Double) -> (Double, Double) {\n    let length = sqrt(x*x + y*y)\n    guard length != 0 else { return (0, 0) }\n    return (x/length, y/length)\n}",
    "output": "/// Вычисляет нормализованный вектор.\n/// - Parameters:\n///   - x: X компонент.\n///   - y: Y компонент.\n/// - Returns: Нормализованный вектор (x, y).\nfunc normalizeVector(x: Double, y: Double) -> (Double, Double) {\n    let length = sqrt(x*x + y*y)\n    guard length != 0 else { return (0, 0) }\n    return (x/length, y/length)\n}"
  },
  {
    "input": "func isValidPassword(_ password: String) -> Bool {\n    let pattern = \"^(?=.*[A-Z])(?=.*[0-9])(?=.*[!@#$%^&*]).{8,}$\"\n    return password.range(of: pattern, options: .regularExpression) != nil\n}",
    "output": "/// Проверяет валидность пароля (минимум 8 символов, заглавная, цифра, спецсимвол).\n/// - Parameter password: Пароль.\n/// - Returns: true, если пароль соответствует требованиям.\nfunc isValidPassword(_ password: String) -> Bool {\n    let pattern = \"^(?=.*[A-Z])(?=.*[0-9])(?=.*[!@#$%^&*]).{8,}$\"\n    return password.range(of: pattern, options: .regularExpression) != nil\n}"
  },
  {
    "input": "func tailRecursiveFactorial(_ n: Int, accumulator: Int = 1) -> Int {\n    return n <= 1 ? accumulator : tailRecursiveFactorial(n-1, accumulator: accumulator * n)\n}",
    "output": "/// Вычисляет факториал с использованием хвостовой рекурсии.\n/// - Parameters:\n///   - n: Число.\n///   - accumulator: Аккумулятор (начинать с 1).\n/// - Returns: Факториал числа.\nfunc tailRecursiveFactorial(_ n: Int, accumulator: Int = 1) -> Int {\n    return n <= 1 ? accumulator : tailRecursiveFactorial(n-1, accumulator: accumulator * n)\n}"
  },
  {
    "input": "func degreesToGradians(_ degrees: Double) -> Double {\n    return degrees * 10 / 9\n}",
    "output": "/// Конвертирует градусы в градианы.\n/// - Parameter degrees: Угол в градусах.\n/// - Returns: Угол в градианах.\nfunc degreesToGradians(_ degrees: Double) -> Double {\n    return degrees * 10 / 9\n}"
  },
  {
    "input": "func combinationsWithRepetition(n: Int, k: Int) -> Int {\n    return (n + k - 1).choose(k)\n}",
    "output": "/// Вычисляет количество комбинаций с повторениями.\n/// - Parameters:\n///   - n: Общее количество элементов.\n///   - k: Размер выборки.\n/// - Returns: Число комбинаций с повторениями.\nfunc combinationsWithRepetition(n: Int, k: Int) -> Int {\n    return (n + k - 1).choose(k)\n}"
  },
  {
    "input": "func isTautogram(_ str: String, caseSensitive: Bool = false) -> Bool {\n    let words = str.components(separatedBy: .whitespaces).filter { !$0.isEmpty }\n    guard !words.isEmpty else { return false }\n    \n    let firstLetter = caseSensitive ? words[0].first : words[0].lowercased().first\n    return words.allSatisfy { word in\n        let letter = caseSensitive ? word.first : word.lowercased().first\n        return letter == firstLetter\n    }\n}",
    "output": "/// Проверяет, является ли строка таутограммой (все слова начинаются с одной буквы).\n/// - Parameters:\n///   - str: Входная строка.\n///   - caseSensitive: Учитывать регистр.\n/// - Returns: true, если таутограмма.\nfunc isTautogram(_ str: String, caseSensitive: Bool = false) -> Bool {\n    let words = str.components(separatedBy: .whitespaces).filter { !$0.isEmpty }\n    guard !words.isEmpty else { return false }\n    \n    let firstLetter = caseSensitive ? words[0].first : words[0].lowercased().first\n    return words.allSatisfy { word in\n        let letter = caseSensitive ? word.first : word.lowercased().first\n        return letter == firstLetter\n    }\n}"
  },
  {
    "input": "func isEvenAndPositive(_ number: Int) -> Bool {\n    return number > 0 && number % 2 == 0\n}",
    "output": "/// Проверяет, является ли число четным и положительным\nfunc isEvenAndPositive(_ number: Int) -> Bool {\n    return number > 0 && number % 2 == 0\n}"
  },
  {
    "input": "func lcmThreeNumbers(a: Int, b: Int, c: Int) -> Int {\n    return lcm(lcm(a, b), c)\n}",
    "output": "/// Вычисляет НОК трех чисел\nfunc lcmThreeNumbers(a: Int, b: Int, c: Int) -> Int {\n    return lcm(lcm(a, b), c)\n}"
  },
  {
    "input": "func kilometersToMiles(_ km: Double) -> Double {\n    return km * 0.621371\n}",
    "output": "/// Преобразует километры в мили\nfunc kilometersToMiles(_ km: Double) -> Double {\n    return km * 0.621371\n}"
  },
  {
    "input": "func countSpaces(in text: String) -> Int {\n    return text.filter { $0 == \" \" }.count\n}",
    "output": "/// Считает количество пробелов в строке\nfunc countSpaces(in text: String) -> Int {\n    return text.filter { $0 == \" \" }.count\n}"
  },
  {
    "input": "func isNumericString(_ str: String) -> Bool {\n    return !str.isEmpty && str.allSatisfy { $0.isNumber }\n}",
    "output": "/// Проверяет, содержит ли строка только цифры\nfunc isNumericString(_ str: String) -> Bool {\n    return !str.isEmpty && str.allSatisfy { $0.isNumber }\n}"
  },
  {
    "input": "func circleArea(diameter: Double) -> Double {\n    let radius = diameter / 2\n    return .pi * radius * radius\n}",
    "output": "/// Вычисляет площадь круга по диаметру\nfunc circleArea(diameter: Double) -> Double {\n    let radius = diameter / 2\n    return .pi * radius * radius\n}"
  },
  {
    "input": "func timeBasedGreeting() -> String {\n    let hour = Calendar.current.component(.hour, from: Date())\n    switch hour {\n    case 6..<12: return \"Доброе утро!\"\n    case 12..<18: return \"Добрый день!\"\n    case 18..<24: return \"Добрый вечер!\"\n    default: return \"Доброй ночи!\"\n    }\n}",
    "output": "/// Генерирует приветствие по времени суток\nfunc timeBasedGreeting() -> String {\n    let hour = Calendar.current.component(.hour, from: Date())\n    switch hour {\n    case 6..<12: return \"Доброе утро!\"\n    case 12..<18: return \"Добрый день!\"\n    case 18..<24: return \"Добрый вечер!\"\n    default: return \"Доброй ночи!\"\n    }\n}"
  },
  {
    "input": "func canFormWord(from letters: String, word: String) -> Bool {\n    let lettersCount = letters.lowercased().countedCharacters\n    let wordCount = word.lowercased().countedCharacters\n    return wordCount.allSatisfy { lettersCount[$0.key] ?? 0 >= $0.value }\n}",
    "output": "/// Проверяет, можно ли из букв первого слова составить второе\nfunc canFormWord(from letters: String, word: String) -> Bool {\n    let lettersCount = letters.lowercased().countedCharacters\n    let wordCount = word.lowercased().countedCharacters\n    return wordCount.allSatisfy { lettersCount[$0.key] ?? 0 >= $0.value }\n}"
  },
  {
    "input": "func averageWordLength(in text: String) -> Double {\n    let words = text.components(separatedBy: .whitespacesAndNewlines).filter { !$0.isEmpty }\n    guard !words.isEmpty else { return 0 }\n    let total = words.reduce(0) { $0 + $1.count }\n    return Double(total) / Double(words.count)\n}",
    "output": "/// Вычисляет среднюю длину слов в строке\nfunc averageWordLength(in text: String) -> Double {\n    let words = text.components(separatedBy: .whitespacesAndNewlines).filter { !$0.isEmpty }\n    guard !words.isEmpty else { return 0 }\n    let total = words.reduce(0) { $0 + $1.count }\n    return Double(total) / Double(words.count)\n}"
  },
  {
    "input": "func isJulianLeapYear(_ year: Int) -> Bool {\n    return year % 4 == 0\n}",
    "output": "/// Проверяет, является ли год високосным по юлианскому календарю\nfunc isJulianLeapYear(_ year: Int) -> Bool {\n    return year % 4 == 0\n}"
  },
  {
    "input": "func radiansToDegrees(_ radians: Double) -> Double {\n    return radians * 180 / .pi\n}",
    "output": "/// Конвертирует радианы в градусы\nfunc radiansToDegrees(_ radians: Double) -> Double {\n    return radians * 180 / .pi\n}"
  },
  {
    "input": "func rangeOfArray(_ numbers: [Int]) -> Int {\n    guard !numbers.isEmpty else { return 0 }\n    return numbers.max()! - numbers.min()!\n}",
    "output": "/// Находит разницу между максимальным и минимальным элементами массива\nfunc rangeOfArray(_ numbers: [Int]) -> Int {\n    guard !numbers.isEmpty else { return 0 }\n    return numbers.max()! - numbers.min()!\n}"
  },
  {
    "input": "func isTriangularNumber(_ n: Int) -> Bool {\n    let discriminant = 1 + 8 * n\n    let sqrtDiscriminant = Int(sqrt(Double(discriminant)))\n    return sqrtDiscriminant * sqrtDiscriminant == discriminant && (sqrtDiscriminant - 1) % 2 == 0\n}",
    "output": "/// Проверяет, является ли число треугольным\nfunc isTriangularNumber(_ n: Int) -> Bool {\n    let discriminant = 1 + 8 * n\n    let sqrtDiscriminant = Int(sqrt(Double(discriminant)))\n    return sqrtDiscriminant * sqrtDiscriminant == discriminant && (sqrtDiscriminant - 1) % 2 == 0\n}"
  },
  {
    "input": "func sumOfDivisors(_ number: Int) -> Int {\n    guard number > 0 else { return 0 }\n    return (1...number).filter { number % $0 == 0 }.reduce(0, +)\n}",
    "output": "/// Вычисляет сумму всех делителей числа\nfunc sumOfDivisors(_ number: Int) -> Int {\n    guard number > 0 else { return 0 }\n    return (1...number).filter { number % $0 == 0 }.reduce(0, +)\n}"
  },
  {
    "input": "func reverseWords(in text: String) -> String {\n    return text.components(separatedBy: \" \").reversed().joined(separator: \" \")\n}",
    "output": "/// Переворачивает слова в строке\nfunc reverseWords(in text: String) -> String {\n    return text.components(separatedBy: \" \").reversed().joined(separator: \" \")\n}"
  },
  {
    "input": "func areCoprime(_ a: Int, _ b: Int) -> Bool {\n    return gcd(a, b) == 1\n}",
    "output": "/// Проверяет, являются ли два числа взаимно простыми\nfunc areCoprime(_ a: Int, _ b: Int) -> Bool {\n    return gcd(a, b) == 1\n}"
  },
  {
    "input": "func levenshteinDistance(_ a: String, _ b: String) -> Int {\n    let empty = [Int](repeating: 0, count: b.count + 1)\n    var matrix = (0...a.count).map { [$0] + empty }\n    \n    for (i, aChar) in a.enumerated() {\n        for (j, bChar) in b.enumerated() {\n            matrix[i+1][j+1] = aChar == bChar ? \n                matrix[i][j] : \n                min(matrix[i][j], matrix[i][j+1], matrix[i+1][j]) + 1\n        }\n    }\n    return matrix.last?.last ?? 0\n}",
    "output": "/// Вычисляет расстояние Левенштейна между двумя строками\nfunc levenshteinDistance(_ a: String, _ b: String) -> Int {\n    let empty = [Int](repeating: 0, count: b.count + 1)\n    var matrix = (0...a.count).map { [$0] + empty }\n    \n    for (i, aChar) in a.enumerated() {\n        for (j, bChar) in b.enumerated() {\n            matrix[i+1][j+1] = aChar == bChar ? \n                matrix[i][j] : \n                min(matrix[i][j], matrix[i][j+1], matrix[i+1][j]) + 1\n        }\n    }\n    return matrix.last?.last ?? 0\n}"
  },
  {
    "input": "func isIncreasing(_ numbers: [Int]) -> Bool {\n    return numbers == numbers.sorted(by: <)\n}",
    "output": "/// Проверяет, является ли массив возрастающим\nfunc isIncreasing(_ numbers: [Int]) -> Bool {\n    return numbers == numbers.sorted(by: <)\n}"
  },
  {
    "input": "func iterativeFactorial(_ n: Int) -> Int {\n    return (1...max(n, 0)).reduce(1, *)\n}",
    "output": "/// Вычисляет факториал без рекурсии\nfunc iterativeFactorial(_ n: Int) -> Int {\n    return (1...max(n, 0)).reduce(1, *)\n}"
  },
  {
    "input": "func celsiusToKelvin(_ celsius: Double) -> Double {\n    return celsius + 273.15\n}",
    "output": "/// Конвертирует температуру в Кельвинах\nfunc celsiusToKelvin(_ celsius: Double) -> Double {\n    return celsius + 273.15\n}"
  },
  {
    "input": "func firstUniqueCharacterIndex(in text: String) -> Int? {\n    let counts = text.reduce(into: [Character: Int]()) { $0[$1, default: 0] += 1 }\n    return text.enumerated().first { counts[$1] == 1 }?.offset\n}",
    "output": "/// Находит индекс первого уникального символа в строке\nfunc firstUniqueCharacterIndex(in text: String) -> Int? {\n    let counts = text.reduce(into: [Character: Int]()) { $0[$1, default: 0] += 1 }\n    return text.enumerated().first { counts[$1] == 1 }?.offset\n}"
  },
  {
    "input": "func isSquareOfPrime(_ n: Int) -> Bool {\n    let sqrtN = Int(sqrt(Double(n)))\n    return sqrtN * sqrtN == n && isPrime(sqrtN)\n}",
    "output": "/// Проверяет, является ли число квадратом простого числа\nfunc isSquareOfPrime(_ n: Int) -> Bool {\n    let sqrtN = Int(sqrt(Double(n)))\n    return sqrtN * sqrtN == n && isPrime(sqrtN)\n}"
  },
  {
    "input": "func sumOfEvenNumbers(upTo n: Int) -> Int {\n    return (0...n).filter { $0 % 2 == 0 }.reduce(0, +)\n}",
    "output": "/// Вычисляет сумму всех четных чисел до N\nfunc sumOfEvenNumbers(upTo n: Int) -> Int {\n    return (0...n).filter { $0 % 2 == 0 }.reduce(0, +)\n}"
  },
  {
    "input": "func isValidPIN(_ pin: String) -> Bool {\n    return pin.count == 4 || pin.count == 6) && pin.allSatisfy { $0.isNumber }\n}",
    "output": "/// Проверяет валидность PIN-кода (ровно 4 или 6 цифр)\nfunc isValidPIN(_ pin: String) -> Bool {\n    return pin.count == 4 || pin.count == 6) && pin.allSatisfy { $0.isNumber }\n}"
  },
  {
    "input": "func hourHandAngle(hour: Int, minutes: Int) -> Double {\n    let hourPosition = Double(hour % 12) * 30 + Double(minutes) * 0.5\n    return hourPosition\n}",
    "output": "/// Вычисляет угол между часовой стрелкой и 12 часами\nfunc hourHandAngle(hour: Int, minutes: Int) -> Double {\n    let hourPosition = Double(hour % 12) * 30 + Double(minutes) * 0.5\n    return hourPosition\n}"
  },
  {
    "input": "func isPangram(_ text: String) -> Bool {\n    let letters = text.lowercased().filter { $0.isLetter }\n    return Set(letters).count >= 26\n}",
    "output": "/// Проверяет, является ли строка панграммой (содержит все буквы алфавита)\nfunc isPangram(_ text: String) -> Bool {\n    let letters = text.lowercased().filter { $0.isLetter }\n    return Set(letters).count >= 26\n}"
  },
  {
    "input": "func allNegative(_ numbers: [Int]) -> Bool {\n    return numbers.allSatisfy { $0 < 0 }\n}",
    "output": "/// Проверяет, являются ли все числа в массиве отрицательными\nfunc allNegative(_ numbers: [Int]) -> Bool {\n    return numbers.allSatisfy { $0 < 0 }\n}"
  },
  {
    "input": "func convertSeconds(_ seconds: Int) -> (days: Int, hours: Int, minutes: Int, seconds: Int) {\n    var remaining = seconds\n    let days = remaining / 86400\n    remaining %= 86400\n    let hours = remaining / 3600\n    remaining %= 3600\n    let minutes = remaining / 60\n    remaining %= 60\n    return (days, hours, minutes, remaining)\n}",
    "output": "/// Конвертирует секунды в дни, часы, минуты и секунды\nfunc convertSeconds(_ seconds: Int) -> (days: Int, hours: Int, minutes: Int, seconds: Int) {\n    var remaining = seconds\n    let days = remaining / 86400\n    remaining %= 86400\n    let hours = remaining / 3600\n    remaining %= 3600\n    let minutes = remaining / 60\n    remaining %= 60\n    return (days, hours, minutes, remaining)\n}"
  },
  {
    "input": "func mostFrequentElement<T: Hashable>(in array: [T]) -> T? {\n    let counts = array.reduce(into: [:]) { $0[$1, default: 0] += 1 }\n    return counts.max { $0.value < $1.value }?.key\n}",
    "output": "/// Находит наиболее часто встречающийся элемент\nfunc mostFrequentElement<T: Hashable>(in array: [T]) -> T? {\n    let counts = array.reduce(into: [:]) { $0[$1, default: 0] += 1 }\n    return counts.max { $0.value < $1.value }?.key\n}"
  },
  {
    "input": "func isBalancedNumber(_ number: Int) -> Bool {\n    let digits = String(number).compactMap { Int(String($0)) }\n    guard digits.count % 2 == 1 else { return false }\n    let mid = digits.count / 2\n    return digits[0..<mid].reduce(0, +) == digits[mid+1...].reduce(0, +)\n}",
    "output": "/// Проверяет, является ли число сбалансированным (суммы цифр слева и справа равны)\nfunc isBalancedNumber(_ number: Int) -> Bool {\n    let digits = String(number).compactMap { Int(String($0)) }\n    guard digits.count % 2 == 1 else { return false }\n    let mid = digits.count / 2\n    return digits[0..<mid].reduce(0, +) == digits[mid+1...].reduce(0, +)\n}"
  },
  {
    "input": "func medianOfArray(_ numbers: [Double]) -> Double {\n    let sorted = numbers.sorted()\n    let mid = sorted.count / 2\n    return sorted.count % 2 == 0 ? (sorted[mid] + sorted[mid-1]) / 2 : sorted[mid]\n}",
    "output": "/// Вычисляет медиану массива\nfunc medianOfArray(_ numbers: [Double]) -> Double {\n    let sorted = numbers.sorted()\n    let mid = sorted.count / 2\n    return sorted.count % 2 == 0 ? (sorted[mid] + sorted[mid-1]) / 2 : sorted[mid]\n}"
  },
  {
    "input": "func isIsogram(_ text: String) -> Bool {\n    let letters = text.lowercased().filter { $0.isLetter }\n    return letters.count == Set(letters).count\n}",
    "output": "/// Проверяет, является ли строка изограммой (все буквы уникальны)\nfunc isIsogram(_ text: String) -> Bool {\n    let letters = text.lowercased().filter { $0.isLetter }\n    return letters.count == Set(letters).count\n}"
  },
  {
    "input": "func sumOfSquares(upTo n: Int) -> Int {\n    return (1...n).map { $0 * $0 }.reduce(0, +)\n}",
    "output": "/// Вычисляет сумму квадратов первых N чисел\nfunc sumOfSquares(upTo n: Int) -> Int {\n    return (1...n).map { $0 * $0 }.reduce(0, +)\n}"
  },
  {
    "input": "func isPerfectCube(_ n: Int) -> Bool {\n    let cubeRoot = Int(round(pow(Double(n), 1/3)))\n    return cubeRoot * cubeRoot * cubeRoot == n\n}",
    "output": "/// Проверяет, является ли число кубом целого числа\nfunc isPerfectCube(_ n: Int) -> Bool {\n    let cubeRoot = Int(round(pow(Double(n), 1/3)))\n    return cubeRoot * cubeRoot * cubeRoot == n\n}"
  },
  {
    "input": "func feetToMeters(_ feet: Double) -> Double {\n    return feet * 0.3048\n}",
    "output": "/// Конвертирует футы в метры\nfunc feetToMeters(_ feet: Double) -> Double {\n    return feet * 0.3048\n}"
  },
  {
    "input": "func sumSquareDifference(upTo n: Int) -> Int {\n    let sum = (1...n).reduce(0, +)\n    let sumOfSquares = (1...n).map { $0 * $0 }.reduce(0, +)\n    return sum * sum - sumOfSquares\n}",
    "output": "/// Находит разность между суммой квадратов и квадратом суммы\nfunc sumSquareDifference(upTo n: Int) -> Int {\n    let sum = (1...n).reduce(0, +)\n    let sumOfSquares = (1...n).map { $0 * $0 }.reduce(0, +)\n    return sum * sum - sumOfSquares\n}"
  },
  {
    "input": "func isSmithNumber(_ n: Int) -> Bool {\n    let primeFactors = primeFactors(n)\n    let digitSum = String(n).compactMap { Int(String($0)) }.reduce(0, +)\n    let factorSum = primeFactors.flatMap { String($0).compactMap { Int(String($0)) } }.reduce(0, +)\n    return primeFactors.count > 1 && digitSum == factorSum\n}",
    "output": "/// Проверяет, является ли число числом Смита\nfunc isSmithNumber(_ n: Int) -> Bool {\n    let primeFactors = primeFactors(n)\n    let digitSum = String(n).compactMap { Int(String($0)) }.reduce(0, +)\n    let factorSum = primeFactors.flatMap { String($0).compactMap { Int(String($0)) } }.reduce(0, +)\n    return primeFactors.count > 1 && digitSum == factorSum\n}"
  },
  {
    "input": "func chebyshevDistance(x1: Int, y1: Int, x2: Int, y2: Int) -> Int {\n    return max(abs(x1 - x2), abs(y1 - y2))\n}",
    "output": "/// Вычисляет расстояние Чебышева между двумя точками\nfunc chebyshevDistance(x1: Int, y1: Int, x2: Int, y2: Int) -> Int {\n    return max(abs(x1 - x2), abs(y1 - y2))\n}"
  },
  {
    "input": "func isRussianMobileNumber(_ phone: String) -> Bool {\n    let pattern = \"^(\\\\+7|8)\\\\d{10}$\"\n    return phone.range(of: pattern, options: .regularExpression) != nil\n}",
    "output": "/// Проверяет, является ли строка мобильным номером (начинается с +7 или 8)\nfunc isRussianMobileNumber(_ phone: String) -> Bool {\n    let pattern = \"^(\\\\+7|8)\\\\d{10}$\"\n    return phone.range(of: pattern, options: .regularExpression) != nil\n}"
  },
  {
    "input": "func mode<T: Hashable>(of array: [T]) -> [T] {\n    let counts = array.reduce(into: [:]) { $0[$1, default: 0] += 1 }\n    guard let maxCount = counts.values.max() else { return [] }\n    return counts.filter { $0.value == maxCount }.map { $0.key }\n}",
    "output": "/// Вычисляет модальное значение массива\nfunc mode<T: Hashable>(of array: [T]) -> [T] {\n    let counts = array.reduce(into: [:]) { $0[$1, default: 0] += 1 }\n    guard let maxCount = counts.values.max() else { return [] }\n    return counts.filter { $0.value == maxCount }.map { $0.key }\n}"
  },
  {
    "input": "func hasUniqueDigits(year: Int) -> Bool {\n    let digits = Set(String(year))\n    return digits.count == 4\n}",
    "output": "/// Проверяет, является ли год годом с повторяющимися цифрами\n/// - Parameter year: Год (4-значное число)\n/// - Returns: true, если все цифры года уникальны\nfunc hasUniqueDigits(year: Int) -> Bool {\n    let digits = Set(String(year))\n    return digits.count == 4\n}"
  },
  {
    "input": "func squareDifference(a: Int, b: Int) -> Int {\n    return (a + b) * (a + b) - (a * a + b * b)\n}",
    "output": "/// Вычисляет разницу между квадратом суммы и суммой квадратов двух чисел\n/// - Parameters:\n///   - a: Первое число\n///   - b: Второе число\n/// - Returns: (a + b)² - (a² + b²)\nfunc squareDifference(a: Int, b: Int) -> Int {\n    return (a + b) * (a + b) - (a * a + b * b)\n}"
  },
  {
    "input": "func allCharactersUnique(_ str: String) -> Bool {\n    return str.count == Set(str).count\n}",
    "output": "/// Проверяет, содержит ли строка только уникальные символы\n/// - Parameter str: Входная строка\n/// - Returns: true, если все символы уникальны\nfunc allCharactersUnique(_ str: String) -> Bool {\n    return str.count == Set(str).count\n}"
  },
  {
    "input": "func metersToKilometers(_ meters: Double) -> Double {\n    return meters / 1000\n}",
    "output": "/// Конвертирует метры в километры\n/// - Parameter meters: Значение в метрах\n/// - Returns: Значение в километрах\nfunc metersToKilometers(_ meters: Double) -> Double {\n    return meters / 1000\n}"
  },
  {
    "input": "func geometricMean(a: Double, b: Double) -> Double {\n    return sqrt(a * b)\n}",
    "output": "/// Находит среднее геометрическое двух чисел\n/// - Parameters:\n///   - a: Первое число\n///   - b: Второе число\n/// - Returns: √(a * b)\nfunc geometricMean(a: Double, b: Double) -> Double {\n    return sqrt(a * b)\n}"
  },
  {
    "input": "func isPerfectSquare(_ number: Int) -> Bool {\n    let sqrtNum = Int(Double(number).squareRoot())\n    return sqrtNum * sqrtNum == number\n}",
    "output": "/// Проверяет, является ли число совершенным квадратом\n/// - Parameter number: Проверяемое число\n/// - Returns: true, если число - полный квадрат\nfunc isPerfectSquare(_ number: Int) -> Bool {\n    let sqrtNum = Int(Double(number).squareRoot())\n    return sqrtNum * sqrtNum == number\n}"
  },
  {
    "input": "func fahrenheitToCelsius(_ fahrenheit: Double) -> Double {\n    return (fahrenheit - 32) * 5/9\n}",
    "output": "/// Переводит температуру из Фаренгейтов в Цельсии\n/// - Parameter fahrenheit: Температура в °F\n/// - Returns: Температура в °C\nfunc fahrenheitToCelsius(_ fahrenheit: Double) -> Double {\n    return (fahrenheit - 32) * 5/9\n}"
  },
  {
    "input": "func countConsonants(text: String) -> Int {\n    let vowels: Set<Character> = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    return text.lowercased().filter { $0.isLetter && !vowels.contains($0) }.count\n}",
    "output": "/// Считает количество согласных букв в строке\n/// - Parameter text: Входная строка\n/// - Returns: Количество согласных\nfunc countConsonants(text: String) -> Int {\n    let vowels: Set<Character> = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    return text.lowercased().filter { $0.isLetter && !vowels.contains($0) }.count\n}"
  },
  {
    "input": "func isSymmetricArray<T: Equatable>(_ array: [T]) -> Bool {\n    for i in 0..<array.count/2 {\n        if array[i] != array[array.count - 1 - i] {\n            return false\n        }\n    }\n    return true\n}",
    "output": "/// Проверяет, является ли массив симметричным относительно центра\n/// - Parameter array: Входной массив\n/// - Returns: true, если массив симметричен\nfunc isSymmetricArray<T: Equatable>(_ array: [T]) -> Bool {\n    for i in 0..<array.count/2 {\n        if array[i] != array[array.count - 1 - i] {\n            return false\n        }\n    }\n    return true\n}"
  },
  {
    "input": "func calculatePercentage(value: Double, percent: Double) -> Double {\n    return value * percent / 100\n}",
    "output": "/// Вычисляет процент от числа\n/// - Parameters:\n///   - value: Исходное число\n///   - percent: Процент (0-100)\n/// - Returns: Результат вычисления\nfunc calculatePercentage(value: Double, percent: Double) -> Double {\n    return value * percent / 100\n}"
  },
  {
    "input": "func endsWith(str: String, suffix: String) -> Bool {\n    return str.hasSuffix(suffix)\n}",
    "output": "/// Проверяет, заканчивается ли строка указанным суффиксом\n/// - Parameters:\n///   - str: Основная строка\n///   - suffix: Проверяемый суффикс\n/// - Returns: true, если строка заканчивается суффиксом\nfunc endsWith(str: String, suffix: String) -> Bool {\n    return str.hasSuffix(suffix)\n}"
  },
  {
    "input": "func timeToMinutes(hours: Int, minutes: Int) -> Int {\n    return hours * 60 + minutes\n}",
    "output": "/// Конвертирует часы и минуты в общее количество минут\n/// - Parameters:\n///   - hours: Часы\n///   - minutes: Минуты\n/// - Returns: Общее количество минут\nfunc timeToMinutes(hours: Int, minutes: Int) -> Int {\n    return hours * 60 + minutes\n}"
  },
  {
    "input": "func minOfThree(a: Int, b: Int, c: Int) -> Int {\n    return min(a, min(b, c))\n}",
    "output": "/// Находит минимальное из трех чисел\n/// - Parameters:\n///   - a: Первое число\n///   - b: Второе число\n///   - c: Третье число\n/// - Returns: Наименьшее число\nfunc minOfThree(a: Int, b: Int, c: Int) -> Int {\n    return min(a, min(b, c))\n}"
  },
  {
    "input": "func hasDuplicates<T: Hashable>(_ array: [T]) -> Bool {\n    return array.count != Set(array).count\n}",
    "output": "/// Проверяет, содержит ли массив дубликаты\n/// - Parameter array: Входной массив\n/// - Returns: true, если есть повторяющиеся элементы\nfunc hasDuplicates<T: Hashable>(_ array: [T]) -> Bool {\n    return array.count != Set(array).count\n}"
  },
  {
    "input": "func cubeSurfaceArea(side: Double) -> Double {\n    return 6 * side * side\n}",
    "output": "/// Вычисляет площадь поверхности куба\n/// - Parameter side: Длина ребра куба\n/// - Returns: Площадь поверхности\nfunc cubeSurfaceArea(side: Double) -> Double {\n    return 6 * side * side\n}"
  },
  {
    "input": "func isPowerOfFour(_ n: Int) -> Bool {\n    guard n > 0 else { return false }\n    var num = n\n    while num % 4 == 0 { num /= 4 }\n    return num == 1\n}",
    "output": "/// Проверяет, является ли число степенью четверки\n/// - Parameter n: Проверяемое число\n/// - Returns: true, если число - степень 4\nfunc isPowerOfFour(_ n: Int) -> Bool {\n    guard n > 0 else { return false }\n    var num = n\n    while num % 4 == 0 { num /= 4 }\n    return num == 1\n}"
  },
  {
    "input": "func romanToIntSimple(_ roman: String) -> Int {\n    let values: [Character: Int] = [\"I\":1, \"V\":5, \"X\":10]\n    return roman.reversed().reduce(0) { $0 + (values[$1] ?? 0) }\n}",
    "output": "/// Конвертирует римские цифры в целое число (упрощенная версия)\n/// - Parameter roman: Римское число (I-X)\n/// - Returns: Соответствующее целое число\nfunc romanToIntSimple(_ roman: String) -> Int {\n    let values: [Character: Int] = [\"I\":1, \"V\":5, \"X\":10]\n    return roman.reversed().reduce(0) { $0 + (values[$1] ?? 0) }\n}"
  },
  {
    "input": "func sumOfDigits(number: Int) -> Int {\n    return String(number).compactMap { Int(String($0)) }.reduce(0, +)\n}",
    "output": "/// Вычисляет сумму цифр в числе\n/// - Parameter number: Исходное число\n/// - Returns: Сумма цифр\nfunc sumOfDigits(number: Int) -> Int {\n    return String(number).compactMap { Int(String($0)) }.reduce(0, +)\n}"
  },
  {
    "input": "func isPalindromeIgnoringSpaces(_ str: String) -> Bool {\n    let cleaned = str.replacingOccurrences(of: \" \", with: \"\").lowercased()\n    return cleaned == String(cleaned.reversed())\n}",
    "output": "/// Проверяет, является ли строка палиндромом игнорируя пробелы\n/// - Parameter str: Входная строка\n/// - Returns: true, если строка - палиндром\nfunc isPalindromeIgnoringSpaces(_ str: String) -> Bool {\n    let cleaned = str.replacingOccurrences(of: \" \", with: \"\").lowercased()\n    return cleaned == String(cleaned.reversed())\n}"
  },
  {
    "input": "func sphereVolume(radius: Double) -> Double {\n    return (4/3) * .pi * pow(radius, 3)\n}",
    "output": "/// Вычисляет объем шара\n/// - Parameter radius: Радиус шара\n/// - Returns: Объем\nfunc sphereVolume(radius: Double) -> Double {\n    return (4/3) * .pi * pow(radius, 3)\n}"
  },
  {
    "input": "func areAnagrams(_ str1: String, _ str2: String) -> Bool {\n    return str1.lowercased().sorted() == str2.lowercased().sorted()\n}",
    "output": "/// Проверяет, являются ли две строки анаграммами.\n/// - Parameters:\n///   - str1: Первая строка.\n///   - str2: Вторая строка.\n/// - Returns: true, если строки являются анаграммами.\nfunc areAnagrams(_ str1: String, _ str2: String) -> Bool {\n    return str1.lowercased().sorted() == str2.lowercased().sorted()\n}"
  },
  {
    "input": "func countUnique<T: Hashable>(in array: [T]) -> Int {\n    return Set(array).count\n}",
    "output": "/// Возвращает количество уникальных элементов в массиве.\n/// - Parameter array: Входной массив.\n/// - Returns: Количество уникальных элементов.\nfunc countUnique<T: Hashable>(in array: [T]) -> Int {\n    return Set(array).count\n}"
  },
  {
    "input": "func formatDate(_ date: Date) -> String {\n    let formatter = DateFormatter()\n    formatter.dateFormat = \"dd.MM.yyyy\"\n    return formatter.string(from: date)\n}",
    "output": "/// Форматирует дату в строку формата \"dd.MM.yyyy\".\n/// - Parameter date: Дата для форматирования.\n/// - Returns: Отформатированная строка.\nfunc formatDate(_ date: Date) -> String {\n    let formatter = DateFormatter()\n    formatter.dateFormat = \"dd.MM.yyyy\"\n    return formatter.string(from: date)\n}"
  },
  {
    "input": "func mergeDictionaries<K, V>(_ dict1: [K: V], _ dict2: [K: V]) -> [K: V] {\n    return dict1.merging(dict2) { _, new in new }\n}",
    "output": "/// Объединяет два словаря. Значения из второго заменяют дубли в первом.\n/// - Parameters:\n///   - dict1: Первый словарь.\n///   - dict2: Второй словарь.\n/// - Returns: Объединенный словарь.\nfunc mergeDictionaries<K, V>(_ dict1: [K: V], _ dict2: [K: V]) -> [K: V] {\n    return dict1.merging(dict2) { _, new in new }\n}"
  },
  {
    "input": "func wordCount(in text: String) -> Int {\n    return text.split { $0.isWhitespace }.count\n}",
    "output": "/// Подсчитывает количество слов в строке.\n/// - Parameter text: Входная строка.\n/// - Returns: Количество слов.\nfunc wordCount(in text: String) -> Int {\n    return text.split { $0.isWhitespace }.count\n}"
  },
  {
    "input": "func gcd(_ a: Int, _ b: Int) -> Int {\n    var a = a, b = b\n    while b != 0 {\n        let temp = b\n        b = a % b\n        a = temp\n    }\n    return a\n}",
    "output": "/// Вычисляет наибольший общий делитель двух чисел.\n/// - Parameters:\n///   - a: Первое число.\n///   - b: Второе число.\n/// - Returns: НОД.\nfunc gcd(_ a: Int, _ b: Int) -> Int {\n    var a = a, b = b\n    while b != 0 {\n        let temp = b\n        b = a % b\n        a = temp\n    }\n    return a\n}"
  },
  {
    "input": "func readFile(at path: String) -> String? {\n    return try? String(contentsOfFile: path, encoding: .utf8)\n}",
    "output": "/// Считывает содержимое файла по указанному пути.\n/// - Parameter path: Путь к файлу.\n/// - Returns: Строка с содержимым файла или nil.\nfunc readFile(at path: String) -> String? {\n    return try? String(contentsOfFile: path, encoding: .utf8)\n}"
  },
  {
    "input": "func isPalindrome<T: Equatable>(_ array: [T]) -> Bool {\n    return array == array.reversed()\n}",
    "output": "/// Проверяет, является ли массив палиндромом.\n/// - Parameter array: Массив элементов.\n/// - Returns: true, если массив читается одинаково в обе стороны.\nfunc isPalindrome<T: Equatable>(_ array: [T]) -> Bool {\n    return array == array.reversed()\n}"
  },
  {
    "input": "func removeDuplicates<T: Hashable>(from array: [T]) -> [T] {\n    var seen = Set<T>()\n    return array.filter { seen.insert($0).inserted }\n}",
    "output": "/// Удаляет дубликаты из массива, сохраняя порядок.\n/// - Parameter array: Входной массив.\n/// - Returns: Массив без дубликатов.\nfunc removeDuplicates<T: Hashable>(from array: [T]) -> [T] {\n    var seen = Set<T>()\n    return array.filter { seen.insert($0).inserted }\n}"
  },
  {
    "input": "func fileSize(at path: String) -> UInt64? {\n    let attr = try? FileManager.default.attributesOfItem(atPath: path)\n    return attr?[.size] as? UInt64\n}",
    "output": "/// Возвращает размер файла в байтах.\n/// - Parameter path: Путь к файлу.\n/// - Returns: Размер файла в байтах или nil.\nfunc fileSize(at path: String) -> UInt64? {\n    let attr = try? FileManager.default.attributesOfItem(atPath: path)\n    return attr?[.size] as? UInt64\n}"
  },
  {
    "input": "func toTitleCase(_ text: String) -> String {\n    return text.capitalized\n}",
    "output": "/// Преобразует строку в формат заголовка (каждое слово с заглавной буквы).\n/// - Parameter text: Входная строка.\n/// - Returns: Строка в формате заголовка.\nfunc toTitleCase(_ text: String) -> String {\n    return text.capitalized\n}"
  },
  {
    "input": "func sumOfEvenNumbers(in numbers: [Int]) -> Int {\n    return numbers.filter { $0 % 2 == 0 }.reduce(0, +)\n}",
    "output": "/// Возвращает сумму всех четных чисел в массиве.\n/// - Parameter numbers: Массив целых чисел.\n/// - Returns: Сумма четных чисел.\nfunc sumOfEvenNumbers(in numbers: [Int]) -> Int {\n    return numbers.filter { $0 % 2 == 0 }.reduce(0, +)\n}"
  },
  {
    "input": "func isValidEmail(_ email: String) -> Bool {\n    let pattern = \"^[A-Z0-9._%+-]+@[A-Z0-9.-]+\\\\.[A-Z]{2,}$\"\n    let regex = try? NSRegularExpression(pattern: pattern, options: .caseInsensitive)\n    return regex?.firstMatch(in: email, options: [], range: NSRange(location: 0, length: email.utf16.count)) != nil\n}",
    "output": "/// Проверяет, является ли строка допустимым email.\n/// - Parameter email: Строка для проверки.\n/// - Returns: true, если строка похожа на email.\nfunc isValidEmail(_ email: String) -> Bool {\n    let pattern = \"^[A-Z0-9._%+-]+@[A-Z0-9.-]+\\\\.[A-Z]{2,}$\"\n    let regex = try? NSRegularExpression(pattern: pattern, options: .caseInsensitive)\n    return regex?.firstMatch(in: email, options: [], range: NSRange(location: 0, length: email.utf16.count)) != nil\n}"
  },
  {
    "input": "func jsonString(from dictionary: [String: Any]) -> String? {\n    guard let data = try? JSONSerialization.data(withJSONObject: dictionary, options: .prettyPrinted) else { return nil }\n    return String(data: data, encoding: .utf8)\n}",
    "output": "/// Преобразует словарь в строку JSON.\n/// - Parameter dictionary: Словарь для преобразования.\n/// - Returns: Строка JSON или nil.\nfunc jsonString(from dictionary: [String: Any]) -> String? {\n    guard let data = try? JSONSerialization.data(withJSONObject: dictionary, options: .prettyPrinted) else { return nil }\n    return String(data: data, encoding: .utf8)\n}"
  },
  {
    "input": "func fileExists(at path: String) -> Bool {\n    return FileManager.default.fileExists(atPath: path)\n}",
    "output": "/// Проверяет, существует ли файл по заданному пути.\n/// - Parameter path: Путь к файлу.\n/// - Returns: true, если файл существует.\nfunc fileExists(at path: String) -> Bool {\n    return FileManager.default.fileExists(atPath: path)\n}"
  },
  {
    "input": "func median(of numbers: [Int]) -> Double? {\n    guard !numbers.isEmpty else { return nil }\n    let sorted = numbers.sorted()\n    let mid = sorted.count / 2\n    if sorted.count % 2 == 0 {\n        return Double(sorted[mid - 1] + sorted[mid]) / 2.0\n    } else {\n        return Double(sorted[mid])\n    }\n}",
    "output": "/// Находит медиану в массиве целых чисел.\n/// - Parameter numbers: Массив целых чисел.\n/// - Returns: Медиана или nil, если массив пуст.\nfunc median(of numbers: [Int]) -> Double? {\n    guard !numbers.isEmpty else { return nil }\n    let sorted = numbers.sorted()\n    let mid = sorted.count / 2\n    if sorted.count % 2 == 0 {\n        return Double(sorted[mid - 1] + sorted[mid]) / 2.0\n    } else {\n        return Double(sorted[mid])\n    }\n}"
  },
  {
    "input": "func readableFileSize(from bytes: Int64) -> String {\n    let formatter = ByteCountFormatter()\n    formatter.countStyle = .file\n    return formatter.string(fromByteCount: bytes)\n}",
    "output": "/// Переводит байты в читаемый формат (КБ, МБ и т.д.).\n/// - Parameter bytes: Размер в байтах.\n/// - Returns: Форматированная строка.\nfunc readableFileSize(from bytes: Int64) -> String {\n    let formatter = ByteCountFormatter()\n    formatter.countStyle = .file\n    return formatter.string(fromByteCount: bytes)\n}"
  },
  {
    "input": "func currentDayOfWeek() -> String {\n    let formatter = DateFormatter()\n    formatter.dateFormat = \"EEEE\"\n    return formatter.string(from: Date())\n}",
    "output": "/// Получает текущий день недели в строковом виде.\n/// - Returns: Название дня недели.\nfunc currentDayOfWeek() -> String {\n    let formatter = DateFormatter()\n    formatter.dateFormat = \"EEEE\"\n    return formatter.string(from: Date())\n}"
  },
  {
    "input": "func removeEmptyLines(from lines: [String]) -> [String] {\n    return lines.filter { !$0.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty }\n}",
    "output": "/// Удаляет пустые строки из массива строк.\n/// - Parameter lines: Массив строк.\n/// - Returns: Новый массив без пустых строк.\nfunc removeEmptyLines(from lines: [String]) -> [String] {\n    return lines.filter { !$0.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty }\n}"
  },
  {
    "input": "func startsWithCapitalLetter(_ text: String) -> Bool {\n    guard let first = text.first else { return false }\n    return first.isUppercase\n}",
    "output": "/// Проверяет, начинается ли строка с заглавной буквы.\n/// - Parameter text: Строка для проверки.\n/// - Returns: true, если строка начинается с заглавной буквы.\nfunc startsWithCapitalLetter(_ text: String) -> Bool {\n    guard let first = text.first else { return false }\n    return first.isUppercase\n}"
  },
  {
    "input": "func iso8601String(from date: Date) -> String {\n    let formatter = ISO8601DateFormatter()\n    return formatter.string(from: date)\n}",
    "output": "/// Получает дату в формате ISO8601.\n/// - Parameter date: Дата.\n/// - Returns: Строка в формате ISO8601.\nfunc iso8601String(from date: Date) -> String {\n    let formatter = ISO8601DateFormatter()\n    return formatter.string(from: date)\n}"
  },
  {
    "input": "func invertDictionary<K, V>(_ dictionary: [K: V]) -> [V: K] where K: Hashable, V: Hashable {\n    var result: [V: K] = [:]\n    for (key, value) in dictionary {\n        result[value] = key\n    }\n    return result\n}",
    "output": "/// Разворачивает словарь (меняет местами ключи и значения).\n/// - Parameter dictionary: Словарь.\n/// - Returns: Новый словарь.\nfunc invertDictionary<K, V>(_ dictionary: [K: V]) -> [V: K] where K: Hashable, V: Hashable {\n    var result: [V: K] = [:]\n    for (key, value) in dictionary {\n        result[value] = key\n    }\n    return result\n}"
  },
  {
    "input": "func isPrime(_ number: Int) -> Bool {\n    guard number > 1 else { return false }\n    for i in 2..<Int(sqrt(Double(number))) + 1 {\n        if number % i == 0 {\n            return false\n        }\n    }\n    return true\n}",
    "output": "/// Проверяет, является ли число простым.\n/// - Parameter number: Целое число.\n/// - Returns: true, если число простое.\nfunc isPrime(_ number: Int) -> Bool {\n    guard number > 1 else { return false }\n    for i in 2..<Int(sqrt(Double(number))) + 1 {\n        if number % i == 0 {\n            return false\n        }\n    }\n    return true\n}"
  },
  {
    "input": "func removingLastPathComponent(from path: String) -> String {\n    return (path as NSString).deletingLastPathComponent\n}",
    "output": "/// Удаляет последний компонент пути файла.\n/// - Parameter path: Строка пути.\n/// - Returns: Новый путь без последнего компонента.\nfunc removingLastPathComponent(from path: String) -> String {\n    return (path as NSString).deletingLastPathComponent\n}"
  },
  {
    "input": "func duplicates<T: Hashable>(in array: [T]) -> [T] {\n    var counts: [T: Int] = [:]\n    array.forEach { counts[$0, default: 0] += 1 }\n    return counts.filter { $0.value > 1 }.map { $0.key }\n}",
    "output": "/// Возвращает элементы, встречающиеся чаще одного раза.\n/// - Parameter array: Массив.\n/// - Returns: Массив повторяющихся элементов.\nfunc duplicates<T: Hashable>(in array: [T]) -> [T] {\n    var counts: [T: Int] = [:]\n    array.forEach { counts[$0, default: 0] += 1 }\n    return counts.filter { $0.value > 1 }.map { $0.key }\n}"
  },
  {
    "input": "func isNumeric(_ text: String) -> Bool {\n    return !text.isEmpty && text.allSatisfy { $0.isNumber }\n}",
    "output": "/// Проверяет, содержит ли строка только цифры.\n/// - Parameter text: Входная строка.\n/// - Returns: true, если строка состоит только из цифр.\nfunc isNumeric(_ text: String) -> Bool {\n    return !text.isEmpty && text.allSatisfy { $0.isNumber }\n}"
  },
  {
    "input": "func removeSpaces(from text: String) -> String {\n    return text.replacingOccurrences(of: \" \", with: \"\")\n}",
    "output": "/// Удаляет все пробелы из строки.\n/// - Parameter text: Входная строка.\n/// - Returns: Строка без пробелов.\nfunc removeSpaces(from text: String) -> String {\n    return text.replacingOccurrences(of: \" \", with: \"\")\n}"
  },
  {
    "input": "func uniqueCharacters(in text: String) -> [Character] {\n    return Array(Set(text))\n}",
    "output": "/// Создает массив из уникальных символов строки.\n/// - Parameter text: Входная строка.\n/// - Returns: Массив уникальных символов.\nfunc uniqueCharacters(in text: String) -> [Character] {\n    return Array(Set(text))\n}"
  },
  {
    "input": "func wordFrequencies(in text: String) -> [String: Int] {\n    let words = text.lowercased().split { !$0.isLetter }.map(String.init)\n    var result: [String: Int] = [:]\n    for word in words {\n        result[word, default: 0] += 1\n    }\n    return result\n}",
    "output": "/// Возвращает словарь с подсчетом частоты слов в строке.\n/// - Parameter text: Входная строка.\n/// - Returns: Словарь [слово: количество].\nfunc wordFrequencies(in text: String) -> [String: Int] {\n    let words = text.lowercased().split { !$0.isLetter }.map(String.init)\n    var result: [String: Int] = [:]\n    for word in words {\n        result[word, default: 0] += 1\n    }\n    return result\n}"
  },
  {
    "input": "func isFutureDate(_ date: Date) -> Bool {\n    return date > Date()\n}",
    "output": "/// Проверяет, находится ли указанная дата в будущем.\n/// - Parameter date: Дата для проверки.\n/// - Returns: true, если дата в будущем.\nfunc isFutureDate(_ date: Date) -> Bool {\n    return date > Date()\n}"
  },
  {
    "input": "func removeZeros(from numbers: [Int]) -> [Int] {\n    return numbers.filter { $0 != 0 }\n}",
    "output": "/// Удаляет нулевые значения из массива чисел.\n/// - Parameter numbers: Массив чисел.\n/// - Returns: Массив без нулей.\nfunc removeZeros(from numbers: [Int]) -> [Int] {\n    return numbers.filter { $0 != 0 }\n}"
  },
  {
    "input": "func fileExtension(from path: String) -> String {\n    return (path as NSString).pathExtension\n}",
    "output": "/// Получает расширение файла из строки пути.\n/// - Parameter path: Строка пути.\n/// - Returns: Расширение файла или пустая строка.\nfunc fileExtension(from path: String) -> String {\n    return (path as NSString).pathExtension\n}"
  },
  {
    "input": "func isCleanPalindrome(_ text: String) -> Bool {\n    let cleaned = text.lowercased().filter { $0.isLetter }\n    return cleaned == cleaned.reversed()\n}",
    "output": "/// Проверяет, является ли строка палиндромом без учета регистра и пробелов.\n/// - Parameter text: Входная строка.\n/// - Returns: true, если строка палиндром.\nfunc isCleanPalindrome(_ text: String) -> Bool {\n    let cleaned = text.lowercased().filter { $0.isLetter }\n    return cleaned == cleaned.reversed()\n}"
  },
  {
    "input": "func sortDictionaryByValueDescending<K, V: Comparable>(_ dictionary: [K: V]) -> [(K, V)] {\n    return dictionary.sorted { $0.value > $1.value }\n}",
    "output": "/// Сортирует словарь по значениям в порядке убывания.\n/// - Parameter dictionary: Словарь [ключ: значение].\n/// - Returns: Отсортированный массив пар.\nfunc sortDictionaryByValueDescending<K, V: Comparable>(_ dictionary: [K: V]) -> [(K, V)] {\n    return dictionary.sorted { $0.value > $1.value }\n}"
  },
  {
    "input": "func allElementsUnique<T: Hashable>(_ array: [T]) -> Bool {\n    return Set(array).count == array.count\n}",
    "output": "/// Проверяет, все ли элементы массива уникальны.\n/// - Parameter array: Массив элементов.\n/// - Returns: true, если все элементы уникальны.\nfunc allElementsUnique<T: Hashable>(_ array: [T]) -> Bool {\n    return Set(array).count == array.count\n}"
  },
  {
    "input": "func areArraysEqualUnordered<T: Hashable>(_ a: [T], _ b: [T]) -> Bool {\n    return Set(a) == Set(b)\n}",
    "output": "/// Сравнивает два массива на равенство независимо от порядка.\n/// - Parameters:\n///   - a: Первый массив.\n///   - b: Второй массив.\n/// - Returns: true, если массивы содержат одинаковые элементы.\nfunc areArraysEqualUnordered<T: Hashable>(_ a: [T], _ b: [T]) -> Bool {\n    return Set(a) == Set(b)\n}"
  },
  {
    "input": "func extractNumbers(from text: String) -> [Int] {\n    let pattern = \"\\\\d+\"\n    let matches = try? NSRegularExpression(pattern: pattern).matches(in: text, range: NSRange(text.startIndex..., in: text))\n    return matches?.compactMap {\n        Int((text as NSString).substring(with: $0.range))\n    } ?? []\n}",
    "output": "/// Извлекает все числа из строки.\n/// - Parameter text: Входная строка.\n/// - Returns: Массив целых чисел.\nfunc extractNumbers(from text: String) -> [Int] {\n    let pattern = \"\\\\d+\"\n    let matches = try? NSRegularExpression(pattern: pattern).matches(in: text, range: NSRange(text.startIndex..., in: text))\n    return matches?.compactMap {\n        Int((text as NSString).substring(with: $0.range))\n    } ?? []\n}"
  },
  {
    "input": "func fileCount(in path: String) -> Int? {\n    try? FileManager.default.contentsOfDirectory(atPath: path).count\n}",
    "output": "/// Возвращает количество файлов в указанной директории.\n/// - Parameter path: Путь к директории.\n/// - Returns: Количество файлов или nil.\nfunc fileCount(in path: String) -> Int? {\n    try? FileManager.default.contentsOfDirectory(atPath: path).count\n}"
  },
  {
    "input": "func allNonEmpty(_ array: [String]) -> Bool {\n    return array.allSatisfy { !$0.isEmpty }\n}",
    "output": "/// Проверяет, все ли строки в массиве непустые.\n/// - Parameter array: Массив строк.\n/// - Returns: true, если все строки непустые.\nfunc allNonEmpty(_ array: [String]) -> Bool {\n    return array.allSatisfy { !$0.isEmpty }\n}"
  },
  {
    "input": "func chunkString(_ text: String, length: Int) -> [String] {\n    guard length > 0 else { return [] }\n    return stride(from: 0, to: text.count, by: length).map {\n        let start = text.index(text.startIndex, offsetBy: $0)\n        let end = text.index(start, offsetBy: length, limitedBy: text.endIndex) ?? text.endIndex\n        return String(text[start..<end])\n    }\n}",
    "output": "/// Делит строку на подстроки заданной длины.\n/// - Parameters:\n///   - text: Входная строка.\n///   - length: Длина подстрок.\n/// - Returns: Массив подстрок.\nfunc chunkString(_ text: String, length: Int) -> [String] {\n    guard length > 0 else { return [] }\n    return stride(from: 0, to: text.count, by: length).map {\n        let start = text.index(text.startIndex, offsetBy: $0)\n        let end = text.index(start, offsetBy: length, limitedBy: text.endIndex) ?? text.endIndex\n        return String(text[start..<end])\n    }\n}"
  },
  {
    "input": "func minMax(of array: [Int]) -> (Int, Int)? {\n    guard let min = array.min(), let max = array.max() else { return nil }\n    return (min, max)\n}",
    "output": "/// Получает минимальное и максимальное значение массива.\n/// - Parameter array: Массив чисел.\n/// - Returns: Кортеж (min, max) или nil.\nfunc minMax(of array: [Int]) -> (Int, Int)? {\n    guard let min = array.min(), let max = array.max() else { return nil }\n    return (min, max)\n}"
  },
  {
    "input": "func hasCommonElements<T: Hashable>(_ array1: [T], _ array2: [T]) -> Bool {\n    return !Set(array1).isDisjoint(with: Set(array2))\n}",
    "output": "/// Проверяет, содержит ли массив хотя бы один элемент из другого массива.\n/// - Parameters:\n///   - array1: Первый массив.\n///   - array2: Второй массив.\n/// - Returns: true, если есть общие элементы.\nfunc hasCommonElements<T: Hashable>(_ array1: [T], _ array2: [T]) -> Bool {\n    return !Set(array1).isDisjoint(with: Set(array2))\n}"
  },
  {
    "input": "func removePrefix(_ string: String, prefix: String) -> String {\n    return string.hasPrefix(prefix) ? String(string.dropFirst(prefix.count)) : string\n}",
    "output": "/// Удаляет указанный префикс из строки, если он есть.\n/// - Parameters:\n///   - string: Исходная строка.\n///   - prefix: Префикс для удаления.\n/// - Returns: Строка без префикса.\nfunc removePrefix(_ string: String, prefix: String) -> String {\n    return string.hasPrefix(prefix) ? String(string.dropFirst(prefix.count)) : string\n}"
  },
  {
    "input": "func tokenize(_ text: String) -> [String] {\n    return text.lowercased().components(separatedBy: CharacterSet.alphanumerics.inverted).filter { !$0.isEmpty }\n}",
    "output": "/// Преобразует строку в массив слов, удаляя знаки препинания.\n/// - Parameter text: Входная строка.\n/// - Returns: Массив слов.\nfunc tokenize(_ text: String) -> [String] {\n    return text.lowercased().components(separatedBy: CharacterSet.alphanumerics.inverted).filter { !$0.isEmpty }\n}"
  },
  {
    "input": "func daysBetween(_ from: Date, _ to: Date) -> Int {\n    return Calendar.current.dateComponents([.day], from: from, to: to).day ?? 0\n}",
    "output": "/// Возвращает количество дней между двумя датами.\n/// - Parameters:\n///   - from: Начальная дата.\n///   - to: Конечная дата.\n/// - Returns: Количество дней.\nfunc daysBetween(_ from: Date, _ to: Date) -> Int {\n    return Calendar.current.dateComponents([.day], from: from, to: to).day ?? 0\n}"
  },
  {
    "input": "func replaceAll(_ text: String, target: String, replacement: String) -> String {\n    return text.replacingOccurrences(of: target, with: replacement)\n}",
    "output": "/// Заменяет все вхождения подстроки в строке.\n/// - Parameters:\n///   - text: Исходная строка.\n///   - target: Подстрока для замены.\n///   - replacement: Подстрока-замена.\n/// - Returns: Обновленная строка.\nfunc replaceAll(_ text: String, target: String, replacement: String) -> String {\n    return text.replacingOccurrences(of: target, with: replacement)\n}"
  },
  {
    "input": "func lettersOnly(_ text: String) -> String {\n    return text.filter { $0.isLetter }\n}",
    "output": "/// Удаляет все символы, не являющиеся буквами.\n/// - Parameter text: Входная строка.\n/// - Returns: Строка, содержащая только буквы.\nfunc lettersOnly(_ text: String) -> String {\n    return text.filter { $0.isLetter }\n}"
  },
  {
    "input": "func keysForValue<K, V: Equatable>(_ dictionary: [K: V], value: V) -> [K] {\n    return dictionary.filter { $0.value == value }.map { $0.key }\n}",
    "output": "/// Возвращает все ключи словаря, соответствующие заданному значению.\n/// - Parameters:\n///   - dictionary: Словарь.\n///   - value: Значение для поиска.\n/// - Returns: Массив ключей.\nfunc keysForValue<K, V: Equatable>(_ dictionary: [K: V], value: V) -> [K] {\n    return dictionary.filter { $0.value == value }.map { $0.key }\n}"
  },
  {
    "input": "func allContain(_ array: [String], substring: String) -> Bool {\n    return array.allSatisfy { $0.contains(substring) }\n}",
    "output": "/// Проверяет, содержат ли все строки в массиве подстроку.\n/// - Parameters:\n///   - array: Массив строк.\n///   - substring: Искомая подстрока.\n/// - Returns: true, если все строки содержат подстроку.\nfunc allContain(_ array: [String], substring: String) -> Bool {\n    return array.allSatisfy { $0.contains(substring) }\n}"
  },
  {
    "input": "func removeDuplicateCharacters(from text: String) -> String {\n    var seen = Set<Character>()\n    return String(text.filter { seen.insert($0).inserted })\n}",
    "output": "/// Удаляет дубликаты символов из строки, сохраняя порядок.\n/// - Parameter text: Входная строка.\n/// - Returns: Строка без повторяющихся символов.\nfunc removeDuplicateCharacters(from text: String) -> String {\n    var seen = Set<Character>()\n    return String(text.filter { seen.insert($0).inserted })\n}"
  },
  {
    "input": "func reversedString(_ text: String) -> String {\n    return String(text.reversed())\n}",
    "output": "/// Возвращает обратную строку.\n/// - Parameter text: Входная строка.\n/// - Returns: Строка в обратном порядке.\nfunc reversedString(_ text: String) -> String {\n    return String(text.reversed())\n}"
  },
  {
    "input": "func isAlphabetic(_ text: String) -> Bool {\n    return !text.isEmpty && text.allSatisfy { $0.isLetter }\n}",
    "output": "/// Проверяет, содержит ли строка только буквы.\n/// - Parameter text: Входная строка.\n/// - Returns: true, если все символы — буквы.\nfunc isAlphabetic(_ text: String) -> Bool {\n    return !text.isEmpty && text.allSatisfy { $0.isLetter }\n}"
  },
  {
    "input": "func joinStrings(_ array: [String], separator: String) -> String {\n    return array.joined(separator: separator)\n}",
    "output": "/// Преобразует массив строк в одну строку с разделителем.\n/// - Parameters:\n///   - array: Массив строк.\n///   - separator: Разделитель.\n/// - Returns: Объединённая строка.\nfunc joinStrings(_ array: [String], separator: String) -> String {\n    return array.joined(separator: separator)\n}"
  },
  {
    "input": "func lowercaseFileExtension(_ path: String) -> String {\n    return (path as NSString).pathExtension.lowercased()\n}",
    "output": "/// Получает расширение файла как нижний регистр.\n/// - Parameter path: Строка пути.\n/// - Returns: Расширение файла в нижнем регистре.\nfunc lowercaseFileExtension(_ path: String) -> String {\n    return (path as NSString).pathExtension.lowercased()\n}"
  },
  {
    "input": "func isLeapYear(_ year: Int) -> Bool {\n    return (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0)\n}",
    "output": "/// Проверяет, является ли год високосным.\n/// - Parameter year: Год.\n/// - Returns: true, если год високосный.\nfunc isLeapYear(_ year: Int) -> Bool {\n    return (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0)\n}"
  },
  {
    "input": "func characterCountExcludingSpaces(_ text: String) -> Int {\n    return text.filter { !$0.isWhitespace }.count\n}",
    "output": "/// Возвращает количество символов в строке, исключая пробелы.\n/// - Parameter text: Входная строка.\n/// - Returns: Количество символов.\nfunc characterCountExcludingSpaces(_ text: String) -> Int {\n    return text.filter { !$0.isWhitespace }.count\n}"
  },
  {
    "input": "func dateAfter(days: Int) -> Date {\n    return Calendar.current.date(byAdding: .day, value: days, to: Date()) ?? Date()\n}",
    "output": "/// Возвращает дату через указанное количество дней от текущей.\n/// - Parameter days: Количество дней.\n/// - Returns: Дата в будущем.\nfunc dateAfter(days: Int) -> Date {\n    return Calendar.current.date(byAdding: .day, value: days, to: Date()) ?? Date()\n}"
  },
  {
    "input": "func toSet(_ array: [String]) -> Set<String> {\n    return Set(array)\n}",
    "output": "/// Преобразует массив строк в Set.\n/// - Parameter array: Массив строк.\n/// - Returns: Множество уникальных строк.\nfunc toSet(_ array: [String]) -> Set<String> {\n    return Set(array)\n}"
  },
  {
    "input": "func isASCII(_ text: String) -> Bool {\n    return text.allSatisfy { $0.isASCII }\n}",
    "output": "/// Проверяет, содержит ли строка только символы ASCII.\n/// - Parameter text: Входная строка.\n/// - Returns: true, если строка содержит только ASCII.\nfunc isASCII(_ text: String) -> Bool {\n    return text.allSatisfy { $0.isASCII }\n}"
  },
  {
    "input": "func removeVowels(from text: String) -> String {\n    return text.filter { !\"aeiouAEIOU\".contains($0) }\n}",
    "output": "/// Удаляет все гласные из строки.\n/// - Parameter text: Входная строка.\n/// - Returns: Строка без гласных.\nfunc removeVowels(from text: String) -> String {\n    return text.filter { !\"aeiouAEIOU\".contains($0) }\n}"
  },
  {
    "input": "func firstDuplicate<T: Hashable>(in array: [T]) -> T? {\n    var seen = Set<T>()\n    for element in array {\n        if !seen.insert(element).inserted {\n            return element\n        }\n    }\n    return nil\n}",
    "output": "/// Находит первое повторяющееся значение в массиве.\n/// - Parameter array: Массив элементов.\n/// - Returns: Повторяющийся элемент или nil.\nfunc firstDuplicate<T: Hashable>(in array: [T]) -> T? {\n    var seen = Set<T>()\n    for element in array {\n        if !seen.insert(element).inserted {\n            return element\n        }\n    }\n    return nil\n}"
  },
  {
    "input": "func splitIntoWords(_ text: String) -> [String] {\n    return text.split(separator: \" \").map(String.init)\n}",
    "output": "/// Делит строку на слова по пробелам.\n/// - Parameter text: Входная строка.\n/// - Returns: Массив слов.\nfunc splitIntoWords(_ text: String) -> [String] {\n    return text.split(separator: \" \").map(String.init)\n}"
  },
  {
    "input": "func indexOf<T: Equatable>(_ element: T, in array: [T]) -> Int? {\n    return array.firstIndex(of: element)\n}",
    "output": "/// Получает индекс первого вхождения элемента в массиве.\n/// - Parameters:\n///   - element: Элемент для поиска.\n///   - array: Массив.\n/// - Returns: Индекс элемента или nil.\nfunc indexOf<T: Equatable>(_ element: T, in array: [T]) -> Int? {\n    return array.firstIndex(of: element)\n}"
  },
  {
    "input": "func removePunctuation(from text: String) -> String {\n    return text.filter { !$0.isPunctuation }\n}",
    "output": "/// Удаляет все знаки препинания из строки.\n/// - Parameter text: Входная строка.\n/// - Returns: Строка без знаков препинания.\nfunc removePunctuation(from text: String) -> String {\n    return text.filter { !$0.isPunctuation }\n}"
  },
  {
    "input": "func isValidURL(_ text: String) -> Bool {\n    return URL(string: text) != nil\n}",
    "output": "/// Проверяет, является ли строка URL.\n/// - Parameter text: Входная строка.\n/// - Returns: true, если строка — допустимый URL.\nfunc isValidURL(_ text: String) -> Bool {\n    return URL(string: text) != nil\n}"
  },
  {
    "input": "func maxValue(in numbers: [Int]) -> Int? {\n    return numbers.max()\n}",
    "output": "/// Находит наибольшее число в массиве.\n/// - Parameter numbers: Массив целых чисел.\n/// - Returns: Максимальное значение или nil.\nfunc maxValue(in numbers: [Int]) -> Int? {\n    return numbers.max()\n}"
  },
  {
    "input": "func removeElement<T: Equatable>(_ element: T, from array: [T]) -> [T] {\n    return array.filter { $0 != element }\n}",
    "output": "/// Удаляет заданный элемент из массива.\n/// - Parameters:\n///   - element: Элемент для удаления.\n///   - array: Исходный массив.\n/// - Returns: Новый массив без заданного элемента.\nfunc removeElement<T: Equatable>(_ element: T, from array: [T]) -> [T] {\n    return array.filter { $0 != element }\n}"
  },
  {
    "input": "func allCharactersUnique(_ text: String) -> Bool {\n    return Set(text).count == text.count\n}",
    "output": "/// Проверяет, все ли символы в строке уникальны.\n/// - Parameter text: Входная строка.\n/// - Returns: true, если все символы уникальны.\nfunc allCharactersUnique(_ text: String) -> Bool {\n    return Set(text).count == text.count\n}"
  },
  {
    "input": "func invertedCase(_ text: String) -> String {\n    return String(text.map {\n        $0.isUppercase ? Character($0.lowercased()) : Character($0.uppercased())\n    })\n}",
    "output": "/// Возвращает строку с инвертированным регистром.\n/// - Parameter text: Входная строка.\n/// - Returns: Строка с изменённым регистром.\nfunc invertedCase(_ text: String) -> String {\n    return String(text.map {\n        $0.isUppercase ? Character($0.lowercased()) : Character($0.uppercased())\n    })\n}"
  },
  {
    "input": "func formattedDateTime() -> String {\n    let formatter = DateFormatter()\n    formatter.dateFormat = \"dd.MM.yyyy HH:mm\"\n    return formatter.string(from: Date())\n}",
    "output": "/// Получает дату и время в формате \"dd.MM.yyyy HH:mm\".\n/// - Returns: Форматированная строка даты и времени.\nfunc formattedDateTime() -> String {\n    let formatter = DateFormatter()\n    formatter.dateFormat = \"dd.MM.yyyy HH:mm\"\n    return formatter.string(from: Date())\n}"
  },
  {
    "input": "func countWhere<T>(_ array: [T], condition: (T) -> Bool) -> Int {\n    return array.filter(condition).count\n}",
    "output": "/// Возвращает количество элементов в массиве, удовлетворяющих условию.\n/// - Parameters:\n///   - array: Массив.\n///   - condition: Условие фильтрации.\n/// - Returns: Количество подходящих элементов.\nfunc countWhere<T>(_ array: [T], condition: (T) -> Bool) -> Int {\n    return array.filter(condition).count\n}"
  },
  {
    "input": "func firstCharacters(of text: String, count: Int) -> String {\n    return String(text.prefix(count))\n}",
    "output": "/// Возвращает первые n символов строки.\n/// - Parameters:\n///   - text: Входная строка.\n///   - count: Количество символов.\n/// - Returns: Подстрока из первых n символов.\nfunc firstCharacters(of text: String, count: Int) -> String {\n    return String(text.prefix(count))\n}"
  },
  {
    "input": "func caseInsensitiveEquals(_ a: String, _ b: String) -> Bool {\n    return a.lowercased() == b.lowercased()\n}",
    "output": "/// Сравнивает две строки без учета регистра.\n/// - Parameters:\n///   - a: Первая строка.\n///   - b: Вторая строка.\n/// - Returns: true, если строки равны.\nfunc caseInsensitiveEquals(_ a: String, _ b: String) -> Bool {\n    return a.lowercased() == b.lowercased()\n}"
  },
  {
    "input": "func startsWithDigit(_ text: String) -> Bool {\n    guard let first = text.first else { return false }\n    return first.isNumber\n}",
    "output": "/// Проверяет, начинается ли строка с цифры.\n/// - Parameter text: Входная строка.\n/// - Returns: true, если строка начинается с цифры.\nfunc startsWithDigit(_ text: String) -> Bool {\n    guard let first = text.first else { return false }\n    return first.isNumber\n}"
  },
  {
    "input": "func pairElements<T>(_ array: [T]) -> [[T]] {\n    var result: [[T]] = []\n    var index = 0\n    while index < array.count {\n        let end = min(index + 2, array.count)\n        result.append(Array(array[index..<end]))\n        index += 2\n    }\n    return result\n}",
    "output": "/// Разделяет массив на пары элементов.\n/// - Parameter array: Исходный массив.\n/// - Returns: Массив пар.\nfunc pairElements<T>(_ array: [T]) -> [[T]] {\n    var result: [[T]] = []\n    var index = 0\n    while index < array.count {\n        let end = min(index + 2, array.count)\n        result.append(Array(array[index..<end]))\n        index += 2\n    }\n    return result\n}"
  },
  {
    "input": "func isSorted<T: Comparable>(_ array: [T]) -> Bool {\n    return array == array.sorted()\n}",
    "output": "/// Проверяет, является ли массив отсортированным.\n/// - Parameter array: Массив сравнимых элементов.\n/// - Returns: true, если массив отсортирован.\nfunc isSorted<T: Comparable>(_ array: [T]) -> Bool {\n    return array == array.sorted()\n}"
  },
  {
    "input": "func sortByLength(_ array: [String]) -> [String] {\n    return array.sorted { $0.count < $1.count }\n}",
    "output": "/// Сортирует массив строк по длине.\n/// - Parameter array: Массив строк.\n/// - Returns: Отсортированный массив.\nfunc sortByLength(_ array: [String]) -> [String] {\n    return array.sorted { $0.count < $1.count }\n}"
  },
  {
    "input": "func countCharacter(_ character: Character, in array: [String]) -> Int {\n    return array.reduce(0) { $0 + $1.filter { $0 == character }.count }\n}",
    "output": "/// Находит общее количество вхождений символа в массив строк.\n/// - Parameters:\n///   - character: Символ для подсчета.\n///   - array: Массив строк.\n/// - Returns: Количество вхождений символа.\nfunc countCharacter(_ character: Character, in array: [String]) -> Int {\n    return array.reduce(0) { $0 + $1.filter { $0 == character }.count }\n}"
  },
  {
    "input": "func isWhitespaceOnly(_ text: String) -> Bool {\n    return !text.isEmpty && text.trimmingCharacters(in: .whitespaces).isEmpty\n}",
    "output": "/// Возвращает true, если строка содержит только пробелы.\n/// - Parameter text: Входная строка.\n/// - Returns: true, если строка состоит только из пробелов.\nfunc isWhitespaceOnly(_ text: String) -> Bool {\n    return !text.isEmpty && text.trimmingCharacters(in: .whitespaces).isEmpty\n}"
  },
  {
    "input": "func truncate(_ text: String, to length: Int) -> String {\n    return String(text.prefix(length))\n}",
    "output": "/// Обрезает строку до максимальной длины.\n/// - Parameters:\n///   - text: Входная строка.\n///   - length: Максимальная длина.\n/// - Returns: Обрезанная строка.\nfunc truncate(_ text: String, to length: Int) -> String {\n    return String(text.prefix(length))\n}"
  },
  {
    "input": "func extractDigits(from text: String) -> String {\n    return text.filter { $0.isNumber }\n}",
    "output": "/// Возвращает строку, содержащую только цифры из исходной строки.\n/// - Parameter text: Входная строка.\n/// - Returns: Строка, содержащая только цифры.\nfunc extractDigits(from text: String) -> String {\n    return text.filter { $0.isNumber }\n}"
  },
  {
    "input": "func formatTime(seconds: Int) -> String {\n    let h = seconds / 3600\n    let m = (seconds % 3600) / 60\n    let s = seconds % 60\n    return String(format: \"%02d:%02d:%02d\", h, m, s)\n}",
    "output": "/// Переводит число секунд в строку формата \"чч:мм:сс\".\n/// - Parameter seconds: Количество секунд.\n/// - Returns: Строка времени.\nfunc formatTime(seconds: Int) -> String {\n    let h = seconds / 3600\n    let m = (seconds % 3600) / 60\n    let s = seconds % 60\n    return String(format: \"%02d:%02d:%02d\", h, m, s)\n}"
  },
  {
    "input": "func containsWhere<T>(_ array: [T], predicate: (T) -> Bool) -> Bool {\n    return array.contains(where: predicate)\n}",
    "output": "/// Проверяет, есть ли хотя бы один элемент, удовлетворяющий условию.\n/// - Parameters:\n///   - array: Массив элементов.\n///   - predicate: Условие.\n/// - Returns: true, если найден хотя бы один элемент.\nfunc containsWhere<T>(_ array: [T], predicate: (T) -> Bool) -> Bool {\n    return array.contains(where: predicate)\n}"
  },
  {
    "input": "func uniqueIgnoringCase(_ array: [String]) -> [String] {\n    var seen = Set<String>()\n    return array.filter {\n        let lower = $0.lowercased()\n        if seen.contains(lower) {\n            return false\n        } else {\n            seen.insert(lower)\n            return true\n        }\n    }\n}",
    "output": "/// Возвращает только уникальные строки, игнорируя регистр.\n/// - Parameter array: Массив строк.\n/// - Returns: Массив уникальных строк.\nfunc uniqueIgnoringCase(_ array: [String]) -> [String] {\n    var seen = Set<String>()\n    return array.filter {\n        let lower = $0.lowercased()\n        if seen.contains(lower) {\n            return false\n        } else {\n            seen.insert(lower)\n            return true\n        }\n    }\n}"
  },
  {
    "input": "func underscoreSpaces(in text: String) -> String {\n    return text.replacingOccurrences(of: \" \", with: \"_\")\n}",
    "output": "/// Заменяет пробелы на символ подчеркивания.\n/// - Parameter text: Входная строка.\n/// - Returns: Строка с заменёнными пробелами.\nfunc underscoreSpaces(in text: String) -> String {\n    return text.replacingOccurrences(of: \" \", with: \"_\")\n}"
  },
  {
    "input": "func dayOfMonth(from date: Date) -> Int {\n    return Calendar.current.component(.day, from: date)\n}",
    "output": "/// Получает день месяца из даты.\n/// - Parameter date: Дата.\n/// - Returns: День месяца (1–31).\nfunc dayOfMonth(from date: Date) -> Int {\n    return Calendar.current.component(.day, from: date)\n}"
  },
  {
    "input": "func parseBool(from text: String) -> Bool? {\n    let lower = text.lowercased()\n    if lower == \"true\" || lower == \"yes\" || lower == \"1\" {\n        return true\n    } else if lower == \"false\" || lower == \"no\" || lower == \"0\" {\n        return false\n    } else {\n        return nil\n    }\n}",
    "output": "/// Преобразует строку в булево значение.\n/// - Parameter text: Входная строка.\n/// - Returns: Булево значение или nil.\nfunc parseBool(from text: String) -> Bool? {\n    let lower = text.lowercased()\n    if lower == \"true\" || lower == \"yes\" || lower == \"1\" {\n        return true\n    } else if lower == \"false\" || lower == \"no\" || lower == \"0\" {\n        return false\n    } else {\n        return nil\n    }\n}"
  },
  {
    "input": "func filterLongWords(_ words: [String], minLength: Int) -> [String] {\n    return words.filter { $0.count > minLength }\n}",
    "output": "/// Возвращает список слов, длина которых больше заданной.\n/// - Parameters:\n///   - words: Массив слов.\n///   - minLength: Минимальная длина.\n/// - Returns: Отфильтрованный массив.\nfunc filterLongWords(_ words: [String], minLength: Int) -> [String] {\n    return words.filter { $0.count > minLength }\n}"
  },
  {
    "input": "func containsUppercase(_ text: String) -> Bool {\n    return text.contains { $0.isUppercase }\n}",
    "output": "/// Проверяет, содержит ли строка хотя бы один символ верхнего регистра.\n/// - Parameter text: Входная строка.\n/// - Returns: true, если есть хотя бы один символ верхнего регистра.\nfunc containsUppercase(_ text: String) -> Bool {\n    return text.contains { $0.isUppercase }\n}"
  },
  {
    "input": "func totalWordCount(in array: [String]) -> Int {\n    return array.reduce(0) { $0 + $1.split(separator: \" \").count }\n}",
    "output": "/// Подсчитывает общее количество слов во всех строках массива.\n/// - Parameter array: Массив строк.\n/// - Returns: Общее количество слов.\nfunc totalWordCount(in array: [String]) -> Int {\n    return array.reduce(0) { $0 + $1.split(separator: \" \").count }\n}"
  },
  {
    "input": "func dictionaryFromPairs<K, V>(_ pairs: [(K, V)]) -> [K: V] {\n    return Dictionary(uniqueKeysWithValues: pairs)\n}",
    "output": "/// Преобразует массив кортежей (ключ, значение) в словарь.\n/// - Parameter pairs: Массив пар.\n/// - Returns: Словарь.\nfunc dictionaryFromPairs<K, V>(_ pairs: [(K, V)]) -> [K: V] {\n    return Dictionary(uniqueKeysWithValues: pairs)\n}"
  },
  {
    "input": "func toUpperCase(_ text: String) -> String {\n    return text.uppercased()\n}",
    "output": "/// Возвращает строку с символами в верхнем регистре.\n/// - Parameter text: Входная строка.\n/// - Returns: Строка в верхнем регистре.\nfunc toUpperCase(_ text: String) -> String {\n    return text.uppercased()\n}"
  },
  {
    "input": "func isInRange(_ number: Int, range: ClosedRange<Int>) -> Bool {\n    return range.contains(number)\n}",
    "output": "/// Проверяет, находится ли число в заданном диапазоне (включительно).\n/// - Parameters:\n///   - number: Проверяемое число.\n///   - range: Диапазон.\n/// - Returns: true, если число входит в диапазон.\nfunc isInRange(_ number: Int, range: ClosedRange<Int>) -> Bool {\n    return range.contains(number)\n}"
  },
  {
    "input": "func mergeUnique<T: Hashable>(_ a: [T], _ b: [T]) -> [T] {\n    return Array(Set(a).union(b))\n}",
    "output": "/// Объединяет два массива без дубликатов.\n/// - Parameters:\n///   - a: Первый массив.\n///   - b: Второй массив.\n/// - Returns: Объединенный массив без повторов.\nfunc mergeUnique<T: Hashable>(_ a: [T], _ b: [T]) -> [T] {\n    return Array(Set(a).union(b))\n}"
  },
  {
    "input": "func matchesRegex(_ text: String, pattern: String) -> Bool {\n    return (try? NSRegularExpression(pattern: pattern))\n        .map { $0.firstMatch(in: text, range: NSRange(text.startIndex..., in: text)) != nil } ?? false\n}",
    "output": "/// Возвращает true, если строка соответствует регулярному выражению.\n/// - Parameters:\n///   - text: Входная строка.\n///   - pattern: Регулярное выражение.\n/// - Returns: true, если есть совпадение.\nfunc matchesRegex(_ text: String, pattern: String) -> Bool {\n    return (try? NSRegularExpression(pattern: pattern))\n        .map { $0.firstMatch(in: text, range: NSRange(text.startIndex..., in: text)) != nil } ?? false\n}"
  },
  {
    "input": "func allPositive(_ numbers: [Int]) -> Bool {\n    return numbers.allSatisfy { $0 > 0 }\n}",
    "output": "/// Проверяет, все ли элементы массива являются положительными.\n/// - Parameter numbers: Массив чисел.\n/// - Returns: true, если все элементы больше нуля.\nfunc allPositive(_ numbers: [Int]) -> Bool {\n    return numbers.allSatisfy { $0 > 0 }\n}"
  },
  {
    "input": "func countContaining(_ array: [String], substring: String) -> Int {\n    return array.filter { $0.contains(substring) }.count\n}",
    "output": "/// Возвращает количество строк, содержащих заданную подстроку.\n/// - Parameters:\n///   - array: Массив строк.\n///   - substring: Искомая подстрока.\n/// - Returns: Количество совпадений.\nfunc countContaining(_ array: [String], substring: String) -> Int {\n    return array.filter { $0.contains(substring) }.count\n}"
  },
  {
    "input": "func formatCurrency(_ amount: Double) -> String {\n    let formatter = NumberFormatter()\n    formatter.numberStyle = .currency\n    return formatter.string(from: NSNumber(value: amount)) ?? \"\\(amount)\"\n}",
    "output": "/// Форматирует число как валюту в текущей локали.\n/// - Parameter amount: Сумма.\n/// - Returns: Строка с валютой.\nfunc formatCurrency(_ amount: Double) -> String {\n    let formatter = NumberFormatter()\n    formatter.numberStyle = .currency\n    return formatter.string(from: NSNumber(value: amount)) ?? \"\\(amount)\"\n}"
  },
  {
    "input": "func firstNonEmpty(_ array: [String]) -> String? {\n    return array.first { !$0.isEmpty }\n}",
    "output": "/// Возвращает первый непустой элемент из массива строк.\n/// - Parameter array: Массив строк.\n/// - Returns: Первый непустой элемент или nil.\nfunc firstNonEmpty(_ array: [String]) -> String? {\n    return array.first { !$0.isEmpty }\n}"
  },
  {
    "input": "func allAlphabetic(_ array: [String]) -> Bool {\n    return array.allSatisfy { $0.allSatisfy { $0.isLetter } }\n}",
    "output": "/// Проверяет, все ли строки в массиве состоят только из букв.\n/// - Parameter array: Массив строк.\n/// - Returns: true, если все строки содержат только буквы.\nfunc allAlphabetic(_ array: [String]) -> Bool {\n    return array.allSatisfy { $0.allSatisfy { $0.isLetter } }\n}"
  },
  {
    "input": "func wrapText(_ text: String, length: Int) -> String {\n    return stride(from: 0, to: text.count, by: length).map {\n        let start = text.index(text.startIndex, offsetBy: $0)\n        let end = text.index(start, offsetBy: length, limitedBy: text.endIndex) ?? text.endIndex\n        return String(text[start..<end])\n    }.joined(separator: \"\\n\")\n}",
    "output": "/// Разделяет строку на строки фиксированной длины с переносом строки.\n/// - Parameters:\n///   - text: Входная строка.\n///   - length: Максимальная длина.\n/// - Returns: Многострочная строка.\nfunc wrapText(_ text: String, length: Int) -> String {\n    return stride(from: 0, to: text.count, by: length).map {\n        let start = text.index(text.startIndex, offsetBy: $0)\n        let end = text.index(start, offsetBy: length, limitedBy: text.endIndex) ?? text.endIndex\n        return String(text[start..<end])\n    }.joined(separator: \"\\n\")\n}"
  },
  {
    "input": "func endsWithPunctuation(_ text: String) -> Bool {\n    return text.last?.isPunctuation ?? false\n}",
    "output": "/// Проверяет, заканчивается ли строка знаком препинания.\n/// - Parameter text: Входная строка.\n/// - Returns: true, если последний символ — знак препинания.\nfunc endsWithPunctuation(_ text: String) -> Bool {\n    return text.last?.isPunctuation ?? false\n}"
  },
  {
    "input": "func filterMultiples(of factor: Int, in array: [Int]) -> [Int] {\n    return array.filter { $0 % factor == 0 }\n}",
    "output": "/// Возвращает массив, состоящий только из чисел, кратных заданному значению.\n/// - Parameters:\n///   - array: Массив чисел.\n///   - factor: Делитель.\n/// - Returns: Отфильтрованный массив.\nfunc filterMultiples(of factor: Int, in array: [Int]) -> [Int] {\n    return array.filter { $0 % factor == 0 }\n}"
  },
  {
    "input": "func yesNoString(_ value: Bool) -> String {\n    return value ? \"Да\" : \"Нет\"\n}",
    "output": "/// Преобразует Bool в строку \"Да\"/\"Нет\".\n/// - Parameter value: Булево значение.\n/// - Returns: \"Да\", если true, иначе \"Нет\".\nfunc yesNoString(_ value: Bool) -> String {\n    return value ? \"Да\" : \"Нет\"\n}"
  },
  {
    "input": "func roundToPlaces(_ value: Double, places: Int) -> Double {\n    let factor = pow(10.0, Double(places))\n    return (value * factor).rounded() / factor\n}",
    "output": "/// Округляет число до заданного количества знаков после запятой.\n/// - Parameters:\n///   - value: Число.\n///   - places: Количество знаков.\n/// - Returns: Округлённое число.\nfunc roundToPlaces(_ value: Double, places: Int) -> Double {\n    let factor = pow(10.0, Double(places))\n    return (value * factor).rounded() / factor\n}"
  },
  {
    "input": "func containsDigit(_ text: String) -> Bool {\n    return text.contains { $0.isNumber }\n}",
    "output": "/// Проверяет, есть ли в строке хотя бы одна цифра.\n/// - Parameter text: Входная строка.\n/// - Returns: true, если в строке есть цифра.\nfunc containsDigit(_ text: String) -> Bool {\n    return text.contains { $0.isNumber }\n}"
  },
  {
    "input": "func monthName(from month: Int) -> String? {\n    let formatter = DateFormatter()\n    return formatter.monthSymbols[safe: month - 1]\n}",
    "output": "/// Возвращает имя месяца по номеру.\n/// - Parameter month: Номер месяца (1–12).\n/// - Returns: Название месяца или nil.\nfunc monthName(from month: Int) -> String? {\n    let formatter = DateFormatter()\n    return formatter.monthSymbols[safe: month - 1]\n}"
  },
  {
    "input": "func safeElement<T>(in array: [T], at index: Int) -> T? {\n    return array.indices.contains(index) ? array[index] : nil\n}",
    "output": "/// Безопасно получает элемент массива по индексу.\n/// - Parameters:\n///   - array: Массив.\n///   - index: Индекс.\n/// - Returns: Элемент или nil.\nfunc safeElement<T>(in array: [T], at index: Int) -> T? {\n    return array.indices.contains(index) ? array[index] : nil\n}"
  },
  {
    "input": "func removeZeroValues<K>(_ dictionary: [K: Int]) -> [K: Int] {\n    return dictionary.filter { $0.value != 0 }\n}",
    "output": "/// Удаляет все нулевые значения из словаря.\n/// - Parameter dictionary: Словарь с числовыми значениями.\n/// - Returns: Новый словарь без нулей.\nfunc removeZeroValues<K>(_ dictionary: [K: Int]) -> [K: Int] {\n    return dictionary.filter { $0.value != 0 }\n}"
  },
  {
    "input": "func hasFileExtension(_ path: String, extension ext: String) -> Bool {\n    return (path as NSString).pathExtension.lowercased() == ext.lowercased()\n}",
    "output": "/// Проверяет, начинается ли файл с указанного расширения.\n/// - Parameters:\n///   - path: Путь к файлу.\n///   - extension: Расширение без точки.\n/// - Returns: true, если файл соответствует расширению.\nfunc hasFileExtension(_ path: String, extension ext: String) -> Bool {\n    return (path as NSString).pathExtension.lowercased() == ext.lowercased()\n}"
  },
  {
    "input": "func isLowercase(_ text: String) -> Bool {\n    return !text.isEmpty && text.allSatisfy { !$0.isUppercase }\n}",
    "output": "/// Возвращает true, если строка содержит только символы нижнего регистра.\n/// - Parameter text: Входная строка.\n/// - Returns: true, если все буквы — в нижнем регистре.\nfunc isLowercase(_ text: String) -> Bool {\n    return !text.isEmpty && text.allSatisfy { !$0.isUppercase }\n}"
  },
  {
    "input": "func boolArrayToBinaryString(_ array: [Bool]) -> String {\n    return array.map { $0 ? \"1\" : \"0\" }.joined()\n}",
    "output": "/// Преобразует массив булевых значений в строку из \"1\" и \"0\".\n/// - Parameter array: Массив булевых значений.\n/// - Returns: Строка, где true — \"1\", false — \"0\".\nfunc boolArrayToBinaryString(_ array: [Bool]) -> String {\n    return array.map { $0 ? \"1\" : \"0\" }.joined()\n}"
  },
  {
    "input": "func areAllStringsUniqueIgnoringCase(_ array: [String]) -> Bool {\n    let lowered = array.map { $0.lowercased() }\n    return Set(lowered).count == lowered.count\n}",
    "output": "/// Проверяет, содержит ли массив только уникальные строки без учета регистра.\n/// - Parameter array: Массив строк.\n/// - Returns: true, если все строки уникальны.\nfunc areAllStringsUniqueIgnoringCase(_ array: [String]) -> Bool {\n    let lowered = array.map { $0.lowercased() }\n    return Set(lowered).count == lowered.count\n}"
  },
  {
    "input": "func characterFrequencies(in text: String) -> [Character: Int] {\n    var result: [Character: Int] = [:]\n    for char in text {\n        result[char, default: 0] += 1\n    }\n    return result\n}",
    "output": "/// Создает словарь частот символов строки.\n/// - Parameter text: Входная строка.\n/// - Returns: Словарь [символ: частота].\nfunc characterFrequencies(in text: String) -> [Character: Int] {\n    var result: [Character: Int] = [:]\n    for char in text {\n        result[char, default: 0] += 1\n    }\n    return result\n}"
  },
  {
    "input": "func removeDuplicateWords(from text: String) -> String {\n    var seen = Set<String>()\n    return text.split(separator: \" \").filter {\n        seen.insert(String($0)).inserted\n    }.joined(separator: \" \")\n}",
    "output": "/// Удаляет дубликаты слов из строки.\n/// - Parameter text: Входная строка.\n/// - Returns: Строка без повторяющихся слов.\nfunc removeDuplicateWords(from text: String) -> String {\n    var seen = Set<String>()\n    return text.split(separator: \" \").filter {\n        seen.insert(String($0)).inserted\n    }.joined(separator: \" \")\n}"
  },
  {
    "input": "func isValidJSON(_ text: String) -> Bool {\n    guard let data = text.data(using: .utf8) else { return false }\n    return (try? JSONSerialization.jsonObject(with: data)) != nil\n}",
    "output": "/// Проверяет, является ли строка JSON.\n/// - Parameter text: Входная строка.\n/// - Returns: true, если строка — валидный JSON.\nfunc isValidJSON(_ text: String) -> Bool {\n    guard let data = text.data(using: .utf8) else { return false }\n    return (try? JSONSerialization.jsonObject(with: data)) != nil\n}"
  },
  {
    "input": "func groupByLength(_ array: [String]) -> [Int: [String]] {\n    return Dictionary(grouping: array, by: { $0.count })\n}",
    "output": "/// Преобразует массив строк в словарь по длине слов.\n/// - Parameter array: Массив строк.\n/// - Returns: Словарь [длина: слова].\nfunc groupByLength(_ array: [String]) -> [Int: [String]] {\n    return Dictionary(grouping: array, by: { $0.count })\n}"
  },
  {
    "input": "func evenNumbers(from start: Int, to end: Int) -> [Int] {\n    return Array(start...end).filter { $0 % 2 == 0 }\n}",
    "output": "/// Создает массив всех четных чисел в диапазоне.\n/// - Parameters:\n///   - start: Начало диапазона.\n///   - end: Конец диапазона.\n/// - Returns: Массив четных чисел.\nfunc evenNumbers(from start: Int, to end: Int) -> [Int] {\n    return Array(start...end).filter { $0 % 2 == 0 }\n}"
  },
  {
    "input": "func isHex(_ text: String) -> Bool {\n    let pattern = \"^[0-9a-fA-F]+$\"\n    return matchesRegex(text, pattern: pattern)\n}",
    "output": "/// Проверяет, является ли строка шестнадцатеричным числом.\n/// - Parameter text: Входная строка.\n/// - Returns: true, если строка — hex.\nfunc isHex(_ text: String) -> Bool {\n    let pattern = \"^[0-9a-fA-F]+$\"\n    return matchesRegex(text, pattern: pattern)\n}"
  },
  {
    "input": "func countGreaterThan(_ array: [Int], threshold: Int) -> Int {\n    return array.filter { $0 > threshold }.count\n}",
    "output": "/// Подсчитывает количество элементов, превышающих заданное значение.\n/// - Parameters:\n///   - array: Массив чисел.\n///   - threshold: Порог.\n/// - Returns: Количество элементов.\nfunc countGreaterThan(_ array: [Int], threshold: Int) -> Int {\n    return array.filter { $0 > threshold }.count\n}"
  },
  {
    "input": "func isPositiveNumber(_ text: String) -> Bool {\n    return Double(text).map { $0 > 0 } ?? false\n}",
    "output": "/// Возвращает true, если строка представляет собой положительное число.\n/// - Parameter text: Входная строка.\n/// - Returns: true, если строка — положительное число.\nfunc isPositiveNumber(_ text: String) -> Bool {\n    return Double(text).map { $0 > 0 } ?? false\n}"
  },
  {
    "input": "func squared(_ array: [Int]) -> [Int] {\n    return array.map { $0 * $0 }\n}",
    "output": "/// Возвращает массив чисел, возведённых в квадрат.\n/// - Parameter array: Массив чисел.\n/// - Returns: Массив квадратов.\nfunc squared(_ array: [Int]) -> [Int] {\n    return array.map { $0 * $0 }\n}"
  },
  {
    "input": "func toCamelCase(_ text: String) -> String {\n    let parts = text.lowercased().split { !$0.isLetter }\n    guard let first = parts.first else { return \"\" }\n    return ([first] + parts.dropFirst().map { $0.capitalized }).joined()\n}",
    "output": "/// Переводит строку в \"верблюжий регистр\" (camelCase).\n/// - Parameter text: Входная строка.\n/// - Returns: Строка в camelCase.\nfunc toCamelCase(_ text: String) -> String {\n    let parts = text.lowercased().split { !$0.isLetter }\n    guard let first = parts.first else { return \"\" }\n    return ([first] + parts.dropFirst().map { $0.capitalized }).joined()\n}"
  },
  {
    "input": "func unicodeScalars(from text: String) -> [UInt32] {\n    return text.unicodeScalars.map { $0.value }\n}",
    "output": "/// Преобразует строку в массив Unicode кодов.\n/// - Parameter text: Входная строка.\n/// - Returns: Массив Unicode-значений символов.\nfunc unicodeScalars(from text: String) -> [UInt32] {\n    return text.unicodeScalars.map { $0.value }\n}"
  },
  {
    "input": "func alphanumericOnly(_ text: String) -> String {\n    return text.filter { $0.isLetter || $0.isNumber }\n}",
    "output": "/// Удаляет все символы кроме букв и цифр.\n/// - Parameter text: Входная строка.\n/// - Returns: Строка, содержащая только буквы и цифры.\nfunc alphanumericOnly(_ text: String) -> String {\n    return text.filter { $0.isLetter || $0.isNumber }\n}"
  },
  {
    "input": "func vowelCount(in text: String) -> Int {\n    let vowels = \"aeiouAEIOU\"\n    return text.filter { vowels.contains($0) }.count\n}",
    "output": "/// Подсчитывает количество гласных в строке.\n/// - Parameter text: Входная строка.\n/// - Returns: Количество гласных символов.\nfunc vowelCount(in text: String) -> Int {\n    let vowels = \"aeiouAEIOU\"\n    return text.filter { vowels.contains($0) }.count\n}"
  },
  {
    "input": "func rotate<T>(array: [T], by positions: Int) -> [T] {\n    guard !array.isEmpty else { return array }\n    let offset = ((positions % array.count) + array.count) % array.count\n    return Array(array[offset...] + array[..<offset])\n}",
    "output": "/// Вращает массив на заданное количество позиций.\n/// - Parameters:\n///   - array: Исходный массив.\n///   - positions: Количество позиций для сдвига вправо.\n/// - Returns: Новый массив после вращения.\nfunc rotate<T>(array: [T], by positions: Int) -> [T] {\n    guard !array.isEmpty else { return array }\n    let offset = ((positions % array.count) + array.count) % array.count\n    return Array(array[offset...] + array[..<offset])\n}"
  },
  {
    "input": "func isWeekend(_ date: Date) -> Bool {\n    let weekday = Calendar.current.component(.weekday, from: date)\n    return weekday == 1 || weekday == 7\n}",
    "output": "/// Проверяет, выпадает ли дата на выходной день (суббота или воскресенье).\n/// - Parameter date: Дата для проверки.\n/// - Returns: true, если дата — суббота или воскресенье.\nfunc isWeekend(_ date: Date) -> Bool {\n    let weekday = Calendar.current.component(.weekday, from: date)\n    return weekday == 1 || weekday == 7\n}"
  },
  {
    "input": "func valueOrDefault<K: Hashable, V>(_ key: K, in dictionary: [K: V], default defaultValue: V) -> V {\n    return dictionary[key] ?? defaultValue\n}",
    "output": "/// Возвращает значение по ключу или значение по умолчанию, если ключ отсутствует.\n/// - Parameters:\n///   - key: Ключ для поиска.\n///   - dictionary: Словарь.\n///   - defaultValue: Значение по умолчанию.\n/// - Returns: Значение из словаря или defaultValue.\nfunc valueOrDefault<K: Hashable, V>(_ key: K, in dictionary: [K: V], default defaultValue: V) -> V {\n    return dictionary[key] ?? defaultValue\n}"
  },
  {
    "input": "func createDirectory(at path: String) -> Bool {\n    let url = URL(fileURLWithPath: path)\n    do {\n        try FileManager.default.createDirectory(at: url, withIntermediateDirectories: true, attributes: nil)\n        return true\n    } catch {\n        return false\n    }\n}",
    "output": "/// Создает каталог по указанному пути, если он не существует.\n/// - Parameter path: Путь к каталогу.\n/// - Returns: true, если каталог создан или уже существует.\nfunc createDirectory(at path: String) -> Bool {\n    let url = URL(fileURLWithPath: path)\n    do {\n        try FileManager.default.createDirectory(at: url, withIntermediateDirectories: true, attributes: nil)\n        return true\n    } catch {\n        return false\n    }\n}"
  },
  {
    "input": "func shuffledString(_ text: String) -> String {\n    return String(text.shuffled())\n}",
    "output": "/// Перемешивает символы в строке случайным образом.\n/// - Parameter text: Входная строка.\n/// - Returns: Строка с перемешанными символами.\nfunc shuffledString(_ text: String) -> String {\n    return String(text.shuffled())\n}"
  },
  {
    "input": "func flatten<T>(_ nested: [[T]]) -> [T] {\n    return nested.flatMap { $0 }\n}",
    "output": "/// \"Выравнивает\" вложенный массив из массивов в один плоский массив.\n/// - Parameter nested: Вложенный массив.\n/// - Returns: Плоский массив элементов.\nfunc flatten<T>(_ nested: [[T]]) -> [T] {\n    return nested.flatMap { $0 }\n}"
  },
  {
    "input": "func age(from birthDate: Date) -> Int {\n    let now = Date()\n    let comps = Calendar.current.dateComponents([.year], from: birthDate, to: now)\n    return comps.year ?? 0\n}",
    "output": "/// Вычисляет возраст по дате рождения.\n/// - Parameter birthDate: Дата рождения.\n/// - Returns: Возраст в полных годах.\nfunc age(from birthDate: Date) -> Int {\n    let now = Date()\n    let comps = Calendar.current.dateComponents([.year], from: birthDate, to: now)\n    return comps.year ?? 0\n}"
  },
  {
    "input": "func mapValues<K: Hashable, V, U>(_ dict: [K: V], transform: (V) -> U) -> [K: U] {\n    return dict.mapValues(transform)\n}",
    "output": "/// Применяет трансформацию к значениям словаря и возвращает новый словарь.\n/// - Parameters:\n///   - dict: Исходный словарь.\n///   - transform: Функция преобразования значений.\n/// - Returns: Новый словарь с преобразованными значениями.\nfunc mapValues<K: Hashable, V, U>(_ dict: [K: V], transform: (V) -> U) -> [K: U] {\n    return dict.mapValues(transform)\n}"
  },
  {
    "input": "func copyFile(from: String, to: String) -> Bool {\n    do {\n        try FileManager.default.copyItem(atPath: from, toPath: to)\n        return true\n    } catch {\n        return false\n    }\n}",
    "output": "/// Копирует файл из одного пути в другой.\n/// - Parameters:\n///   - from: Путь к исходному файлу.\n///   - to: Целевой путь.\n/// - Returns: true, если копирование прошло успешно.\nfunc copyFile(from: String, to: String) -> Bool {\n    do {\n        try FileManager.default.copyItem(atPath: from, toPath: to)\n        return true\n    } catch {\n        return false\n    }\n}"
  },
  {
    "input": "func normalizeWhitespace(_ text: String) -> String {\n    let components = text.trimmingCharacters(in: .whitespacesAndNewlines)\n        .components(separatedBy: .whitespacesAndNewlines)\n        .filter { !$0.isEmpty }\n    return components.joined(separator: \" \")\n}",
    "output": "/// Нормализует пробелы в строке: удаляет начальные и конечные, и сводит повторяющиеся к одному.\n/// - Parameter text: Входная строка.\n/// - Returns: Строка с нормализованными пробелами.\nfunc normalizeWhitespace(_ text: String) -> String {\n    let components = text.trimmingCharacters(in: .whitespacesAndNewlines)\n        .components(separatedBy: .whitespacesAndNewlines)\n        .filter { !$0.isEmpty }\n    return components.joined(separator: \" \")\n}"
  },
  {
    "input": "func zipArrays<A, B>(_ a: [A], _ b: [B]) -> [(A, B)] {\n    return Array(zip(a, b))\n}",
    "output": "/// Объединяет два массива в массив кортежей попарно.\n/// - Parameters:\n///   - a: Первый массив.\n///   - b: Второй массив.\n/// - Returns: Массив кортежей (элемент из a, элемент из b).\nfunc zipArrays<A, B>(_ a: [A], _ b: [B]) -> [(A, B)] {\n    return Array(zip(a, b))\n}"
  },
  {
    "input": "func nextWeekday(_ weekday: Int, from date: Date) -> Date? {\n    var comp = DateComponents()\n    comp.weekday = weekday\n    return Calendar.current.nextDate(after: date, matching: comp, matchingPolicy: .nextTime)\n}",
    "output": "/// Находит следующую дату указанного дня недели (1 — воскресенье, 2 — понедельник … 7 — суббота).\n/// - Parameters:\n///   - weekday: Номер дня недели.\n///   - from: Дата старта.\n/// - Returns: Следующая дата этого дня недели или nil.\nfunc nextWeekday(_ weekday: Int, from date: Date) -> Date? {\n    var comp = DateComponents()\n    comp.weekday = weekday\n    return Calendar.current.nextDate(after: date, matching: comp, matchingPolicy: .nextTime)\n}"
  },
  {
    "input": "func filterDictionary<K: Hashable, V>(_ dict: [K: V], predicate: (V) -> Bool) -> [K: V] {\n    return dict.filter { predicate($0.value) }\n}",
    "output": "/// Отфильтровывает словарь по предикату, возвращая только пары, где значение проходит проверку.\n/// - Parameters:\n///   - dict: Исходный словарь.\n///   - predicate: Функция проверки значений.\n/// - Returns: Отфильтрованный словарь.\nfunc filterDictionary<K: Hashable, V>(_ dict: [K: V], predicate: (V) -> Bool) -> [K: V] {\n    return dict.filter { predicate($0.value) }\n}"
  },
  {
    "input": "func recursiveFileList(at path: String) -> [String]? {\n    let url = URL(fileURLWithPath: path)\n    let fm = FileManager.default\n    guard let enumerator = fm.enumerator(at: url, includingPropertiesForKeys: nil) else { return nil }\n    return enumerator.compactMap { ($0 as? URL)?.path }\n}",
    "output": "/// Рекурсивно возвращает список всех файлов в каталоге и его подкаталогах.\n/// - Parameter path: Путь к каталогу.\n/// - Returns: Массив путей к файлам или nil.\nfunc recursiveFileList(at path: String) -> [String]? {\n    let url = URL(fileURLWithPath: path)\n    let fm = FileManager.default\n    guard let enumerator = fm.enumerator(at: url, includingPropertiesForKeys: nil) else { return nil }\n    return enumerator.compactMap { ($0 as? URL)?.path }\n}"
  },
  {
    "input": "func replaceSpacesWithDashes(_ text: String) -> String {\n    return text.replacingOccurrences(of: \" \", with: \"-\")\n}",
    "output": "/// Возвращает строку, заменяя все пробелы на дефисы.\n/// - Parameter text: Входная строка.\n/// - Returns: Строка с заменёнными пробелами на дефисы.\nfunc replaceSpacesWithDashes(_ text: String) -> String {\n    return text.replacingOccurrences(of: \" \", with: \"-\")\n}"
  },
  {
    "input": "func gcdOfArray(_ numbers: [Int]) -> Int {\n    guard let first = numbers.first else { return 0 }\n    return numbers.dropFirst().reduce(first) { gcd($0, $1) }\n}",
    "output": "/// Находит наибольший общий делитель (НОД) для нескольких чисел.\n/// - Parameter numbers: Массив чисел.\n/// - Returns: НОД для всех чисел.\nfunc gcdOfArray(_ numbers: [Int]) -> Int {\n    guard let first = numbers.first else { return 0 }\n    return numbers.dropFirst().reduce(first) { gcd($0, $1) }\n}"
  },
  {
    "input": "func formatDateToDayMonthYear(_ date: Date) -> String {\n    let formatter = DateFormatter()\n    formatter.dateFormat = \"dd-MM-yyyy\"\n    return formatter.string(from: date)\n}",
    "output": "/// Возвращает строку в формате \"dd-MM-yyyy\" из даты.\n/// - Parameter date: Дата.\n/// - Returns: Отформатированная строка.\nfunc formatDateToDayMonthYear(_ date: Date) -> String {\n    let formatter = DateFormatter()\n    formatter.dateFormat = \"dd-MM-yyyy\"\n    return formatter.string(from: date)\n}"
  },
  {
    "input": "func isValidURL(_ text: String) -> Bool {\n    return URL(string: text) != nil\n}",
    "output": "/// Проверяет, является ли строка действительным URL.\n/// - Parameter text: Входная строка.\n/// - Returns: true, если строка является валидным URL.\nfunc isValidURL(_ text: String) -> Bool {\n    return URL(string: text) != nil\n}"
  },
  {
    "input": "func charactersWithoutSpaces(from text: String) -> [Character] {\n    return text.filter { !$0.isWhitespace }\n}",
    "output": "/// Преобразует строку в массив символов, но игнорирует пробелы.\n/// - Parameter text: Входная строка.\n/// - Returns: Массив символов без пробелов.\nfunc charactersWithoutSpaces(from text: String) -> [Character] {\n    return text.filter { !$0.isWhitespace }\n}"
  },
  {
    "input": "func intersection<T: Hashable>(_ a: [T], _ b: [T]) -> [T] {\n    return Array(Set(a).intersection(Set(b)))\n}",
    "output": "/// Находит пересечение двух массивов.\n/// - Parameters:\n///   - a: Первый массив.\n///   - b: Второй массив.\n/// - Returns: Массив общих элементов.\nfunc intersection<T: Hashable>(_ a: [T], _ b: [T]) -> [T] {\n    return Array(Set(a).intersection(Set(b)))\n}"
  },
  {
    "input": "func isPalindromeIgnoringSpacesAndCase(_ text: String) -> Bool {\n    let cleaned = text.lowercased().filter { $0.isLetter }\n    return cleaned == String(cleaned.reversed())\n}",
    "output": "/// Проверяет, является ли строка палиндромом, игнорируя пробелы и регистр.\n/// - Parameter text: Входная строка.\n/// - Returns: true, если строка палиндром.\nfunc isPalindromeIgnoringSpacesAndCase(_ text: String) -> Bool {\n    let cleaned = text.lowercased().filter { $0.isLetter }\n    return cleaned == String(cleaned.reversed())\n}"
  },
  {
    "input": "func filterByDivisibility(_ array: [Int], by divisor: Int) -> [Int] {\n    return array.filter { $0 % divisor == 0 }\n}",
    "output": "/// Возвращает массив чисел, которые делятся на заданное число.\n/// - Parameters:\n///   - array: Массив чисел.\n///   - divisor: Делитель.\n/// - Returns: Массив чисел, делящихся на divisor.\nfunc filterByDivisibility(_ array: [Int], by divisor: Int) -> [Int] {\n    return array.filter { $0 % divisor == 0 }\n}"
  },
  {
    "input": "func sumOfSquares(_ array: [Int]) -> Int {\n    return array.reduce(0) { $0 + $1 * $1 }\n}",
    "output": "/// Вычисляет сумму квадратов чисел в массиве.\n/// - Parameter array: Массив чисел.\n/// - Returns: Сумма квадратов чисел.\nfunc sumOfSquares(_ array: [Int]) -> Int {\n    return array.reduce(0) { $0 + $1 * $1 }\n}"
  },
  {
    "input": "func daysBetweenDates(from: Date, to: Date) -> Int {\n    let components = Calendar.current.dateComponents([.day], from: from, to: to)\n    return components.day ?? 0\n}",
    "output": "/// Получает разницу между двумя датами в днях.\n/// - Parameters:\n///   - from: Начальная дата.\n///   - to: Конечная дата.\n/// - Returns: Разница в днях.\nfunc daysBetweenDates(from: Date, to: Date) -> Int {\n    let components = Calendar.current.dateComponents([.day], from: from, to: to)\n    return components.day ?? 0\n}"
  },
  {
    "input": "func toIntOrNil(_ text: String) -> Int? {\n    return Int(text)\n}",
    "output": "/// Преобразует строку в число, если возможно, или возвращает nil.\n/// - Parameter text: Входная строка.\n/// - Returns: Число или nil.\nfunc toIntOrNil(_ text: String) -> Int? {\n    return Int(text)\n}"
  },
  {
    "input": "func formatDateToYearMonthDay(_ date: Date) -> String {\n    let formatter = DateFormatter()\n    formatter.dateFormat = \"yyyy-MM-dd\"\n    return formatter.string(from: date)\n}",
    "output": "/// Переводит строку в формат \"yyyy-MM-dd\" из даты.\n/// - Parameter date: Дата.\n/// - Returns: Отформатированная строка.\nfunc formatDateToYearMonthDay(_ date: Date) -> String {\n    let formatter = DateFormatter()\n    formatter.dateFormat = \"yyyy-MM-dd\"\n    return formatter.string(from: date)\n}"
  },
  {
    "input": "func replaceCharacter(in text: String, target: Character, replacement: Character) -> String {\n    return text.map { $0 == target ? replacement : $0 }.joined()\n}",
    "output": "/// Заменяет все вхождения одного символа на другой в строке.\n/// - Parameters:\n///   - text: Входная строка.\n///   - target: Символ для замены.\n///   - replacement: Новый символ.\n/// - Returns: Строка с заменёнными символами.\nfunc replaceCharacter(in text: String, target: Character, replacement: Character) -> String {\n    return text.map { $0 == target ? replacement : $0 }.joined()\n}"
  },
  {
    "input": "func paddedNumber(_ number: Int, toLength length: Int) -> String {\n    return String(format: \"%0\\(length)d\", number)\n}",
    "output": "/// Возвращает число в строковом представлении с добавлением ведущих нулей.\n/// - Parameters:\n///   - number: Число.\n///   - length: Длина строки с ведущими нулями.\n/// - Returns: Строка с ведущими нулями.\nfunc paddedNumber(_ number: Int, toLength length: Int) -> String {\n    return String(format: \"%0\\(length)d\", number)\n}"
  },
  {
    "input": "func repeatCharacter(_ character: Character, count: Int) -> String {\n    return String(repeating: String(character), count: count)\n}",
    "output": "/// Создает строку, состоящую из повторяющихся символов.\n/// - Parameters:\n///   - character: Символ для повторения.\n///   - count: Количество повторений.\n/// - Returns: Строка с повторяющимися символами.\nfunc repeatCharacter(_ character: Character, count: Int) -> String {\n    return String(repeating: String(character), count: count)\n}"
  },
  {
    "input": "func uppercaseLettersOnly(_ text: String) -> String {\n    return text.filter { $0.isLetter }.uppercased()\n}",
    "output": "/// Возвращает строку, содержащую все буквы строки в верхнем регистре, игнорируя цифры и символы.\n/// - Parameter text: Входная строка.\n/// - Returns: Строка с заглавными буквами.\nfunc uppercaseLettersOnly(_ text: String) -> String {\n    return text.filter { $0.isLetter }.uppercased()\n}"
  },
  {
    "input": "func isFloatingPointNumber(_ text: String) -> Bool {\n    return Double(text) != nil\n}",
    "output": "/// Проверяет, является ли строка числом с плавающей точкой.\n/// - Parameter text: Входная строка.\n/// - Returns: true, если строка представляет число с плавающей точкой.\nfunc isFloatingPointNumber(_ text: String) -> Bool {\n    return Double(text) != nil\n}"
  },
  {
    "input": "func uniqueElements<T: Hashable>(_ array: [T]) -> [T] {\n    return Array(Set(array))\n}",
    "output": "/// Получает все уникальные элементы массива.\n/// - Parameter array: Массив элементов.\n/// - Returns: Массив уникальных элементов.\nfunc uniqueElements<T: Hashable>(_ array: [T]) -> [T] {\n    return Array(Set(array))\n}"
  },
  {
    "input": "func sortByLengthAndAlphabetically(_ array: [String]) -> [String] {\n    return array.sorted { $0.count == $1.count ? $0 < $1 : $0.count < $1.count }\n}",
    "output": "/// Сортирует массив строк по длине строк, а затем по алфавиту.\n/// - Parameter array: Массив строк.\n/// - Returns: Отсортированный массив строк.\nfunc sortByLengthAndAlphabetically(_ array: [String]) -> [String] {\n    return array.sorted { $0.count == $1.count ? $0 < $1 : $0.count < $1.count }\n}"
  },
  {
    "input": "func isBlank(_ text: String) -> Bool {\n    return text.trimmingCharacters(in: .whitespaces).isEmpty\n}",
    "output": "/// Проверяет, является ли строка пустой или состоит только из пробелов.\n/// - Parameter text: Входная строка.\n/// - Returns: true, если строка пустая или состоит только из пробелов.\nfunc isBlank(_ text: String) -> Bool {\n    return text.trimmingCharacters(in: .whitespaces).isEmpty\n}"
  },
  {
    "input": "func stringToIntArray(_ text: String) -> [Int]? {\n    return text.split(separator: \" \").compactMap { Int($0) }\n}",
    "output": "/// Преобразует строку в массив чисел, разделяя её по пробелам.\n/// - Parameter text: Входная строка.\n/// - Returns: Массив чисел.\nfunc stringToIntArray(_ text: String) -> [Int]? {\n    return text.split(separator: \" \").compactMap { Int($0) }\n}"
  },
  {
    "input": "func minMaxValues(from array: [Int]) -> (min: Int?, max: Int?) {\n    guard !array.isEmpty else { return (nil, nil) }\n    return (array.min(), array.max())\n}",
    "output": "/// Возвращает максимальное и минимальное значение из массива чисел.\n/// - Parameter array: Массив чисел.\n/// - Returns: Кортеж с минимальным и максимальным значением.\nfunc minMaxValues(from array: [Int]) -> (min: Int?, max: Int?) {\n    guard !array.isEmpty else { return (nil, nil) }\n    return (array.min(), array.max())\n}"
  },
  {
    "input": "func formatToDayMonthYear(_ date: Date) -> String {\n    let formatter = DateFormatter()\n    formatter.dateFormat = \"dd/MM/yyyy\"\n    return formatter.string(from: date)\n}",
    "output": "/// Преобразует строку в формат \"dd/MM/yyyy\".\n/// - Parameter date: Дата.\n/// - Returns: Отформатированная строка.\nfunc formatToDayMonthYear(_ date: Date) -> String {\n    let formatter = DateFormatter()\n    formatter.dateFormat = \"dd/MM/yyyy\"\n    return formatter.string(from: date)\n}"
  },
  {
    "input": "func isJSONArray(_ text: String) -> Bool {\n    let data = text.data(using: .utf8)\n    return (try? JSONSerialization.jsonObject(with: data!, options: [])) is [Any]\n}",
    "output": "/// Проверяет, является ли строка содержимым JSON-массива.\n/// - Parameter text: Входная строка.\n/// - Returns: true, если строка представляет массив JSON.\nfunc isJSONArray(_ text: String) -> Bool {\n    let data = text.data(using: .utf8)\n    return (try? JSONSerialization.jsonObject(with: data!, options: [])) is [Any]\n}"
  },
  {
    "input": "func allStringsOfEqualLength(_ array: [String]) -> Bool {\n    guard let first = array.first else { return true }\n    return array.allSatisfy { $0.count == first.count }\n}",
    "output": "/// Проверяет, все ли элементы в массиве строк имеют одинаковую длину.\n/// - Parameter array: Массив строк.\n/// - Returns: true, если все строки одинаковой длины.\nfunc allStringsOfEqualLength(_ array: [String]) -> Bool {\n    guard let first = array.first else { return true }\n    return array.allSatisfy { $0.count == first.count }\n}"
  },
  {
    "input": "func extractDigitsString(from text: String) -> String {\n    return text.filter { $0.isNumber }\n}",
    "output": "/// Возвращает строку, состоящую из символов, представляющих цифры в исходной строке.\n/// - Parameter text: Входная строка.\n/// - Returns: Строка, состоящая только из цифр.\nfunc extractDigitsString(from text: String) -> String {\n    return text.filter { $0.isNumber }\n}"
  },
  {
    "input": "func commonElements<T: Hashable>(_ a: [T], _ b: [T]) -> [T] {\n    return Array(Set(a).intersection(Set(b)))\n}",
    "output": "/// Создаёт и возвращает массив, содержащий элементы, которые встречаются в обоих массивах.\n/// - Parameters:\n///   - a: Первый массив.\n///   - b: Второй массив.\n/// - Returns: Массив общих элементов.\nfunc commonElements<T: Hashable>(_ a: [T], _ b: [T]) -> [T] {\n    return Array(Set(a).intersection(Set(b)))\n}"
  },
  {
    "input": "func joinNumbersWithSeparator(_ array: [Int], separator: String) -> String {\n    return array.map { String($0) }.joined(separator: separator)\n}",
    "output": "/// Преобразует массив чисел в строку, разделенную заданным разделителем.\n/// - Parameters:\n///   - array: Массив чисел.\n///   - separator: Разделитель.\n/// - Returns: Строка с числами, разделёнными separator.\nfunc joinNumbersWithSeparator(_ array: [Int], separator: String) -> String {\n    return array.map { String($0) }.joined(separator: separator)\n}"
  },
  {
    "input": "func sumOfHalvedValues(_ array: [Int]) -> Double {\n    return Double(array.reduce(0) { $0 + $1 }) / 2.0\n}",
    "output": "/// Возвращает сумму всех элементов в массиве, деленных на 2.\n/// - Parameter array: Массив чисел.\n/// - Returns: Сумма всех чисел, делённых на 2.\nfunc sumOfHalvedValues(_ array: [Int]) -> Double {\n    return Double(array.reduce(0) { $0 + $1 }) / 2.0\n}"
  },
  {
    "input": "func isEven(_ number: Int) -> Bool {\n    return number % 2 == 0\n}",
    "output": "/// Проверяет, является ли число чётным.\n/// - Parameter number: Число.\n/// - Returns: true, если число чётное.\nfunc isEven(_ number: Int) -> Bool {\n    return number % 2 == 0\n}"
  },
  {
    "input": "func stringToWordsArray(_ text: String) -> [String] {\n    return text.split(separator: \" \").map { String($0) }\n}",
    "output": "/// Преобразует строку в массив слов, разделенных пробелами.\n/// - Parameter text: Входная строка.\n/// - Returns: Массив слов.\nfunc stringToWordsArray(_ text: String) -> [String] {\n    return text.split(separator: \" \").map { String($0) }\n}"
  },
  {
    "input": "func removePunctuationFromString(_ text: String) -> String {\n    return text.filter { !$0.isPunctuation }\n}",
    "output": "/// Возвращает строку с удалёнными символами пунктуации.\n/// - Parameter text: Входная строка.\n/// - Returns: Строка без пунктуации.\nfunc removePunctuationFromString(_ text: String) -> String {\n    return text.filter { !$0.isPunctuation }\n}"
  },
  {
    "input": "func isNonIntegerNumber(_ text: String) -> Bool {\n    if let number = Double(text) {\n        return floor(number) != number\n    }\n    return false\n}",
    "output": "/// Проверяет, является ли строка числовым значением, которое не является целым числом.\n/// - Parameter text: Входная строка.\n/// - Returns: true, если строка представляет число с плавающей точкой, false — целое число или не число.\nfunc isNonIntegerNumber(_ text: String) -> Bool {\n    if let number = Double(text) {\n        return floor(number) != number\n    }\n    return false\n}"
  },
  {
    "input": "func repeatCharacter(_ character: Character, count: Int) -> String {\n    return String(repeating: String(character), count: count)\n}",
    "output": "/// Генерирует строку, содержащую повторяющийся символ определённое количество раз.\n/// - Parameters:\n///   - character: Символ для повторения.\n///   - count: Количество повторений.\n/// - Returns: Строка с повторяющимися символами.\nfunc repeatCharacter(_ character: Character, count: Int) -> String {\n    return String(repeating: String(character), count: count)\n}"
  },
  {
    "input": "func isUniqueString(_ text: String, in array: [String]) -> Bool {\n    return array.filter { $0 == text }.count == 1\n}",
    "output": "/// Проверяет, является ли строка уникальной в массиве строк.\n/// - Parameters:\n///   - text: Строка для проверки.\n///   - array: Массив строк.\n/// - Returns: true, если строка встречается в массиве только один раз.\nfunc isUniqueString(_ text: String, in array: [String]) -> Bool {\n    return array.filter { $0 == text }.count == 1\n}"
  },
  {
    "input": "func roundedNumber(from text: String, decimals: Int) -> Double? {\n    guard let number = Double(text) else { return nil }\n    return round(number * pow(10, Double(decimals))) / pow(10, Double(decimals))\n}",
    "output": "/// Преобразует строку в число с заданным округлением до определённого числа знаков после запятой.\n/// - Parameters:\n///   - text: Входная строка.\n///   - decimals: Количество знаков после запятой.\n/// - Returns: Округлённое число.\nfunc roundedNumber(from text: String, decimals: Int) -> Double? {\n    guard let number = Double(text) else { return nil }\n    return round(number * pow(10, Double(decimals))) / pow(10, Double(decimals))\n}"
  },
  {
    "input": "func extractDigitsInOrder(from text: String) -> String {\n    return text.filter { $0.isNumber }\n}",
    "output": "/// Возвращает строку, содержащую все цифры из строки в порядке их появления.\n/// - Parameter text: Входная строка.\n/// - Returns: Строка, содержащая только цифры.\nfunc extractDigitsInOrder(from text: String) -> String {\n    return text.filter { $0.isNumber }\n}"
  },
  {
    "input": "func toCobolCase(_ text: String) -> String {\n    let words = text.split(separator: \" \").map { $0.lowercased() }\n    guard let first = words.first else { return \"\" }\n    return [first] + words.dropFirst().map { $0.capitalized }.joined(separator: \" \")\n}",
    "output": "/// Переводит строку в \"кобольдский\" регистр (каждое слово с маленькой буквы, кроме первого).\n/// - Parameter text: Входная строка.\n/// - Returns: Строка в \"кобольдском\" регистре.\nfunc toCobolCase(_ text: String) -> String {\n    let words = text.split(separator: \" \").map { $0.lowercased() }\n    guard let first = words.first else { return \"\" }\n    return [first] + words.dropFirst().map { $0.capitalized }.joined(separator: \" \")\n}"
  },
  {
    "input": "func removeCharactersFromString(_ text: String, charactersToRemove: String) -> String {\n    return text.filter { !charactersToRemove.contains($0) }\n}",
    "output": "/// Возвращает строку с удалением всех символов, которые встречаются в другой строке.\n/// - Parameters:\n///   - text: Входная строка.\n///   - charactersToRemove: Строка с символами для удаления.\n/// - Returns: Строка без указанных символов.\nfunc removeCharactersFromString(_ text: String, charactersToRemove: String) -> String {\n    return text.filter { !charactersToRemove.contains($0) }\n}"
  },
  {
    "input": "func isWholeNumber(_ text: String) -> Bool {\n    return Int(text) != nil\n}",
    "output": "/// Проверяет, является ли строка полным числом без десятичной точки.\n/// - Parameter text: Входная строка.\n/// - Returns: true, если строка представляет целое число.\nfunc isWholeNumber(_ text: String) -> Bool {\n    return Int(text) != nil\n}"
  },
  {
    "input": "func containsSubstring(_ substring: String, in text: String) -> Bool {\n    return text.contains(substring)\n}",
    "output": "/// Проверяет, является ли строка подстрокой другой строки.\n/// - Parameters:\n///   - substring: Подстрока для проверки.\n///   - text: Исходная строка.\n/// - Returns: true, если подстрока найдена в строке.\nfunc containsSubstring(_ substring: String, in text: String) -> Bool {\n    return text.contains(substring)\n}"
  },
  {
    "input": "func stringToCapitalizedWords(_ text: String) -> [String] {\n    return text.split(separator: \" \").map { $0.capitalized }\n}",
    "output": "/// Преобразует строку в список слов с учётом заглавных букв (каждое новое слово начинается с заглавной буквы).\n/// - Parameter text: Входная строка.\n/// - Returns: Массив слов с учётом заглавных букв.\nfunc stringToCapitalizedWords(_ text: String) -> [String] {\n    return text.split(separator: \" \").map { $0.capitalized }\n}"
  },
  {
    "input": "func alternatingCase(_ text: String) -> String {\n    return String(text.enumerated().map { (index, character) in\n        index % 2 == 0 ? character.lowercased() : character.uppercased()\n    })\n}",
    "output": "/// Преобразует строку в строку с чередующимися буквами в верхнем и нижнем регистрах.\n/// - Parameter text: Входная строка.\n/// - Returns: Строка с чередующимися заглавными и строчными буквами.\nfunc alternatingCase(_ text: String) -> String {\n    return String(text.enumerated().map { (index, character) in\n        index % 2 == 0 ? character.lowercased() : character.uppercased()\n    })\n}"
  },
  {
    "input": "func indexOfSubstring(_ substring: String, in text: String) -> Int? {\n    return text.range(of: substring)?.lowerBound.utf16Offset(in: text)\n}",
    "output": "/// Возвращает индекс первого вхождения подстроки в строку.\n/// - Parameters:\n///   - substring: Подстрока для поиска.\n///   - text: Исходная строка.\n/// - Returns: Индекс первого вхождения подстроки или nil, если не найдено.\nfunc indexOfSubstring(_ substring: String, in text: String) -> Int? {\n    return text.range(of: substring)?.lowerBound.utf16Offset(in: text)\n}"
  },
  {
    "input": "func isAlphaOnlyPalindrome(_ text: String) -> Bool {\n    let cleaned = text.lowercased().filter { $0.isLetter }\n    return cleaned == String(cleaned.reversed())\n}",
    "output": "/// Проверяет, является ли строка палиндромом, учитывая только алфавитные символы и игнорируя регистр.\n/// - Parameter text: Входная строка.\n/// - Returns: true, если строка является палиндромом.\nfunc isAlphaOnlyPalindrome(_ text: String) -> Bool {\n    let cleaned = text.lowercased().filter { $0.isLetter }\n    return cleaned == String(cleaned.reversed())\n}"
  },
  {
    "input": "func extractUppercaseLetters(from text: String) -> String {\n    return text.filter { $0.isUppercase }\n}",
    "output": "/// Возвращает строку, содержащую только заглавные буквы из исходной строки.\n/// - Parameter text: Входная строка.\n/// - Returns: Строка, содержащая только заглавные буквы.\nfunc extractUppercaseLetters(from text: String) -> String {\n    return text.filter { $0.isUppercase }\n}"
  },
  {
    "input": "func isBinaryNumber(_ text: String) -> Bool {\n    return text.allSatisfy { $0 == \"0\" || $0 == \"1\" }\n}",
    "output": "/// Возвращает true, если строка является числовым значением в двоичной системе.\n/// - Parameter text: Входная строка.\n/// - Returns: true, если строка является двоичным числом.\nfunc isBinaryNumber(_ text: String) -> Bool {\n    return text.allSatisfy { $0 == \"0\" || $0 == \"1\" }\n}"
  },
  {
    "input": "func capitalizeFirstLetter(_ text: String) -> String {\n    guard let first = text.first else { return text }\n    return first.uppercased() + text.dropFirst()\n}",
    "output": "/// Возвращает строку с первым символом, преобразованным в заглавную букву.\n/// - Parameter text: Входная строка.\n/// - Returns: Строка с первым символом в верхнем регистре.\nfunc capitalizeFirstLetter(_ text: String) -> String {\n    guard let first = text.first else { return text }\n    return first.uppercased() + text.dropFirst()\n}"
  },
  {
    "input": "func stringToCharArray(_ text: String) -> [Character] {\n    return Array(text)\n}",
    "output": "/// Преобразует строку в массив, разбивая по каждому символу.\n/// - Parameter text: Входная строка.\n/// - Returns: Массив символов.\nfunc stringToCharArray(_ text: String) -> [Character] {\n    return Array(text)\n}"
  },
  {
    "input": "func repeatString(_ text: String, count: Int) -> String {\n    return String(repeating: text, count: count)\n}",
    "output": "/// Возвращает строку, которая является результатом повторения строкового значения несколько раз.\n/// - Parameters:\n///   - text: Входная строка.\n///   - count: Количество повторений.\n/// - Returns: Повторённая строка.\nfunc repeatString(_ text: String, count: Int) -> String {\n    return String(repeating: text, count: count)\n}"
  },
  {
    "input": "func isValidTime(_ text: String) -> Bool {\n    let pattern = \"^(2[0-3]|[01]?[0-9]):([0-5]?[0-9])$\"\n    return matchesRegex(text, pattern: pattern)\n}",
    "output": "/// Проверяет, является ли строка представлением действительного времени в формате \"HH:mm\".\n/// - Parameter text: Входная строка.\n/// - Returns: true, если строка является временем в формате \"HH:mm\".\nfunc isValidTime(_ text: String) -> Bool {\n    let pattern = \"^(2[0-3]|[01]?[0-9]):([0-5]?[0-9])$\"\n    return matchesRegex(text, pattern: pattern)\n}"
  },
  {
    "input": "func extractDigitsAndDashes(from text: String) -> String {\n    return text.filter { $0.isNumber || $0 == \"-\" }\n}",
    "output": "/// Возвращает строку, состоящую только из цифр и символов тире, если они присутствуют в строке.\n/// - Parameter text: Входная строка.\n/// - Returns: Строка с цифрами и тире.\nfunc extractDigitsAndDashes(from text: String) -> String {\n    return text.filter { $0.isNumber || $0 == \"-\" }\n}"
  },
  {
    "input": "func lowercaseLettersWithoutNumbers(from text: String) -> String {\n    return text.filter { $0.isLetter }.lowercased()\n}",
    "output": "/// Возвращает все символы строки в нижнем регистре, кроме чисел.\n/// - Parameter text: Входная строка.\n/// - Returns: Строка с буквами в нижнем регистре.\nfunc lowercaseLettersWithoutNumbers(from text: String) -> String {\n    return text.filter { $0.isLetter }.lowercased()\n}"
  },
  {
    "input": "func allStringsHaveEqualLength(_ array: [String]) -> Bool {\n    guard let firstLength = array.first?.count else { return true }\n    return array.allSatisfy { $0.count == firstLength }\n}",
    "output": "/// Проверяет, все ли строки в массиве имеют одинаковую длину.\n/// - Parameter array: Массив строк.\n/// - Returns: true, если все строки одинаковой длины.\nfunc allStringsHaveEqualLength(_ array: [String]) -> Bool {\n    guard let firstLength = array.first?.count else { return true }\n    return array.allSatisfy { $0.count == firstLength }\n}"
  },
  {
    "input": "func splitStringByCharacter(_ text: String, separator: Character) -> [String] {\n    return text.split(separator: separator).map { String($0) }\n}",
    "output": "/// Преобразует строку в список строк, разделённых определённым символом.\n/// - Parameters:\n///   - text: Входная строка.\n///   - separator: Символ для разделения.\n/// - Returns: Массив строк.\nfunc splitStringByCharacter(_ text: String, separator: Character) -> [String] {\n    return text.split(separator: separator).map { String($0) }\n}"
  },
  {
    "input": "func isHexadecimalNumber(_ text: String) -> Bool {\n    let pattern = \"^[0-9A-Fa-f]+$\"\n    return matchesRegex(text, pattern: pattern)\n}",
    "output": "/// Проверяет, является ли строка числовым значением в шестнадцатеричной системе.\n/// - Parameter text: Входная строка.\n/// - Returns: true, если строка является шестнадцатеричным числом.\nfunc isHexadecimalNumber(_ text: String) -> Bool {\n    let pattern = \"^[0-9A-Fa-f]+$\"\n    return matchesRegex(text, pattern: pattern)\n}"
  },
  {
    "input": "func stringToDate(_ text: String) -> Date? {\n    let formatter = DateFormatter()\n    formatter.dateFormat = \"yyyy-MM-dd HH:mm:ss\"\n    return formatter.date(from: text)\n}",
    "output": "/// Преобразует строку в дату с учётом времени в формате \"yyyy-MM-dd HH:mm:ss\".\n/// - Parameter text: Входная строка.\n/// - Returns: Дата, если строка соответствует формату.\nfunc stringToDate(_ text: String) -> Date? {\n    let formatter = DateFormatter()\n    formatter.dateFormat = \"yyyy-MM-dd HH:mm:ss\"\n    return formatter.date(from: text)\n}"
  },
  {
    "input": "func cleanString(_ text: String) -> String {\n    let charactersToRemove = CharacterSet.whitespacesAndNewlines.union(.punctuationCharacters)\n    return text.filter { !charactersToRemove.contains($0.unicodeScalars.first!) }\n}",
    "output": "/// Преобразует строку в строку с удалёнными пробелами, знаками препинания и символами новой строки.\n/// - Parameter text: Входная строка.\n/// - Returns: Строка без пробелов и знаков препинания.\nfunc cleanString(_ text: String) -> String {\n    let charactersToRemove = CharacterSet.whitespacesAndNewlines.union(.punctuationCharacters)\n    return text.filter { !charactersToRemove.contains($0.unicodeScalars.first!) }\n}"
  },
  {
    "input": "func stringToNumberWithBase(_ text: String, base: Int) -> Int? {\n    return Int(text, radix: base)\n}",
    "output": "/// Преобразует строку в число с использованием заданной базы (например, 2 для двоичной системы).\n/// - Parameters:\n///   - text: Входная строка.\n///   - base: База числа.\n/// - Returns: Число в заданной системе счисления.\nfunc stringToNumberWithBase(_ text: String, base: Int) -> Int? {\n    return Int(text, radix: base)\n}"
  },
  {
    "input": "func countUniqueCharacters(in text: String) -> Int {\n    return Set(text).count\n}",
    "output": "/// Преобразует строку в массив символов и возвращает количество уникальных символов.\n/// - Parameter text: Входная строка.\n/// - Returns: Количество уникальных символов.\nfunc countUniqueCharacters(in text: String) -> Int {\n    return Set(text).count\n}"
  },
  {
    "input": "func uniqueCharactersOnly(in text: String) -> String {\n    let characterCount = text.reduce(into: [:]) { counts, char in counts[char, default: 0] += 1 }\n    return String(text.filter { characterCount[$0] == 1 })\n}",
    "output": "/// Возвращает строку, состоящую из символов, которые встречаются в строке не более одного раза.\n/// - Parameter text: Входная строка.\n/// - Returns: Строка с уникальными символами.\nfunc uniqueCharactersOnly(in text: String) -> String {\n    let characterCount = text.reduce(into: [:]) { counts, char in counts[char, default: 0] += 1 }\n    return String(text.filter { characterCount[$0] == 1 })\n}"
  },
  {
    "input": "func isValidEmail(_ text: String) -> Bool {\n    let emailRegex = \"^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\\\.[A-Za-z]{2,}$\"\n    return matchesRegex(text, pattern: emailRegex)\n}",
    "output": "/// Проверяет, является ли строка строкой, представляющей корректный email-адрес.\n/// - Parameter text: Входная строка.\n/// - Returns: true, если строка — корректный email.\nfunc isValidEmail(_ text: String) -> Bool {\n    let emailRegex = \"^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\\\.[A-Za-z]{2,}$\"\n    return matchesRegex(text, pattern: emailRegex)\n}"
  },
  {
    "input": "func extractNumbersFromString(_ text: String) -> String {\n    return text.filter { $0.isNumber }\n}",
    "output": "/// Возвращает строку, которая является результатом склеивания всех чисел из строки.\n/// - Parameter text: Входная строка.\n/// - Returns: Строка, содержащая только числа из исходной строки.\nfunc extractNumbersFromString(_ text: String) -> String {\n    return text.filter { $0.isNumber }\n}"
  },
  {
    "input": "func stringToPercentage(_ text: String, precision: Int) -> String? {\n    guard let number = Double(text) else { return nil }\n    let percentage = number * 100\n    return String(format: \"%.\\(precision)f%%\", percentage)\n}",
    "output": "/// Преобразует строку с числовым значением в проценты.\n/// - Parameters:\n///   - text: Входная строка.\n///   - precision: Количество знаков после запятой.\n/// - Returns: Строка с процентным значением.\nfunc stringToPercentage(_ text: String, precision: Int) -> String? {\n    guard let number = Double(text) else { return nil }\n    let percentage = number * 100\n    return String(format: \"%.\\(precision)f%%\", percentage)\n}"
  },
  {
    "input": "func alternatingUpperAndLowerCase(_ text: String) -> String {\n    return String(text.enumerated().map { (index, char) in\n        index % 2 == 0 ? char.lowercased() : char.uppercased()\n    })\n}",
    "output": "/// Возвращает строку, где символы чередуются между верхним и нижним регистром.\n/// - Parameter text: Входная строка.\n/// - Returns: Строка с чередующимися буквами.\nfunc alternatingUpperAndLowerCase(_ text: String) -> String {\n    return String(text.enumerated().map { (index, char) in\n        index % 2 == 0 ? char.lowercased() : char.uppercased()\n    })\n}"
  },
  {
    "input": "func isNumeric(_ text: String) -> Bool {\n    return Double(text) != nil\n}",
    "output": "/// Проверяет, является ли строка числовым значением, включая десятичную точку.\n/// - Parameter text: Входная строка.\n/// - Returns: true, если строка является числом.\nfunc isNumeric(_ text: String) -> Bool {\n    return Double(text) != nil\n}"
  },
  {
    "input": "func uniqueWords(in text: String) -> [String] {\n    let words = text.lowercased().split { !$0.isLetter }\n    return Array(Set(words.map { String($0) }))\n}",
    "output": "/// Находит все уникальные слова в строке и возвращает их в массив.\n/// - Parameter text: Входная строка.\n/// - Returns: Массив уникальных слов.\nfunc uniqueWords(in text: String) -> [String] {\n    let words = text.lowercased().split { !$0.isLetter }\n    return Array(Set(words.map { String($0) }))\n}"
  },
  {
    "input": "func capitalizeWords(_ text: String) -> String {\n    return text.split(separator: \" \").map { $0.capitalized }.joined(separator: \" \")\n}",
    "output": "/// Возвращает строку, в которой каждое слово начинается с заглавной буквы.\n/// - Parameter text: Входная строка.\n/// - Returns: Строка с заглавными буквами в начале каждого слова.\nfunc capitalizeWords(_ text: String) -> String {\n    return text.split(separator: \" \").map { $0.capitalized }.joined(separator: \" \")\n}"
  },
  {
    "input": "func wordsStartingWithLetter(_ text: String, letter: Character) -> [String] {\n    return text.split(separator: \" \").filter { $0.first == letter }.map { String($0) }\n}",
    "output": "/// Преобразует строку в список слов, которые начинаются с заданной буквы.\n/// - Parameters:\n///   - text: Входная строка.\n///   - letter: Буква для фильтрации.\n/// - Returns: Массив слов, начинающихся с заданной буквы.\nfunc wordsStartingWithLetter(_ text: String, letter: Character) -> [String] {\n    return text.split(separator: \" \").filter { $0.first == letter }.map { String($0) }\n}"
  },
  {
    "input": "func isValidDate(_ text: String) -> Bool {\n    let formatter = DateFormatter()\n    formatter.dateFormat = \"yyyy-MM-dd\"\n    return formatter.date(from: text) != nil\n}",
    "output": "/// Проверяет, является ли строка в формате даты (например, \"yyyy-MM-dd\").\n/// - Parameter text: Входная строка.\n/// - Returns: true, если строка — дата в формате \"yyyy-MM-dd\".\nfunc isValidDate(_ text: String) -> Bool {\n    let formatter = DateFormatter()\n    formatter.dateFormat = \"yyyy-MM-dd\"\n    return formatter.date(from: text) != nil\n}"
  },
  {
    "input": "func stringToNumberArray(_ text: String) -> [Int]? {\n    return text.split(separator: \" \").compactMap { Int($0) }\n}",
    "output": "/// Преобразует строку с числами в массив чисел.\n/// - Parameter text: Входная строка.\n/// - Returns: Массив чисел.\nfunc stringToNumberArray(_ text: String) -> [Int]? {\n    return text.split(separator: \" \").compactMap { Int($0) }\n}"
  },
  {
    "input": "func firstAndLastCharacter(_ text: String) -> String {\n    guard text.count > 1 else { return text }\n    return String([text.first!, text.last!])\n}",
    "output": "/// Возвращает строку с первым и последним символом исходной строки.\n/// - Parameter text: Входная строка.\n/// - Returns: Строка с первым и последним символом.\nfunc firstAndLastCharacter(_ text: String) -> String {\n    guard text.count > 1 else { return text }\n    return String([text.first!, text.last!])\n}"
  },
  {
    "input": "func isDecimalNumber(_ text: String) -> Bool {\n    let decimalRegex = \"^[0-9]*\\\\.?[0-9]+$\"\n    return matchesRegex(text, pattern: decimalRegex)\n}",
    "output": "/// Проверяет, является ли строка числом в десятичной системе счисления.\n/// - Parameter text: Входная строка.\n/// - Returns: true, если строка представляет десятичное число.\nfunc isDecimalNumber(_ text: String) -> Bool {\n    let decimalRegex = \"^[0-9]*\\\\.?[0-9]+$\"\n    return matchesRegex(text, pattern: decimalRegex)\n}"
  },
  {
    "input": "func replaceNonDigitsWithUnderscores(_ text: String) -> String {\n    return text.map { $0.isNumber ? $0 : \"_\" }.joined()\n}",
    "output": "/// Возвращает строку, в которой символы, не являющиеся цифрами, заменены на подчеркивания.\n/// - Parameter text: Входная строка.\n/// - Returns: Строка с заменёнными символами.\nfunc replaceNonDigitsWithUnderscores(_ text: String) -> String {\n    return text.map { $0.isNumber ? $0 : \"_\" }.joined()\n}"
  },
  {
    "input": "func replaceDigitsWithAsterisks(_ text: String) -> String {\n    return text.map { $0.isNumber ? \"*\" : $0 }.joined()\n}",
    "output": "/// Возвращает строку, в которой все цифры заменены на звёздочки.\n/// - Parameter text: Входная строка.\n/// - Returns: Строка с заменёнными цифрами.\nfunc replaceDigitsWithAsterisks(_ text: String) -> String {\n    return text.map { $0.isNumber ? \"*\" : $0 }.joined()\n}"
  },
  {
    "input": "func stringToWordsWithPunctuation(_ text: String) -> [String] {\n    return text.split { $0.isWhitespace || $0.isPunctuation }\n        .map { String($0) }\n}",
    "output": "/// Преобразует строку в массив слов, разделённых пробелами и знаками препинания.\n/// - Parameter text: Входная строка.\n/// - Returns: Массив слов.\nfunc stringToWordsWithPunctuation(_ text: String) -> [String] {\n    return text.split { $0.isWhitespace || $0.isPunctuation }\n        .map { String($0) }\n}"
  },
  {
    "input": "func isAlphabeticString(_ text: String) -> Bool {\n    return text.allSatisfy { $0.isLetter }\n}",
    "output": "/// Проверяет, является ли строка строкой с алфавитными символами только.\n/// - Parameter text: Входная строка.\n/// - Returns: true, если строка состоит только из букв.\nfunc isAlphabeticString(_ text: String) -> Bool {\n    return text.allSatisfy { $0.isLetter }\n}"
  },
  {
    "input": "func removeDigits(from text: String) -> String {\n    return text.filter { !$0.isNumber }\n}",
    "output": "/// Возвращает строку с удалёнными все цифры из текста.\n/// - Parameter text: Входная строка.\n/// - Returns: Строка без цифр.\nfunc removeDigits(from text: String) -> String {\n    return text.filter { !$0.isNumber }\n}"
  },
  {
    "input": "func isValidNumber(_ text: String) -> Bool {\n    let numberRegex = \"^-?\\\\d*(\\\\.\\\\d+)?$\"\n    return matchesRegex(text, pattern: numberRegex)\n}",
    "output": "/// Проверяет, является ли строка числом, включая отрицательные числа и числа с плавающей точкой.\n/// - Parameter text: Входная строка.\n/// - Returns: true, если строка является числом.\nfunc isValidNumber(_ text: String) -> Bool {\n    let numberRegex = \"^-?\\\\d*(\\\\.\\\\d+)?$\"\n    return matchesRegex(text, pattern: numberRegex)\n}"
  },
  {
    "input": "func replaceNonAlphanumericWithDashes(_ text: String) -> String {\n    return text.map { $0.isLetter || $0.isNumber ? $0 : \"-\" }.joined()\n}",
    "output": "/// Возвращает строку, в которой все символы кроме букв и цифр заменены на дефисы.\n/// - Parameter text: Входная строка.\n/// - Returns: Строка с дефисами вместо символов.\nfunc replaceNonAlphanumericWithDashes(_ text: String) -> String {\n    return text.map { $0.isLetter || $0.isNumber ? $0 : \"-\" }.joined()\n}"
  },
  {
    "input": "func stringToDoubleArrayWithPrecision(_ text: String) -> [Double]? {\n    return text.split(separator: \" \").compactMap { Double($0).map { round($0 * 100) / 100 } }\n}",
    "output": "/// Преобразует строку с числами в массив чисел с точностью до двух знаков после запятой.\n/// - Parameter text: Входная строка.\n/// - Returns: Массив чисел с точностью до двух знаков.\nfunc stringToDoubleArrayWithPrecision(_ text: String) -> [Double]? {\n    return text.split(separator: \" \").compactMap { Double($0).map { round($0 * 100) / 100 } }\n}"
  },
  {
    "input": "func stringToUnicodeCodes(_ text: String) -> String {\n    return text.unicodeScalars.map { \"\\\\u{\\(String(format: \"%04X\", $0.value))}\" }.joined()\n}",
    "output": "/// Возвращает строку, в которой каждый символ преобразован в его Unicode код.\n/// - Parameter text: Входная строка.\n/// - Returns: Строка с Unicode кодами символов.\nfunc stringToUnicodeCodes(_ text: String) -> String {\n    return text.unicodeScalars.map { \"\\\\u{\\(String(format: \"%04X\", $0.value))}\" }.joined()\n}"
  },
  {
    "input": "func allStringsStartWithUppercase(_ array: [String]) -> Bool {\n    return array.allSatisfy { !$0.isEmpty && $0.first!.isUppercase }\n}",
    "output": "/// Проверяет, все ли строки в массиве начинаются с заглавной буквы.\n/// - Parameter array: Массив строк.\n/// - Returns: true, если все строки начинаются с заглавной буквы.\nfunc allStringsStartWithUppercase(_ array: [String]) -> Bool {\n    return array.allSatisfy { !$0.isEmpty && $0.first!.isUppercase }\n}"
  },
  {
    "input": "func removeExtraSpaces(_ text: String) -> String {\n    let components = text.split { $0.isWhitespace }\n    return components.joined(separator: \" \")\n}",
    "output": "/// Возвращает строку, в которой удалены все пробелы перед и после строки, а также все лишние пробелы между словами.\n/// - Parameter text: Входная строка.\n/// - Returns: Строка без лишних пробелов.\nfunc removeExtraSpaces(_ text: String) -> String {\n    let components = text.split { $0.isWhitespace }\n    return components.joined(separator: \" \")\n}"
  },
  {
    "input": "func capitalizeEvenIndexedLetters(_ text: String) -> String {\n    return String(text.enumerated().map { (index, char) in\n        index % 2 == 0 ? char.uppercased() : char.lowercased()\n    })\n}",
    "output": "/// Преобразует строку в строку, в которой все символы на чётных позициях заменены на заглавные буквы.\n/// - Parameter text: Входная строка.\n/// - Returns: Строка с чередующимися заглавными буквами.\nfunc capitalizeEvenIndexedLetters(_ text: String) -> String {\n    return String(text.enumerated().map { (index, char) in\n        index % 2 == 0 ? char.uppercased() : char.lowercased()\n    })\n}"
  },
  {
    "input": "func uniqueWordsIgnoringCase(_ text: String) -> String {\n    let words = text.lowercased().split { !$0.isLetter }\n    let uniqueWords = Set(words.map { String($0) })\n    return uniqueWords.joined(separator: \" \")\n}",
    "output": "/// Возвращает строку, содержащую все уникальные слова из строки, игнорируя регистр.\n/// - Parameter text: Входная строка.\n/// - Returns: Строка с уникальными словами.\nfunc uniqueWordsIgnoringCase(_ text: String) -> String {\n    let words = text.lowercased().split { !$0.isLetter }\n    let uniqueWords = Set(words.map { String($0) })\n    return uniqueWords.joined(separator: \" \")\n}"
  },
  {
    "input": "func isValidIPv4(_ text: String) -> Bool {\n    let components = text.split(separator: \".\")\n    guard components.count == 4 else { return false }\n    return components.allSatisfy {\n        guard let number = Int($0), (0...255).contains(number) else { return false }\n        return true\n    }\n}",
    "output": "/// Проверяет, является ли строка строкой с действительным IP-адресом (IPv4).\n/// - Parameter text: Входная строка.\n/// - Returns: true, если строка является действительным IPv4.\nfunc isValidIPv4(_ text: String) -> Bool {\n    let components = text.split(separator: \".\")\n    guard components.count == 4 else { return false }\n    return components.allSatisfy {\n        guard let number = Int($0), (0...255).contains(number) else { return false }\n        return true\n    }\n}"
  },
  {
    "input": "func replaceDigitsWithSquares(_ text: String) -> String {\n    return text.map { $0.isNumber ? String(Int(String($0))! * Int(String($0))!) : String($0) }.joined()\n}",
    "output": "/// Возвращает строку, в которой все цифры заменены на их квадратные значения.\n/// - Parameter text: Входная строка.\n/// - Returns: Строка с квадратами цифр.\nfunc replaceDigitsWithSquares(_ text: String) -> String {\n    return text.map { $0.isNumber ? String(Int(String($0))! * Int(String($0))!) : String($0) }.joined()\n}"
  },
  {
    "input": "func removeRepeatedCharacters(from text: String) -> String {\n    var seen = Set<Character>()\n    return text.filter { seen.insert($0).inserted }\n}",
    "output": "/// Преобразует строку в строку с удалёнными символами, которые встречаются более одного раза.\n/// - Parameter text: Входная строка.\n/// - Returns: Строка с уникальными символами.\nfunc removeRepeatedCharacters(from text: String) -> String {\n    var seen = Set<Character>()\n    return text.filter { seen.insert($0).inserted }\n}"
  },
  {
    "input": "func sumOfArray(_ array: [Int]) -> Int {\n    return array.reduce(0, +)\n}",
    "output": "/// Возвращает сумму всех элементов в массиве.\n/// - Parameter array: Массив чисел.\n/// - Returns: Сумма всех элементов массива.\nfunc sumOfArray(_ array: [Int]) -> Int {\n    return array.reduce(0, +)\n}"
  },
  {
    "input": "func maxOfArray(_ array: [Int]) -> Int? {\n    return array.max()\n}",
    "output": "/// Возвращает наибольшее значение в массиве.\n/// - Parameter array: Массив чисел.\n/// - Returns: Наибольшее значение или nil, если массив пуст.\nfunc maxOfArray(_ array: [Int]) -> Int? {\n    return array.max()\n}"
  },
  {
    "input": "func minOfArray(_ array: [Int]) -> Int? {\n    return array.min()\n}",
    "output": "/// Возвращает минимальное значение в массиве.\n/// - Parameter array: Массив чисел.\n/// - Returns: Минимальное значение или nil, если массив пуст.\nfunc minOfArray(_ array: [Int]) -> Int? {\n    return array.min()\n}"
  },
  {
    "input": "func multiplyArrayElements(_ array: [Int], by multiplier: Int) -> [Int] {\n    return array.map { $0 * multiplier }\n}",
    "output": "/// Возвращает новый массив с элементами, умноженными на заданное число.\n/// - Parameters:\n///   - array: Массив чисел.\n///   - multiplier: Число для умножения.\n/// - Returns: Новый массив с умноженными элементами.\nfunc multiplyArrayElements(_ array: [Int], by multiplier: Int) -> [Int] {\n    return array.map { $0 * multiplier }\n}"
  },
  {
    "input": "func removeDuplicates<T: Hashable>(_ array: [T]) -> [T] {\n    return Array(Set(array))\n}",
    "output": "/// Удаляет все дубликаты из массива.\n/// - Parameter array: Массив.\n/// - Returns: Массив без дубликатов.\nfunc removeDuplicates<T: Hashable>(_ array: [T]) -> [T] {\n    return Array(Set(array))\n}"
  },
  {
    "input": "func sortArrayDescending(_ array: [Int]) -> [Int] {\n    return array.sorted { $0 > $1 }\n}",
    "output": "/// Возвращает новый массив, отсортированный по убыванию.\n/// - Parameter array: Массив чисел.\n/// - Returns: Массив чисел, отсортированный по убыванию.\nfunc sortArrayDescending(_ array: [Int]) -> [Int] {\n    return array.sorted { $0 > $1 }\n}"
  },
  {
    "input": "func areArraysEqualUnordered<T: Hashable>(_ array1: [T], _ array2: [T]) -> Bool {\n    return Set(array1) == Set(array2)\n}",
    "output": "/// Проверяет, содержат ли два массива одинаковые элементы, независимо от порядка.\n/// - Parameters:\n///   - array1: Первый массив.\n///   - array2: Второй массив.\n/// - Returns: true, если массивы содержат одинаковые элементы.\nfunc areArraysEqualUnordered<T: Hashable>(_ array1: [T], _ array2: [T]) -> Bool {\n    return Set(array1) == Set(array2)\n}"
  },
  {
    "input": "func allPositiveElements(_ array: [Int]) -> Bool {\n    return array.allSatisfy { $0 > 0 }\n}",
    "output": "/// Проверяет, все ли элементы массива положительные.\n/// - Parameter array: Массив чисел.\n/// - Returns: true, если все элементы массива положительные.\nfunc allPositiveElements(_ array: [Int]) -> Bool {\n    return array.allSatisfy { $0 > 0 }\n}"
  },
  {
    "input": "func commonElements<T: Hashable>(_ array1: [T], _ array2: [T]) -> [T] {\n    return Array(Set(array1).intersection(Set(array2)))\n}",
    "output": "/// Возвращает массив чисел, которые встречаются в обоих массивах.\n/// - Parameters:\n///   - array1: Первый массив.\n///   - array2: Второй массив.\n/// - Returns: Массив общих элементов.\nfunc commonElements<T: Hashable>(_ array1: [T], _ array2: [T]) -> [T] {\n    return Array(Set(array1).intersection(Set(array2)))\n}"
  },
  {
    "input": "func chunkArray<T>(_ array: [T], size: Int) -> [[T]] {\n    var chunks: [[T]] = []\n    for i in stride(from: 0, to: array.count, by: size) {\n        let chunk = Array(array[i..<min(i + size, array.count)])\n        chunks.append(chunk)\n    }\n    return chunks\n}",
    "output": "/// Разбивает массив на несколько подмассивов заданного размера.\n/// - Parameters:\n///   - array: Исходный массив.\n///   - size: Размер подмассивов.\n/// - Returns: Массив подмассивов.\nfunc chunkArray<T>(_ array: [T], size: Int) -> [[T]] {\n    var chunks: [[T]] = []\n    for i in stride(from: 0, to: array.count, by: size) {\n        let chunk = Array(array[i..<min(i + size, array.count)])\n        chunks.append(chunk)\n    }\n    return chunks\n}"
  },
  {
    "input": "func stringArrayToIntArray(_ array: [String]) -> [Int]? {\n    return array.compactMap { Int($0) }\n}",
    "output": "/// Преобразует массив строк в массив чисел.\n/// - Parameter array: Массив строк, содержащих числа.\n/// - Returns: Массив чисел.\nfunc stringArrayToIntArray(_ array: [String]) -> [Int]? {\n    return array.compactMap { Int($0) }\n}"
  },
  {
    "input": "func indexOfElement<T: Equatable>(_ array: [T], element: T) -> Int? {\n    return array.firstIndex(of: element)\n}",
    "output": "/// Находит индекс первого появления элемента в массиве.\n/// - Parameters:\n///   - array: Массив.\n///   - element: Элемент для поиска.\n/// - Returns: Индекс первого вхождения элемента или nil, если элемент не найден.\nfunc indexOfElement<T: Equatable>(_ array: [T], element: T) -> Int? {\n    return array.firstIndex(of: element)\n}"
  },
  {
    "input": "func elementsLessThan<T: Comparable>(_ array: [T], value: T) -> [T] {\n    return array.filter { $0 < value }\n}",
    "output": "/// Возвращает элементы массива, которые меньше заданного значения.\n/// - Parameters:\n///   - array: Массив чисел.\n///   - value: Пороговое значение.\n/// - Returns: Массив элементов, которые меньше заданного значения.\nfunc elementsLessThan<T: Comparable>(_ array: [T], value: T) -> [T] {\n    return array.filter { $0 < value }\n}"
  },
  {
    "input": "func elementsGreaterThan<T: Comparable>(_ array: [T], value: T) -> [T] {\n    return array.filter { $0 > value }\n}",
    "output": "/// Возвращает массив, содержащий все элементы массива, которые больше заданного значения.\n/// - Parameters:\n///   - array: Массив чисел.\n///   - value: Пороговое значение.\n/// - Returns: Массив элементов, которые больше заданного значения.\nfunc elementsGreaterThan<T: Comparable>(_ array: [T], value: T) -> [T] {\n    return array.filter { $0 > value }\n}"
  },
  {
    "input": "func numberArrayToStringArray(_ array: [Double], precision: Int) -> [String] {\n    return array.map { String(format: \"%.\\(precision)f\", $0) }\n}",
    "output": "/// Переводит массив чисел в массив строк, округляя до заданного количества знаков после запятой.\n/// - Parameters:\n///   - array: Массив чисел.\n///   - precision: Количество знаков после запятой.\n/// - Returns: Массив строк с округленными числами.\nfunc numberArrayToStringArray(_ array: [Double], precision: Int) -> [String] {\n    return array.map { String(format: \"%.\\(precision)f\", $0) }\n}"
  },
  {
    "input": "func indicesOfElement<T: Equatable>(_ array: [T], element: T) -> [Int] {\n    return array.enumerated().compactMap { $1 == element ? $0 : nil }\n}",
    "output": "/// Возвращает массив с индексами всех элементов, равных заданному.\n/// - Parameters:\n///   - array: Массив.\n///   - element: Элемент для поиска.\n/// - Returns: Массив индексов.\nfunc indicesOfElement<T: Equatable>(_ array: [T], element: T) -> [Int] {\n    return array.enumerated().compactMap { $1 == element ? $0 : nil }\n}"
  },
  {
    "input": "func scaleArray(_ array: [Int], by factor: Int) -> [Int] {\n    return array.map { $0 * factor }\n}",
    "output": "/// Возвращает новый массив, который состоит из элементов исходного массива, умноженных на заданный коэффициент.\n/// - Parameters:\n///   - array: Массив чисел.\n///   - factor: Коэффициент умножения.\n/// - Returns: Массив с умноженными элементами.\nfunc scaleArray(_ array: [Int], by factor: Int) -> [Int] {\n    return array.map { $0 * factor }\n}"
  },
  {
    "input": "func isArraySortedAscending(_ array: [Int]) -> Bool {\n    return array == array.sorted()\n}",
    "output": "/// Проверяет, является ли массив отсортированным по возрастанию.\n/// - Parameter array: Массив чисел.\n/// - Returns: true, если массив отсортирован по возрастанию.\nfunc isArraySortedAscending(_ array: [Int]) -> Bool {\n    return array == array.sorted()\n}"
  },
  {
    "input": "func isArraySortedDescending(_ array: [Int]) -> Bool {\n    return array == array.sorted { $0 > $1 }\n}",
    "output": "/// Проверяет, является ли массив отсортированным по убыванию.\n/// - Parameter array: Массив чисел.\n/// - Returns: true, если массив отсортирован по убыванию.\nfunc isArraySortedDescending(_ array: [Int]) -> Bool {\n    return array == array.sorted { $0 > $1 }\n}"
  },
  {
    "input": "func lengthOfStringsArray(_ array: [String]) -> [Int] {\n    return array.map { $0.count }\n}",
    "output": "/// Преобразует массив строк в массив длины строк.\n/// - Parameter array: Массив строк.\n/// - Returns: Массив длин строк.\nfunc lengthOfStringsArray(_ array: [String]) -> [Int] {\n    return array.map { $0.count }\n}"
  },
  {
    "input": "func countUniqueElements<T: Hashable>(_ array: [T]) -> Int {\n    return Set(array).count\n}",
    "output": "/// Возвращает количество уникальных элементов в массиве.\n/// - Parameter array: Массив элементов.\n/// - Returns: Количество уникальных элементов.\nfunc countUniqueElements<T: Hashable>(_ array: [T]) -> Int {\n    return Set(array).count\n}"
  },
  {
    "input": "func evenNumbers(from array: [Int]) -> [Int] {\n    return array.filter { $0 % 2 == 0 }\n}",
    "output": "/// Возвращает массив, который состоит только из четных чисел из исходного массива.\n/// - Parameter array: Массив чисел.\n/// - Returns: Массив четных чисел.\nfunc evenNumbers(from array: [Int]) -> [Int] {\n    return array.filter { $0 % 2 == 0 }\n}"
  },
  {
    "input": "func oddNumbers(from array: [Int]) -> [Int] {\n    return array.filter { $0 % 2 != 0 }\n}",
    "output": "/// Возвращает массив, который состоит только из нечетных чисел из исходного массива.\n/// - Parameter array: Массив чисел.\n/// - Returns: Массив нечетных чисел.\nfunc oddNumbers(from array: [Int]) -> [Int] {\n    return array.filter { $0 % 2 != 0 }\n}"
  },
  {
    "input": "func productOfArray(_ array: [Int]) -> Int {\n    return array.reduce(1, *)\n}",
    "output": "/// Находит произведение всех элементов массива.\n/// - Parameter array: Массив чисел.\n/// - Returns: Произведение всех элементов массива.\nfunc productOfArray(_ array: [Int]) -> Int {\n    return array.reduce(1, *)\n}"
  },
  {
    "input": "func isMaxElement<T: Comparable>(_ array: [T], element: T) -> Bool {\n    return element == array.max()\n}",
    "output": "/// Проверяет, является ли элемент максимальным в массиве.\n/// - Parameters:\n///   - array: Массив чисел.\n///   - element: Элемент для проверки.\n/// - Returns: true, если элемент максимален в массиве.\nfunc isMaxElement<T: Comparable>(_ array: [T], element: T) -> Bool {\n    return element == array.max()\n}"
  },
  {
    "input": "func formatArrayAsCurrency(_ array: [Int]) -> [String] {\n    return array.map { \"$\\($0)\" }\n}",
    "output": "/// Преобразует массив чисел в массив строк в формате \"$number$\".\n/// - Parameter array: Массив чисел.\n/// - Returns: Массив строк в формате \"$number$\".\nfunc formatArrayAsCurrency(_ array: [Int]) -> [String] {\n    return array.map { \"$\\($0)\" }\n}"
  },
  {
    "input": "func elementsGreaterThanAverage(_ array: [Int]) -> [Int] {\n    let average = Double(array.reduce(0, +)) / Double(array.count)\n    return array.filter { Double($0) > average }\n}",
    "output": "/// Находит элементы массива, которые больше среднего значения.\n/// - Parameter array: Массив чисел.\n/// - Returns: Массив элементов, которые больше среднего.\nfunc elementsGreaterThanAverage(_ array: [Int]) -> [Int] {\n    let average = Double(array.reduce(0, +)) / Double(array.count)\n    return array.filter { Double($0) > average }\n}"
  },
  {
    "input": "func duplicateElements<T: Hashable>(_ array: [T]) -> [T] {\n    let counts = array.reduce(into: [:]) { $0[$1, default: 0] += 1 }\n    return counts.filter { $0.value > 1 }.map { $0.key }\n}",
    "output": "/// Создает новый массив, содержащий элементы, которые встречаются больше одного раза.\n/// - Parameter array: Массив.\n/// - Returns: Массив элементов, которые встречаются более одного раза.\nfunc duplicateElements<T: Hashable>(_ array: [T]) -> [T] {\n    let counts = array.reduce(into: [:]) { $0[$1, default: 0] += 1 }\n    return counts.filter { $0.value > 1 }.map { $0.key }\n}"
  },
  {
    "input": "func sumExcludingMax(_ array: [Int]) -> Int? {\n    guard let maxElement = array.max() else { return nil }\n    return array.filter { $0 != maxElement }.reduce(0, +)\n}",
    "output": "/// Суммирует все элементы в массиве, кроме максимального.\n/// - Parameter array: Массив чисел.\n/// - Returns: Сумма всех элементов, кроме максимального.\nfunc sumExcludingMax(_ array: [Int]) -> Int? {\n    guard let maxElement = array.max() else { return nil }\n    return array.filter { $0 != maxElement }.reduce(0, +)\n}"
  },
  {
    "input": "func isMinElement<T: Comparable>(_ array: [T], element: T) -> Bool {\n    return element == array.min()\n}",
    "output": "/// Проверяет, является ли элемент минимальным в массиве.\n/// - Parameters:\n///   - array: Массив чисел.\n///   - element: Элемент для проверки.\n/// - Returns: true, если элемент минимален в массиве.\nfunc isMinElement<T: Comparable>(_ array: [T], element: T) -> Bool {\n    return element == array.min()\n}"
  },
  {
    "input": "func reverseStringsInArray(_ array: [String]) -> [String] {\n    return array.map { String($0.reversed()) }\n}",
    "output": "/// Преобразует массив строк в массив их обратных значений.\n/// - Parameter array: Массив строк.\n/// - Returns: Массив строк с обратным порядком символов.\nfunc reverseStringsInArray(_ array: [String]) -> [String] {\n    return array.map { String($0.reversed()) }\n}"
  },
  {
    "input": "func indicesOfOccurrences<T: Equatable>(_ array: [T], element: T) -> [Int] {\n    return array.enumerated().compactMap { $1 == element ? $0 : nil }\n}",
    "output": "/// Возвращает массив всех индексов, на которых встречается заданный элемент.\n/// - Parameters:\n///   - array: Массив.\n///   - element: Элемент для поиска.\n/// - Returns: Массив индексов.\nfunc indicesOfOccurrences<T: Equatable>(_ array: [T], element: T) -> [Int] {\n    return array.enumerated().compactMap { $1 == element ? $0 : nil }\n}"
  },
  {
    "input": "func joinNumbersWithCommas(_ array: [Int]) -> String {\n    return array.map { String($0) }.joined(separator: \", \")\n}",
    "output": "/// Преобразует массив чисел в строку, где числа разделены запятой.\n/// - Parameter array: Массив чисел.\n/// - Returns: Строка с числами, разделёнными запятыми.\nfunc joinNumbersWithCommas(_ array: [Int]) -> String {\n    return array.map { String($0) }.joined(separator: \", \")\n}"
  },
  {
    "input": "func uniqueElementsInArray<T: Hashable>(_ array: [T]) -> [T] {\n    let counts = array.reduce(into: [:]) { $0[$1, default: 0] += 1 }\n    return counts.filter { $0.value == 1 }.map { $0.key }\n}",
    "output": "/// Возвращает массив всех элементов, которые встречаются в массиве только один раз.\n/// - Parameter array: Массив.\n/// - Returns: Массив элементов, которые встречаются один раз.\nfunc uniqueElementsInArray<T: Hashable>(_ array: [T]) -> [T] {\n    let counts = array.reduce(into: [:]) { $0[$1, default: 0] += 1 }\n    return counts.filter { $0.value == 1 }.map { $0.key }\n}"
  },
  {
    "input": "func sortAndRemoveDuplicates(_ array: [Int]) -> [Int] {\n    return Array(Set(array)).sorted()\n}",
    "output": "/// Сортирует массив чисел по возрастанию и возвращает только уникальные элементы.\n/// - Parameter array: Массив чисел.\n/// - Returns: Отсортированный массив уникальных элементов.\nfunc sortAndRemoveDuplicates(_ array: [Int]) -> [Int] {\n    return Array(Set(array)).sorted()\n}"
  },
  {
    "input": "func capitalizeStringsInArray(_ array: [String]) -> [String] {\n    return array.map { $0.capitalized }\n}",
    "output": "/// Преобразует массив строк в массив строк, где каждый элемент начинается с заглавной буквы.\n/// - Parameter array: Массив строк.\n/// - Returns: Массив строк с заглавной буквы.\nfunc capitalizeStringsInArray(_ array: [String]) -> [String] {\n    return array.map { $0.capitalized }\n}"
  },
  {
    "input": "func filterEvenNumbers(_ array: [Int]) -> [Int] {\n    return array.filter { $0 % 2 == 0 }\n}",
    "output": "/// Возвращает новый массив, состоящий только из чётных чисел из исходного массива.\n/// - Parameter array: Массив чисел.\n/// - Returns: Массив чётных чисел.\nfunc filterEvenNumbers(_ array: [Int]) -> [Int] {\n    return array.filter { $0 % 2 == 0 }\n}"
  },
  {
    "input": "func filterMultiples(of divisor: Int, in array: [Int]) -> [Int] {\n    return array.filter { $0 % divisor == 0 }\n}",
    "output": "/// Возвращает новый массив, состоящий только из чисел, кратных заданному числу.\n/// - Parameters:\n///   - array: Массив чисел.\n///   - divisor: Число для проверки кратности.\n/// - Returns: Массив чисел, кратных divisor.\nfunc filterMultiples(of divisor: Int, in array: [Int]) -> [Int] {\n    return array.filter { $0 % divisor == 0 }\n}"
  },
  {
    "input": "func medianOfArray(_ array: [Int]) -> Double? {\n    guard !array.isEmpty else { return nil }\n    let sorted = array.sorted()\n    if sorted.count % 2 == 0 {\n        return Double(sorted[sorted.count / 2 - 1] + sorted[sorted.count / 2]) / 2.0\n    } else {\n        return Double(sorted[sorted.count / 2])\n    }\n}",
    "output": "/// Находит медиану массива чисел.\n/// - Parameter array: Массив чисел.\n/// - Returns: Медиана массива.\nfunc medianOfArray(_ array: [Int]) -> Double? {\n    guard !array.isEmpty else { return nil }\n    let sorted = array.sorted()\n    if sorted.count % 2 == 0 {\n        return Double(sorted[sorted.count / 2 - 1] + sorted[sorted.count / 2]) / 2.0\n    } else {\n        return Double(sorted[sorted.count / 2])\n    }\n}"
  },
  {
    "input": "func multiplyByIndex(_ array: [Int]) -> [Int] {\n    return array.enumerated().map { $0.element * $0.offset }\n}",
    "output": "/// Возвращает новый массив, в котором каждый элемент умножен на индекс его положения в исходном массиве.\n/// - Parameter array: Массив чисел.\n/// - Returns: Новый массив, элементы которого умножены на их индексы.\nfunc multiplyByIndex(_ array: [Int]) -> [Int] {\n    return array.enumerated().map { $0.element * $0.offset }\n}"
  },
  {
    "input": "func containsNegative(_ array: [Int]) -> Bool {\n    return array.contains { $0 < 0 }\n}",
    "output": "/// Проверяет, есть ли в массиве хотя бы одно отрицательное число.\n/// - Parameter array: Массив чисел.\n/// - Returns: true, если есть хотя бы одно отрицательное число.\nfunc containsNegative(_ array: [Int]) -> Bool {\n    return array.contains { $0 < 0 }\n}"
  },
  {
    "input": "func sortAndDuplicate(_ array: [Int]) -> [Int] {\n    return array.sorted().flatMap { [$0, $0] }\n}",
    "output": "/// Возвращает новый массив, в котором элементы отсортированы по возрастанию и дублируются элементы.\n/// - Parameter array: Массив чисел.\n/// - Returns: Отсортированный массив с повторяющимися элементами.\nfunc sortAndDuplicate(_ array: [Int]) -> [Int] {\n    return array.sorted().flatMap { [$0, $0] }\n}"
  },
  {
    "input": "func filterStringsByLength(_ array: [String], minLength: Int) -> [String] {\n    return array.filter { $0.count > minLength }\n}",
    "output": "/// Преобразует массив строк в новый массив строк, длина которых больше заданного значения.\n/// - Parameters:\n///   - array: Массив строк.\n///   - minLength: Минимальная длина строк.\n/// - Returns: Массив строк, длина которых больше minLength.\nfunc filterStringsByLength(_ array: [String], minLength: Int) -> [String] {\n    return array.filter { $0.count > minLength }\n}"
  },
  {
    "input": "func factorial(of number: Int) -> Int {\n    guard number >= 0 else { return 0 }\n    return (1...number).reduce(1, *)\n}",
    "output": "/// Возвращает факториал заданного числа.\n/// - Parameter number: Число.\n/// - Returns: Факториал числа.\nfunc factorial(of number: Int) -> Int {\n    guard number >= 0 else { return 0 }\n    return (1...number).reduce(1, *)\n}"
  },
  {
    "input": "func sumOfDigits(of number: Int) -> Int {\n    return String(abs(number)).compactMap { $0.wholeNumberValue }.reduce(0, +)\n}",
    "output": "/// Возвращает сумму всех цифр числа.\n/// - Parameter number: Число.\n/// - Returns: Сумма всех цифр числа.\nfunc sumOfDigits(of number: Int) -> Int {\n    return String(abs(number)).compactMap { $0.wholeNumberValue }.reduce(0, +)\n}"
  },
  {
    "input": "func isPrime(_ number: Int) -> Bool {\n    guard number > 1 else { return false }\n    for i in 2..<Int(sqrt(Double(number))) + 1 {\n        if number % i == 0 { return false }\n    }\n    return true\n}",
    "output": "/// Проверяет, является ли число простым.\n/// - Parameter number: Число.\n/// - Returns: true, если число простое.\nfunc isPrime(_ number: Int) -> Bool {\n    guard number > 1 else { return false }\n    for i in 2..<Int(sqrt(Double(number))) + 1 {\n        if number % i == 0 { return false }\n    }\n    return true\n}"
  },
  {
    "input": "func gcd(_ a: Int, _ b: Int) -> Int {\n    var a = a\n    var b = b\n    while b != 0 {\n        let temp = b\n        b = a % b\n        a = temp\n    }\n    return a\n}",
    "output": "/// Возвращает наибольший общий делитель (НОД) двух чисел.\n/// - Parameters:\n///   - a: Первое число.\n///   - b: Второе число.\n/// - Returns: НОД.\nfunc gcd(_ a: Int, _ b: Int) -> Int {\n    var a = a\n    var b = b\n    while b != 0 {\n        let temp = b\n        b = a % b\n        a = temp\n    }\n    return a\n}"
  },
  {
    "input": "func lcm(_ a: Int, _ b: Int) -> Int {\n    return abs(a * b) / gcd(a, b)\n}",
    "output": "/// Возвращает наименьшее общее кратное (НОК) двух чисел.\n/// - Parameters:\n///   - a: Первое число.\n///   - b: Второе число.\n/// - Returns: НОК.\nfunc lcm(_ a: Int, _ b: Int) -> Int {\n    return abs(a * b) / gcd(a, b)\n}"
  },
  {
    "input": "func paddedNumber(_ number: Int, toLength length: Int) -> String {\n    return String(format: \"%0\\(length)d\", number)\n}",
    "output": "/// Преобразует число в строку с добавлением ведущих нулей до заданной длины.\n/// - Parameters:\n///   - number: Число.\n///   - length: Длина строки.\n/// - Returns: Строка с ведущими нулями.\nfunc paddedNumber(_ number: Int, toLength length: Int) -> String {\n    return String(format: \"%0\\(length)d\", number)\n}"
  },
  {
    "input": "func average(of array: [Int]) -> Double {\n    return array.isEmpty ? 0 : Double(array.reduce(0, +)) / Double(array.count)\n}",
    "output": "/// Возвращает среднее арифметическое элементов массива.\n/// - Parameter array: Массив чисел.\n/// - Returns: Среднее арифметическое.\nfunc average(of array: [Int]) -> Double {\n    return array.isEmpty ? 0 : Double(array.reduce(0, +)) / Double(array.count)\n}"
  },
  {
    "input": "func isEven(_ number: Int) -> Bool {\n    return number % 2 == 0\n}",
    "output": "/// Проверяет, является ли число чётным.\n/// - Parameter number: Число.\n/// - Returns: true, если число чётное.\nfunc isEven(_ number: Int) -> Bool {\n    return number % 2 == 0\n}"
  },
  {
    "input": "func isOdd(_ number: Int) -> Bool {\n    return number % 2 != 0\n}",
    "output": "/// Проверяет, является ли число нечётным.\n/// - Parameter number: Число.\n/// - Returns: true, если число нечётное.\nfunc isOdd(_ number: Int) -> Bool {\n    return number % 2 != 0\n}"
  },
  {
    "input": "func toPercentage(_ number: Double) -> String {\n    return String(format: \"%.2f%%\", number * 100)\n}",
    "output": "/// Преобразует число в строку с процентами.\n/// - Parameter number: Число.\n/// - Returns: Строка с процентами.\nfunc toPercentage(_ number: Double) -> String {\n    return String(format: \"%.2f%%\", number * 100)\n}"
  },
  {
    "input": "func squareRoot(of number: Double) -> Double {\n    return sqrt(number)\n}",
    "output": "/// Возвращает число, которое является квадратным корнем из заданного числа.\n/// - Parameter number: Число.\n/// - Returns: Квадратный корень числа.\nfunc squareRoot(of number: Double) -> Double {\n    return sqrt(number)\n}"
  },
  {
    "input": "func cubeRoot(of number: Double) -> Double {\n    return pow(number, 1.0 / 3.0)\n}",
    "output": "/// Возвращает число, которое является кубическим корнем из заданного числа.\n/// - Parameter number: Число.\n/// - Returns: Кубический корень числа.\nfunc cubeRoot(of number: Double) -> Double {\n    return pow(number, 1.0 / 3.0)\n}"
  },
  {
    "input": "func isPowerOfTwo(_ number: Int) -> Bool {\n    return number > 0 && (number & (number - 1)) == 0\n}",
    "output": "/// Проверяет, является ли число степенью двойки.\n/// - Parameter number: Число.\n/// - Returns: true, если число является степенью двойки.\nfunc isPowerOfTwo(_ number: Int) -> Bool {\n    return number > 0 && (number & (number - 1)) == 0\n}"
  },
  {
    "input": "func absoluteValue(of number: Int) -> Int {\n    return abs(number)\n}",
    "output": "/// Возвращает абсолютное значение числа.\n/// - Parameter number: Число.\n/// - Returns: Абсолютное значение числа.\nfunc absoluteValue(of number: Int) -> Int {\n    return abs(number)\n}"
  },
  {
    "input": "func hasUniqueDigits(year: Int) -> Bool {\n    let digits = Set(String(year))\n    return digits.count == 4\n}",
    "output": "/// Проверяет, является ли год годом с повторяющимися цифрами\n/// - Parameter year: Год (4-значное число)\n/// - Returns: true, если все цифры года уникальны\nfunc hasUniqueDigits(year: Int) -> Bool {\n    let digits = Set(String(year))\n    return digits.count == 4\n}"
  },
  {
    "input": "func squareDifference(a: Int, b: Int) -> Int {\n    return (a + b) * (a + b) - (a * a + b * b)\n}",
    "output": "/// Вычисляет разницу между квадратом суммы и суммой квадратов двух чисел\n/// - Parameters:\n///   - a: Первое число\n///   - b: Второе число\n/// - Returns: (a + b)² - (a² + b²)\nfunc squareDifference(a: Int, b: Int) -> Int {\n    return (a + b) * (a + b) - (a * a + b * b)\n}"
  },
  {
    "input": "func allCharactersUnique(_ str: String) -> Bool {\n    return str.count == Set(str).count\n}",
    "output": "/// Проверяет, содержит ли строка только уникальные символы\n/// - Parameter str: Входная строка\n/// - Returns: true, если все символы уникальны\nfunc allCharactersUnique(_ str: String) -> Bool {\n    return str.count == Set(str).count\n}"
  },
  {
    "input": "func metersToKilometers(_ meters: Double) -> Double {\n    return meters / 1000\n}",
    "output": "/// Конвертирует метры в километры\n/// - Parameter meters: Значение в метрах\n/// - Returns: Значение в километрах\nfunc metersToKilometers(_ meters: Double) -> Double {\n    return meters / 1000\n}"
  },
  {
    "input": "func geometricMean(a: Double, b: Double) -> Double {\n    return sqrt(a * b)\n}",
    "output": "/// Находит среднее геометрическое двух чисел\n/// - Parameters:\n///   - a: Первое число\n///   - b: Второе число\n/// - Returns: √(a * b)\nfunc geometricMean(a: Double, b: Double) -> Double {\n    return sqrt(a * b)\n}"
  },
  {
    "input": "func isPerfectSquare(_ number: Int) -> Bool {\n    let sqrtNum = Int(Double(number).squareRoot())\n    return sqrtNum * sqrtNum == number\n}",
    "output": "/// Проверяет, является ли число совершенным квадратом\n/// - Parameter number: Проверяемое число\n/// - Returns: true, если число - полный квадрат\nfunc isPerfectSquare(_ number: Int) -> Bool {\n    let sqrtNum = Int(Double(number).squareRoot())\n    return sqrtNum * sqrtNum == number\n}"
  },
  {
    "input": "func fahrenheitToCelsius(_ fahrenheit: Double) -> Double {\n    return (fahrenheit - 32) * 5/9\n}",
    "output": "/// Переводит температуру из Фаренгейтов в Цельсии\n/// - Parameter fahrenheit: Температура в °F\n/// - Returns: Температура в °C\nfunc fahrenheitToCelsius(_ fahrenheit: Double) -> Double {\n    return (fahrenheit - 32) * 5/9\n}"
  },
  {
    "input": "func countConsonants(text: String) -> Int {\n    let vowels: Set<Character> = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    return text.lowercased().filter { $0.isLetter && !vowels.contains($0) }.count\n}",
    "output": "/// Считает количество согласных букв в строке\n/// - Parameter text: Входная строка\n/// - Returns: Количество согласных\nfunc countConsonants(text: String) -> Int {\n    let vowels: Set<Character> = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    return text.lowercased().filter { $0.isLetter && !vowels.contains($0) }.count\n}"
  },
  {
    "input": "func isSymmetricArray<T: Equatable>(_ array: [T]) -> Bool {\n    for i in 0..<array.count/2 {\n        if array[i] != array[array.count - 1 - i] {\n            return false\n        }\n    }\n    return true\n}",
    "output": "/// Проверяет, является ли массив симметричным относительно центра\n/// - Parameter array: Входной массив\n/// - Returns: true, если массив симметричен\nfunc isSymmetricArray<T: Equatable>(_ array: [T]) -> Bool {\n    for i in 0..<array.count/2 {\n        if array[i] != array[array.count - 1 - i] {\n            return false\n        }\n    }\n    return true\n}"
  },
  {
    "input": "func calculatePercentage(value: Double, percent: Double) -> Double {\n    return value * percent / 100\n}",
    "output": "/// Вычисляет процент от числа\n/// - Parameters:\n///   - value: Исходное число\n///   - percent: Процент (0-100)\n/// - Returns: Результат вычисления\nfunc calculatePercentage(value: Double, percent: Double) -> Double {\n    return value * percent / 100\n}"
  },
  {
    "input": "func endsWith(str: String, suffix: String) -> Bool {\n    return str.hasSuffix(suffix)\n}",
    "output": "/// Проверяет, заканчивается ли строка указанным суффиксом\n/// - Parameters:\n///   - str: Основная строка\n///   - suffix: Проверяемый суффикс\n/// - Returns: true, если строка заканчивается суффиксом\nfunc endsWith(str: String, suffix: String) -> Bool {\n    return str.hasSuffix(suffix)\n}"
  },
  {
    "input": "func timeToMinutes(hours: Int, minutes: Int) -> Int {\n    return hours * 60 + minutes\n}",
    "output": "/// Конвертирует часы и минуты в общее количество минут\n/// - Parameters:\n///   - hours: Часы\n///   - minutes: Минуты\n/// - Returns: Общее количество минут\nfunc timeToMinutes(hours: Int, minutes: Int) -> Int {\n    return hours * 60 + minutes\n}"
  },
  {
    "input": "func minOfThree(a: Int, b: Int, c: Int) -> Int {\n    return min(a, min(b, c))\n}",
    "output": "/// Находит минимальное из трех чисел\n/// - Parameters:\n///   - a: Первое число\n///   - b: Второе число\n///   - c: Третье число\n/// - Returns: Наименьшее число\nfunc minOfThree(a: Int, b: Int, c: Int) -> Int {\n    return min(a, min(b, c))\n}"
  },
  {
    "input": "func hasDuplicates<T: Hashable>(_ array: [T]) -> Bool {\n    return array.count != Set(array).count\n}",
    "output": "/// Проверяет, содержит ли массив дубликаты\n/// - Parameter array: Входной массив\n/// - Returns: true, если есть повторяющиеся элементы\nfunc hasDuplicates<T: Hashable>(_ array: [T]) -> Bool {\n    return array.count != Set(array).count\n}"
  },
  {
    "input": "func cubeSurfaceArea(side: Double) -> Double {\n    return 6 * side * side\n}",
    "output": "/// Вычисляет площадь поверхности куба\n/// - Parameter side: Длина ребра куба\n/// - Returns: Площадь поверхности\nfunc cubeSurfaceArea(side: Double) -> Double {\n    return 6 * side * side\n}"
  },
  {
    "input": "func isPowerOfFour(_ n: Int) -> Bool {\n    guard n > 0 else { return false }\n    var num = n\n    while num % 4 == 0 { num /= 4 }\n    return num == 1\n}",
    "output": "/// Проверяет, является ли число степенью четверки\n/// - Parameter n: Проверяемое число\n/// - Returns: true, если число - степень 4\nfunc isPowerOfFour(_ n: Int) -> Bool {\n    guard n > 0 else { return false }\n    var num = n\n    while num % 4 == 0 { num /= 4 }\n    return num == 1\n}"
  },
  {
    "input": "func romanToIntSimple(_ roman: String) -> Int {\n    let values: [Character: Int] = [\"I\":1, \"V\":5, \"X\":10]\n    return roman.reversed().reduce(0) { $0 + (values[$1] ?? 0) }\n}",
    "output": "/// Конвертирует римские цифры в целое число (упрощенная версия)\n/// - Parameter roman: Римское число (I-X)\n/// - Returns: Соответствующее целое число\nfunc romanToIntSimple(_ roman: String) -> Int {\n    let values: [Character: Int] = [\"I\":1, \"V\":5, \"X\":10]\n    return roman.reversed().reduce(0) { $0 + (values[$1] ?? 0) }\n}"
  },
  {
    "input": "func sumOfDigits(number: Int) -> Int {\n    return String(number).compactMap { Int(String($0)) }.reduce(0, +)\n}",
    "output": "/// Вычисляет сумму цифр в числе\n/// - Parameter number: Исходное число\n/// - Returns: Сумма цифр\nfunc sumOfDigits(number: Int) -> Int {\n    return String(number).compactMap { Int(String($0)) }.reduce(0, +)\n}"
  },
  {
    "input": "func isPalindromeIgnoringSpaces(_ str: String) -> Bool {\n    let cleaned = str.replacingOccurrences(of: \" \", with: \"\").lowercased()\n    return cleaned == String(cleaned.reversed())\n}",
    "output": "/// Проверяет, является ли строка палиндромом игнорируя пробелы\n/// - Parameter str: Входная строка\n/// - Returns: true, если строка - палиндром\nfunc isPalindromeIgnoringSpaces(_ str: String) -> Bool {\n    let cleaned = str.replacingOccurrences(of: \" \", with: \"\").lowercased()\n    return cleaned == String(cleaned.reversed())\n}"
  },
  {
    "input": "func sphereVolume(radius: Double) -> Double {\n    return (4/3) * .pi * pow(radius, 3)\n}",
    "output": "/// Вычисляет объем шара\n/// - Parameter radius: Радиус шара\n/// - Returns: Объем\nfunc sphereVolume(radius: Double) -> Double {\n    return (4/3) * .pi * pow(radius, 3)\n}"
  },
  {
    "input": "func isDecimalNumber(_ str: String) -> Bool {\n    return Double(str) != nil\n}",
    "output": "/// Проверяет, является ли строка числом в десятичной системе.\n/// - Parameter str: Входная строка.\n/// - Returns: `true`, если строка может быть преобразована в число.\nfunc isDecimalNumber(_ str: String) -> Bool {\n    return Double(str) != nil\n}"
  },
  {
    "input": "func sumDigits(of number: Int) -> Int {\n    return String(abs(number)).compactMap { $0.wholeNumberValue }.reduce(0, +)\n}",
    "output": "/// Вычисляет сумму цифр в числе.\n/// - Parameter number: Входное число.\n/// - Returns: Сумма цифр.\nfunc sumDigits(of number: Int) -> Int {\n    return String(abs(number)).compactMap { $0.wholeNumberValue }.reduce(0, +)\n}"
  },
  {
    "input": "func toUpperCase(_ str: String) -> String {\n    return str.uppercased()\n}",
    "output": "/// Конвертирует строку в заглавные буквы.\n/// - Parameter str: Входная строка.\n/// - Returns: Строка, где все буквы заглавные.\nfunc toUpperCase(_ str: String) -> String {\n    return str.uppercased()\n}"
  },
  {
    "input": "func toLowerCase(_ str: String) -> String {\n    return str.lowercased()\n}",
    "output": "/// Переводит строку в нижний регистр.\n/// - Parameter str: Входная строка.\n/// - Returns: Строка, где все буквы в нижнем регистре.\nfunc toLowerCase(_ str: String) -> String {\n    return str.lowercased()\n}"
  },
  {
    "input": "func daysBetween(startDate: Date, endDate: Date) -> Int {\n    return Calendar.current.dateComponents([.day], from: startDate, to: endDate).day ?? 0\n}",
    "output": "/// Вычисляет общее количество дней между двумя датами.\n/// - Parameters:\n///   - startDate: Начальная дата.\n///   - endDate: Конечная дата.\n/// - Returns: Количество дней.\nfunc daysBetween(startDate: Date, endDate: Date) -> Int {\n    return Calendar.current.dateComponents([.day], from: startDate, to: endDate).day ?? 0\n}"
  },
  {
    "input": "func multiplyArray(_ array: [Int], by multiplier: Int) -> [Int] {\n    return array.map { $0 * multiplier }\n}",
    "output": "/// Умножает все элементы массива на число.\n/// - Parameters:\n///   - array: Массив чисел.\n///   - multiplier: Число для умножения.\n/// - Returns: Массив умноженных чисел.\nfunc multiplyArray(_ array: [Int], by multiplier: Int) -> [Int] {\n    return array.map { $0 * multiplier }\n}"
  },
  {
    "input": "func isEmptyOrWhitespace(_ str: String) -> Bool {\n    return str.trimmingCharacters(in: .whitespaces).isEmpty\n}",
    "output": "/// Проверяет, является ли строка пустой или содержит только пробелы.\n/// - Parameter str: Входная строка.\n/// - Returns: `true`, если строка пуста или состоит только из пробелов.\nfunc isEmptyOrWhitespace(_ str: String) -> Bool {\n    return str.trimmingCharacters(in: .whitespaces).isEmpty\n}"
  },
  {
    "input": "func secondsToHoursMinutes(_ seconds: Int) -> (hours: Int, minutes: Int) {\n    return (seconds / 3600, (seconds % 3600) / 60)\n}",
    "output": "/// Конвертирует секунды в часы и минуты.\n/// - Parameter seconds: Общее количество секунд.\n/// - Returns: Кортеж (часы, минуты).\nfunc secondsToHoursMinutes(_ seconds: Int) -> (hours: Int, minutes: Int) {\n    return (seconds / 3600, (seconds % 3600) / 60)\n}"
  },
  {
    "input": "func findMinValue(_ array: [Int]) -> Int? {\n    return array.min()\n}",
    "output": "/// Ищет минимальное число в массиве.\n/// - Parameter array: Массив чисел.\n/// - Returns: Минимальное число.\nfunc findMinValue(_ array: [Int]) -> Int? {\n    return array.min()\n}"
  },
  {
    "input": "func divideWithRemainder(dividend: Int, divisor: Int) -> (quotient: Int, remainder: Int) {\n    return (dividend / divisor, dividend % divisor)\n}",
    "output": "/// Проводит операцию деления с остатком.\n/// - Parameters:\n///   - dividend: Делимое.\n///   - divisor: Делитель.\n/// - Returns: Кортеж (частное, остаток).\nfunc divideWithRemainder(dividend: Int, divisor: Int) -> (quotient: Int, remainder: Int) {\n    return (dividend / divisor, dividend % divisor)\n}"
  },
  {
    "input": "func isPalindromeIgnoringSpaces(_ str: String) -> Bool {\n    let cleaned = str.lowercased().filter { $0.isLetter }\n    return cleaned == String(cleaned.reversed())\n}",
    "output": "/// Проверяет, является ли строка палиндромом без учета регистра и пробелов.\n/// - Parameter str: Входная строка.\n/// - Returns: `true`, если строка палиндром.\nfunc isPalindromeIgnoringSpaces(_ str: String) -> Bool {\n    let cleaned = str.lowercased().filter { $0.isLetter }\n    return cleaned == String(cleaned.reversed())\n}"
  },
  {
    "input": "func stringToWords(_ str: String) -> [String] {\n    return str.split(whereSeparator: { $0.isWhitespace }).map { String($0) }\n}",
    "output": "/// Преобразует строку в массив слов.\n/// - Parameter str: Входная строка.\n/// - Returns: Массив слов.\nfunc stringToWords(_ str: String) -> [String] {\n    return str.split(whereSeparator: { $0.isWhitespace }).map { String($0) }\n}"
  },
  {
    "input": "func sortStringsByLength(_ strings: [String]) -> [String] {\n    return strings.sorted { $0.count < $1.count }\n}",
    "output": "/// Сортирует массив строк по длине.\n/// - Parameter strings: Массив строк.\n/// - Returns: Отсортированный по длине массив.\nfunc sortStringsByLength(_ strings: [String]) -> [String] {\n    return strings.sorted { $0.count < $1.count }\n}"
  },
  {
    "input": "func containsSubstring(_ str: String, _ substring: String) -> Bool {\n    return str.contains(substring)\n}",
    "output": "/// Проверяет, содержится ли подстрока в строке.\n/// - Parameters:\n///   - str: Строка.\n///   - substring: Подстрока.\n/// - Returns: `true`, если подстрока содержится в строке.\nfunc containsSubstring(_ str: String, _ substring: String) -> Bool {\n    return str.contains(substring)\n}"
  },
  {
    "input": "func randomElement<T>(_ array: [T]) -> T? {\n    return array.randomElement()\n}",
    "output": "/// Генерирует случайный элемент из массива.\n/// - Parameter array: Массив элементов.\n/// - Returns: Случайный элемент из массива.\nfunc randomElement<T>(_ array: [T]) -> T? {\n    return array.randomElement()\n}"
  },
  {
    "input": "func average(of numbers: [Double]) -> Double {\n    return numbers.reduce(0, +) / Double(numbers.count)\n}",
    "output": "/// Вычисляет среднее значение в массиве.\n/// - Parameter numbers: Массив чисел.\n/// - Returns: Среднее значение.\nfunc average(of numbers: [Double]) -> Double {\n    return numbers.reduce(0, +) / Double(numbers.count)\n}"
  },
  {
    "input": "func concatenateStrings(_ strings: [String]) -> String {\n    return strings.joined()\n}",
    "output": "/// Объединяет несколько строк в одну.\n/// - Parameter strings: Массив строк.\n/// - Returns: Объединенная строка.\nfunc concatenateStrings(_ strings: [String]) -> String {\n    return strings.joined()\n}"
  },
  {
    "input": "func isFloatNumber(_ str: String) -> Bool {\n    return Float(str) != nil\n}",
    "output": "/// Проверяет, является ли строка числовым значением с плавающей точкой.\n/// - Parameter str: Входная строка.\n/// - Returns: `true`, если строка представляет собой число с плавающей точкой.\nfunc isFloatNumber(_ str: String) -> Bool {\n    return Float(str) != nil\n}"
  },
  {
    "input": "func stringToCharacters(_ str: String) -> [Character] {\n    return Array(str)\n}",
    "output": "/// Преобразует строку в массив символов.\n/// - Parameter str: Входная строка.\n/// - Returns: Массив символов.\nfunc stringToCharacters(_ str: String) -> [Character] {\n    return Array(str)\n}"
  },
  {
    "input": "func increment(_ number: Int) -> Int {\n    return number + 1\n}",
    "output": "/// Возвращает число, увеличенное на 1.\n/// - Parameter number: Входное число.\n/// - Returns: Число, увеличенное на 1.\nfunc increment(_ number: Int) -> Int {\n    return number + 1\n}"
  },
  {
    "input": "func stringToIntegers(_ str: String) -> [Int] {\n    return str.compactMap { Int(String($0)) }\n}",
    "output": "/// Конвертирует строку в массив целых чисел.\n/// - Parameter str: Входная строка.\n/// - Returns: Массив целых чисел, извлечённых из строки.\nfunc stringToIntegers(_ str: String) -> [Int] {\n    return str.compactMap { Int(String($0)) }\n}"
  },
  {
    "input": "func isValidURL(_ url: String) -> Bool {\n    return URL(string: url) != nil\n}",
    "output": "/// Проверяет, является ли строка валидным URL.\n/// - Parameter url: Входная строка.\n/// - Returns: `true`, если строка является валидным URL.\nfunc isValidURL(_ url: String) -> Bool {\n    return URL(string: url) != nil\n}"
  },
  {
    "input": "func multiplyArrayElements(_ numbers: [Int]) -> Int {\n    return numbers.reduce(1, *)\n}",
    "output": "/// Вычисляет произведение всех чисел в массиве.\n/// - Parameter numbers: Массив чисел.\n/// - Returns: Произведение всех чисел в массиве.\nfunc multiplyArrayElements(_ numbers: [Int]) -> Int {\n    return numbers.reduce(1, *)\n}"
  },
  {
    "input": "func randomUniqueElements<T>(_ array: [T]) -> [T] {\n    return Array(Set(array)).shuffled()\n}",
    "output": "/// Генерирует случайный элемент из массива, исключая дубликаты.\n/// - Parameter array: Массив элементов.\n/// - Returns: Массив с уникальными случайными элементами.\nfunc randomUniqueElements<T>(_ array: [T]) -> [T] {\n    return Array(Set(array)).shuffled()\n}"
  },
  {
    "input": "func isEvenNumber(_ number: Int) -> Bool {\n    return number % 2 == 0\n}",
    "output": "/// Проверяет, является ли число четным.\n/// - Parameter number: Входное число.\n/// - Returns: `true`, если число чётное.\nfunc isEvenNumber(_ number: Int) -> Bool {\n    return number % 2 == 0\n}"
  },
  {
    "input": "func gcdOfArray(_ numbers: [Int]) -> Int {\n    return numbers.reduce(numbers[0]) { gcd($0, $1) }\n}",
    "output": "/// Вычисляет наибольший общий делитель (НОД) для массива чисел.\n/// - Parameter numbers: Массив чисел.\n/// - Returns: НОД для всех чисел массива.\nfunc gcdOfArray(_ numbers: [Int]) -> Int {\n    return numbers.reduce(numbers[0]) { gcd($0, $1) }\n}"
  },
  {
    "input": "func isNumericString(_ str: String) -> Bool {\n    return str.allSatisfy { $0.isNumber }\n}",
    "output": "/// Проверяет, является ли строка цифровой.\n/// - Parameter str: Входная строка.\n/// - Returns: `true`, если строка содержит только цифры.\nfunc isNumericString(_ str: String) -> Bool {\n    return str.allSatisfy { $0.isNumber }\n}"
  },
  {
    "input": "func stringToDouble(_ str: String) -> Double? {\n    return Double(str)\n}",
    "output": "/// Преобразует строку в числовое значение с плавающей точкой.\n/// - Parameter str: Входная строка.\n/// - Returns: Числовое значение с плавающей точкой.\nfunc stringToDouble(_ str: String) -> Double? {\n    return Double(str)\n}"
  },
  {
    "input": "func roundToNearestInteger(_ number: Double) -> Int {\n    return Int(round(number))\n}",
    "output": "/// Выполняет округление числа до ближайшего целого.\n/// - Parameter number: Входное число.\n/// - Returns: Округленное число.\nfunc roundToNearestInteger(_ number: Double) -> Int {\n    return Int(round(number))\n}"
  },
  {
    "input": "func isValidEmailAddress(_ email: String) -> Bool {\n    let pattern = \"[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\\\.[A-Za-z]{2,64}\"\n    return email.range(of: pattern, options: .regularExpression) != nil\n}",
    "output": "/// Проверяет, является ли строка валидным адресом электронной почты.\n/// - Parameter email: Входная строка.\n/// - Returns: `true`, если строка является валидным email.\nfunc isValidEmailAddress(_ email: String) -> Bool {\n    let pattern = \"[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\\\.[A-Za-z]{2,64}\"\n    return email.range(of: pattern, options: .regularExpression) != nil\n}"
  },
  {
    "input": "func isHexadecimal(_ str: String) -> Bool {\n    return Int(str, radix: 16) != nil\n}",
    "output": "/// Проверяет, является ли строка числом в шестнадцатеричной системе.\n/// - Parameter str: Входная строка.\n/// - Returns: `true`, если строка является шестнадцатеричным числом.\nfunc isHexadecimal(_ str: String) -> Bool {\n    return Int(str, radix: 16) != nil\n}"
  },
  {
    "input": "func stringToBytes(_ str: String) -> [UInt8] {\n    return Array(str.utf8)\n}",
    "output": "/// Конвертирует строку в массив байтов (массив целых чисел).\n/// - Parameter str: Входная строка.\n/// - Returns: Массив байтов.\nfunc stringToBytes(_ str: String) -> [UInt8] {\n    return Array(str.utf8)\n}"
  },
  {
    "input": "func toSnakeCase(_ str: String) -> String {\n    return str.lowercased().replacingOccurrences(of: \" \", with: \"_\")\n}",
    "output": "/// Преобразует строку в формат \"собака_запятая\" (snake_case).\n/// - Parameter str: Входная строка.\n/// - Returns: Строка в snake_case.\nfunc toSnakeCase(_ str: String) -> String {\n    return str.lowercased().replacingOccurrences(of: \" \", with: \"_\")\n}"
  },
  {
    "input": "func toBinaryString(_ number: Int) -> String {\n    return String(number, radix: 2)\n}",
    "output": "/// Конвертирует число в строку в двоичном представлении.\n/// - Parameter number: Входное число.\n/// - Returns: Строка в двоичном формате.\nfunc toBinaryString(_ number: Int) -> String {\n    return String(number, radix: 2)\n}"
  },
  {
    "input": "func stringToFloatArray(_ str: String) -> [Float] {\n    return str.split(separator: \",\").compactMap { Float($0.trimmingCharacters(in: .whitespaces)) }\n}",
    "output": "/// Преобразует строку в массив чисел с плавающей точкой.\n/// - Parameter str: Входная строка.\n/// - Returns: Массив чисел с плавающей точкой.\nfunc stringToFloatArray(_ str: String) -> [Float] {\n    return str.split(separator: \",\").compactMap { Float($0.trimmingCharacters(in: .whitespaces)) }\n}"
  },
  {
    "input": "func reverseString(_ str: String) -> String {\n    return String(str.reversed())\n}",
    "output": "/// Возвращает строку, в которой все символы перевёрнуты.\n/// - Parameter str: Входная строка.\n/// - Returns: Строка с перевёрнутыми символами.\nfunc reverseString(_ str: String) -> String {\n    return String(str.reversed())\n}"
  },
  {
    "input": "func bitwiseAnd(_ a: Int, _ b: Int) -> Int {\n    return a & b\n}",
    "output": "/// Выполняет побитовую операцию И для двух целых чисел.\n/// - Parameters:\n///   - a: Первое число.\n///   - b: Второе число.\n/// - Returns: Результат побитовой операции И.\nfunc bitwiseAnd(_ a: Int, _ b: Int) -> Int {\n    return a & b\n}"
  },
  {
    "input": "func splitStringIntoSubstrings(_ str: String, length: Int) -> [String] {\n    return stride(from: 0, to: str.count, by: length).map {\n        let startIndex = str.index(str.startIndex, offsetBy: $0)\n        let endIndex = str.index(startIndex, offsetBy: length, limitedBy: str.endIndex) ?? str.endIndex\n        return String(str[startIndex..<endIndex])\n    }\n}",
    "output": "/// Преобразует строку в массив подстрок с заданной длиной.\n/// - Parameters:\n///   - str: Входная строка.\n///   - length: Длина подстрок.\n/// - Returns: Массив подстрок.\nfunc splitStringIntoSubstrings(_ str: String, length: Int) -> [String] {\n    return stride(from: 0, to: str.count, by: length).map {\n        let startIndex = str.index(str.startIndex, offsetBy: $0)\n        let endIndex = str.index(startIndex, offsetBy: length, limitedBy: str.endIndex) ?? str.endIndex\n        return String(str[startIndex..<endIndex])\n    }\n}"
  },
  {
    "input": "func multiplyArrayByNumber(_ array: [Double], multiplier: Double) -> [Double] {\n    return array.map { $0 * multiplier }\n}",
    "output": "/// Умножает все элементы массива на указанное число.\n/// - Parameters:\n///   - array: Массив чисел.\n///   - multiplier: Число для умножения.\n/// - Returns: Массив чисел после умножения.\nfunc multiplyArrayByNumber(_ array: [Double], multiplier: Double) -> [Double] {\n    return array.map { $0 * multiplier }\n}"
  },
  {
    "input": "func repeatCharacter(_ char: Character, count: Int) -> String {\n    return String(repeating: char, count: count)\n}",
    "output": "/// Генерирует строку с повторяющимися символами.\n/// - Parameters:\n///   - char: Символ для повторения.\n///   - count: Количество повторений.\n/// - Returns: Строка с повторяющимися символами.\nfunc repeatCharacter(_ char: Character, count: Int) -> String {\n    return String(repeating: char, count: count)\n}"
  },
  {
    "input": "func isWhitespaceOnly(_ str: String) -> Bool {\n    return str.trimmingCharacters(in: .whitespaces).isEmpty\n}",
    "output": "/// Проверяет, является ли строка пустой или состоит только из пробелов.\n/// - Parameter str: Входная строка.\n/// - Returns: `true`, если строка пуста или состоит только из пробелов.\nfunc isWhitespaceOnly(_ str: String) -> Bool {\n    return str.trimmingCharacters(in: .whitespaces).isEmpty\n}"
  },
  {
    "input": "func gcd(_ a: Int, _ b: Int) -> Int {\n    var (x, y) = (a, b)\n    while y != 0 {\n        (x, y) = (y, x % y)\n    }\n    return x\n}",
    "output": "/// Находит наибольший общий делитель (НОД) для двух чисел.\n/// - Parameters:\n///   - a: Первое число.\n///   - b: Второе число.\n/// - Returns: НОД для двух чисел.\nfunc gcd(_ a: Int, _ b: Int) -> Int {\n    var (x, y) = (a, b)\n    while y != 0 {\n        (x, y) = (y, x % y)\n    }\n    return x\n}"
  },
  {
    "input": "func repeatCharacterString(_ char: Character, count: Int) -> String {\n    return String(repeating: char, count: count)\n}",
    "output": "/// Генерирует строку, содержащую повторяющийся символ заданное количество раз.\n/// - Parameters:\n///   - char: Символ для повторения.\n///   - count: Количество повторений.\n/// - Returns: Строка с повторяющимися символами.\nfunc repeatCharacterString(_ char: Character, count: Int) -> String {\n    return String(repeating: char, count: count)\n}"
  },
  {
    "input": "func stringToWordArray(_ str: String) -> [String] {\n    return str.split(separator: \" \").map { String($0) }\n}",
    "output": "/// Преобразует строку в массив слов, разделенных пробелами.\n/// - Parameter str: Входная строка.\n/// - Returns: Массив слов.\nfunc stringToWordArray(_ str: String) -> [String] {\n    return str.split(separator: \" \").map { String($0) }\n}"
  },
  {
    "input": "func squareRoot(_ number: Double) -> Double {\n    return sqrt(number)\n}",
    "output": "/// Вычисляет корень квадратный из числа.\n/// - Parameter number: Входное число.\n/// - Returns: Квадратный корень числа.\nfunc squareRoot(_ number: Double) -> Double {\n    return sqrt(number)\n}"
  },
  {
    "input": "func toCamelCase(_ str: String) -> String {\n    let words = str.split(separator: \" \").map { $0.lowercased() }\n    return words.first! + words.dropFirst().map { $0.capitalized }.joined()\n}",
    "output": "/// Преобразует строку в формат \"CamelCase\".\n/// - Parameter str: Входная строка.\n/// - Returns: Строка в формате \"CamelCase\".\nfunc toCamelCase(_ str: String) -> String {\n    let words = str.split(separator: \" \").map { $0.lowercased() }\n    return words.first! + words.dropFirst().map { $0.capitalized }.joined()\n}"
  },
  {
    "input": "func sumOfArray(_ numbers: [Int]) -> Int {\n    return numbers.reduce(0, +)\n}",
    "output": "/// Возвращает сумму всех чисел в массиве.\n/// - Parameter numbers: Массив чисел.\n/// - Returns: Сумма чисел.\nfunc sumOfArray(_ numbers: [Int]) -> Int {\n    return numbers.reduce(0, +)\n}"
  },
  {
    "input": "func isFloat(_ str: String) -> Bool {\n    return Float(str) != nil\n}",
    "output": "/// Проверяет, является ли строка числом с плавающей точкой.\n/// - Parameter str: Входная строка.\n/// - Returns: `true`, если строка представляет собой число с плавающей точкой.\nfunc isFloat(_ str: String) -> Bool {\n    return Float(str) != nil\n}"
  },
  {
    "input": "func stringToIntArray(_ str: String) -> [Int] {\n    return str.split(separator: \",\").compactMap { Int($0) }\n}",
    "output": "/// Преобразует строку в массив целых чисел.\n/// - Parameter str: Входная строка.\n/// - Returns: Массив целых чисел.\nfunc stringToIntArray(_ str: String) -> [Int] {\n    return str.split(separator: \",\").compactMap { Int($0) }\n}"
  },
  {
    "input": "func factorial(_ n: Int) -> Int {\n    return n == 0 ? 1 : n * factorial(n - 1)\n}",
    "output": "/// Находит факториал числа.\n/// - Parameter n: Число.\n/// - Returns: Факториал числа.\nfunc factorial(_ n: Int) -> Int {\n    return n == 0 ? 1 : n * factorial(n - 1)\n}"
  },
  {
    "input": "func caesarCipher(_ str: String, shift: Int) -> String {\n    return String(str.unicodeScalars.map { char in\n        if char.isLetter {\n            let base: UInt32 = char.isUppercase ? 65 : 97\n            let shifted = (char.value - base + UInt32(shift)) % 26 + base\n            return Character(UnicodeScalar(shifted)!)\n        }\n        return char\n    })\n}",
    "output": "/// Преобразует строку в строку, где каждый символ зашифрован сдвигом по алфавиту.\n/// - Parameters:\n///   - str: Входная строка.\n///   - shift: Сдвиг по алфавиту.\n/// - Returns: Зашифрованная строка.\nfunc caesarCipher(_ str: String, shift: Int) -> String {\n    return String(str.unicodeScalars.map { char in\n        if char.isLetter {\n            let base: UInt32 = char.isUppercase ? 65 : 97\n            let shifted = (char.value - base + UInt32(shift)) % 26 + base\n            return Character(UnicodeScalar(shifted)!)\n        }\n        return char\n    })\n}"
  },
  {
    "input": "func averageOfArray(_ numbers: [Double]) -> Double {\n    return numbers.reduce(0, +) / Double(numbers.count)\n}",
    "output": "/// Находит среднее арифметическое массива чисел.\n/// - Parameter numbers: Массив чисел.\n/// - Returns: Среднее арифметическое.\nfunc averageOfArray(_ numbers: [Double]) -> Double {\n    return numbers.reduce(0, +) / Double(numbers.count)\n}"
  },
  {
    "input": "func stringToCharacterArray(_ str: String) -> [Character] {\n    return Array(str)\n}",
    "output": "/// Преобразует строку в массив символов.\n/// - Parameter str: Входная строка.\n/// - Returns: Массив символов.\nfunc stringToCharacterArray(_ str: String) -> [Character] {\n    return Array(str)\n}"
  },
  {
    "input": "func isPrime(_ number: Int) -> Bool {\n    guard number > 1 else { return false }\n    for i in 2..<number {\n        if number % i == 0 {\n            return false\n        }\n    }\n    return true\n}",
    "output": "/// Проверяет, является ли число простым.\n/// - Parameter number: Число.\n/// - Returns: `true`, если число простое.\nfunc isPrime(_ number: Int) -> Bool {\n    guard number > 1 else { return false }\n    for i in 2..<number {\n        if number % i == 0 {\n            return false\n        }\n    }\n    return true\n}"
  },
  {
    "input": "func formatDecimal(_ number: Double, precision: Int) -> String {\n    return String(format: \"%.\\(precision)f\", number)\n}",
    "output": "/// Преобразует число в строку с заданным количеством знаков после запятой.\n/// - Parameters:\n///   - number: Входное число.\n///   - precision: Количество знаков после запятой.\n/// - Returns: Строка с числом, округленным до заданной точности.\nfunc formatDecimal(_ number: Double, precision: Int) -> String {\n    return String(format: \"%.\\(precision)f\", number)\n}"
  },
  {
    "input": "func isPalindrome(_ str: String) -> Bool {\n    let cleaned = str.lowercased().filter { $0.isLetter }\n    return cleaned == String(cleaned.reversed())\n}",
    "output": "/// Проверяет, является ли строка палиндромом.\n/// - Parameter str: Входная строка.\n/// - Returns: `true`, если строка палиндром.\nfunc isPalindrome(_ str: String) -> Bool {\n    let cleaned = str.lowercased().filter { $0.isLetter }\n    return cleaned == String(cleaned.reversed())\n}"
  },
  {
    "input": "func areCoprime(_ a: Int, _ b: Int) -> Bool {\n    return gcd(a, b) == 1\n}",
    "output": "/// Проверяет, являются ли два числа взаимно простыми (их НОД равен 1).\n/// - Parameters:\n///   - a: Первое число.\n///   - b: Второе число.\n/// - Returns: `true`, если числа взаимно простые.\nfunc areCoprime(_ a: Int, _ b: Int) -> Bool {\n    return gcd(a, b) == 1\n}"
  },
  {
    "input": "func distanceBetweenPoints(x1: Double, y1: Double, x2: Double, y2: Double) -> Double {\n    return sqrt(pow(x2 - x1, 2) + pow(y2 - y1, 2))\n}",
    "output": "/// Вычисляет расстояние между двумя точками в 2D пространстве.\n/// - Parameters:\n///   - x1: X координата первой точки.\n///   - y1: Y координата первой точки.\n///   - x2: X координата второй точки.\n///   - y2: Y координата второй точки.\n/// - Returns: Евклидово расстояние.\nfunc distanceBetweenPoints(x1: Double, y1: Double, x2: Double, y2: Double) -> Double {\n    return sqrt(pow(x2 - x1, 2) + pow(y2 - y1, 2))\n}"
  },
  {
    "input": "func areAnagrams(_ str1: String, _ str2: String) -> Bool {\n    return str1.lowercased().sorted() == str2.lowercased().sorted()\n}",
    "output": "/// Проверяет, является ли строка анаграммой другой строки.\n/// - Parameters:\n///   - str1: Первая строка.\n///   - str2: Вторая строка.\n/// - Returns: `true`, если строки являются анаграммами.\nfunc areAnagrams(_ str1: String, _ str2: String) -> Bool {\n    return str1.lowercased().sorted() == str2.lowercased().sorted()\n}"
  },
  {
    "input": "func stringToDoubleArray(_ str: String) -> [Double] {\n    return str.split(separator: \",\").compactMap { Double($0) }\n}",
    "output": "/// Преобразует строку в массив чисел с плавающей точкой.\n/// - Parameter str: Входная строка.\n/// - Returns: Массив чисел с плавающей точкой, извлеченных из строки.\nfunc stringToDoubleArray(_ str: String) -> [Double] {\n    return str.split(separator: \",\").compactMap { Double($0) }\n}"
  },
  {
    "input": "func isScientificNumber(_ str: String) -> Bool {\n    return Double(str) != nil\n}",
    "output": "/// Проверяет, является ли строка числом в экспоненциальной форме.\n/// - Parameter str: Входная строка.\n/// - Returns: `true`, если строка представляет собой число в экспоненциальной форме.\nfunc isScientificNumber(_ str: String) -> Bool {\n    return Double(str) != nil\n}"
  },
  {
    "input": "func isValidUUID(_ str: String) -> Bool {\n    return UUID(uuidString: str) != nil\n}",
    "output": "/// Проверяет, является ли строка валидным UUID.\n/// - Parameter str: Входная строка.\n/// - Returns: `true`, если строка является валидным UUID.\nfunc isValidUUID(_ str: String) -> Bool {\n    return UUID(uuidString: str) != nil\n}"
  },
  {
    "input": "func iterativeFactorial(_ n: Int) -> Int {\n    return (1...n).reduce(1, *)\n}",
    "output": "/// Вычисляет факториал числа с использованием итеративного подхода.\n/// - Parameter n: Число.\n/// - Returns: Факториал числа.\nfunc iterativeFactorial(_ n: Int) -> Int {\n    return (1...n).reduce(1, *)\n}"
  },
  {
    "input": "func toTitleCase(_ str: String) -> String {\n    return str.lowercased().split(separator: \" \").map { $0.capitalized }.joined(separator: \" \")\n}",
    "output": "/// Преобразует строку в формат \"Title Case\" (каждое слово начинается с заглавной буквы).\n/// - Parameter str: Входная строка.\n/// - Returns: Строка в формате \"Title Case\".\nfunc toTitleCase(_ str: String) -> String {\n    return str.lowercased().split(separator: \" \").map { $0.capitalized }.joined(separator: \" \")\n}"
  },
  {
    "input": "func generateUniqueID() -> String {\n    return UUID().uuidString + \"-\" + String(Int(Date().timeIntervalSince1970))\n}",
    "output": "/// Генерирует уникальный идентификатор с помощью текущего времени.\n/// - Returns: Строка с уникальным идентификатором.\nfunc generateUniqueID() -> String {\n    return UUID().uuidString + \"-\" + String(Int(Date().timeIntervalSince1970))\n}"
  },
  {
    "input": "func stringToBoolArray(_ str: String) -> [Bool] {\n    return str.compactMap { $0 == \"1\" ? true : ($0 == \"0\" ? false : nil) }\n}",
    "output": "/// Преобразует строку в массив булевых значений (True/False).\n/// - Parameter str: Входная строка.\n/// - Returns: Массив булевых значений, где каждый символ '1' - true, а '0' - false.\nfunc stringToBoolArray(_ str: String) -> [Bool] {\n    return str.compactMap { $0 == \"1\" ? true : ($0 == \"0\" ? false : nil) }\n}"
  },
  {
    "input": "func stringToIntegerArrayWithSpaces(_ str: String) -> [Int] {\n    return str.split(separator: \" \").compactMap { Int($0) }\n}",
    "output": "/// Преобразует строку в массив целых чисел, разделенных пробелами.\n/// - Parameter str: Входная строка.\n/// - Returns: Массив целых чисел.\nfunc stringToIntegerArrayWithSpaces(_ str: String) -> [Int] {\n    return str.split(separator: \" \").compactMap { Int($0) }\n}"
  },
  {
    "input": "func rotateString(_ str: String, by shift: Int) -> String {\n    let index = str.index(str.startIndex, offsetBy: shift % str.count)\n    return String(str[index...] + str[..<index])\n}",
    "output": "/// Поворачивает строку на заданное количество символов.\n/// - Parameters:\n///   - str: Входная строка.\n///   - shift: Количество символов для сдвига.\n/// - Returns: Повернутая строка.\nfunc rotateString(_ str: String, by shift: Int) -> String {\n    let index = str.index(str.startIndex, offsetBy: shift % str.count)\n    return String(str[index...] + str[..<index])\n}"
  },
  {
    "input": "func stringToUppercaseCharArray(_ str: String) -> [Character] {\n    return Array(str.uppercased())\n}",
    "output": "/// Преобразует строку в массив символов в верхнем регистре.\n/// - Parameter str: Входная строка.\n/// - Returns: Массив символов в верхнем регистре.\nfunc stringToUppercaseCharArray(_ str: String) -> [Character] {\n    return Array(str.uppercased())\n}"
  },
  {
    "input": "func stringToIntArrayWithSpaces(_ str: String) -> [Int] {\n    return str.split(separator: \" \").compactMap { Int($0) }\n}",
    "output": "/// Преобразует строку в массив целых чисел с учетом возможных пробелов.\n/// - Parameter str: Входная строка.\n/// - Returns: Массив целых чисел.\nfunc stringToIntArrayWithSpaces(_ str: String) -> [Int] {\n    return str.split(separator: \" \").compactMap { Int($0) }\n}"
  },
  {
    "input": "func sortStringsByLengthDescending(_ strings: [String]) -> [String] {\n    return strings.sorted { $0.count > $1.count }\n}",
    "output": "/// Сортирует массив строк по длине строки в убывающем порядке.\n/// - Parameter strings: Массив строк.\n/// - Returns: Отсортированный массив строк по длине.\nfunc sortStringsByLengthDescending(_ strings: [String]) -> [String] {\n    return strings.sorted { $0.count > $1.count }\n}"
  },
  {
    "input": "func alternateCase(_ str: String) -> String {\n    return str.enumerated().map { (index, char) in\n        index % 2 == 0 ? char.lowercased() : char.uppercased()\n    }.joined()\n}",
    "output": "/// Преобразует строку в строку с чередующимися заглавными и строчными буквами.\n/// - Parameter str: Входная строка.\n/// - Returns: Строка с чередующимися заглавными и строчными буквами.\nfunc alternateCase(_ str: String) -> String {\n    return str.enumerated().map { (index, char) in\n        index % 2 == 0 ? char.lowercased() : char.uppercased()\n    }.joined()\n}"
  },
  {
    "input": "func stringToNumbersArray(_ str: String) -> [Int] {\n    return str.split(whereSeparator: { $0 == \" \" || $0 == \",\" }).compactMap { Int($0) }\n}",
    "output": "/// Преобразует строку в массив чисел, разделенных пробелами или запятыми.\n/// - Parameter str: Входная строка.\n/// - Returns: Массив чисел.\nfunc stringToNumbersArray(_ str: String) -> [Int] {\n    return str.split(whereSeparator: { $0 == \" \" || $0 == \",\" }).compactMap { Int($0) }\n}"
  },
  {
    "input": "func isBinaryNumber(_ str: String) -> Bool {\n    return str.allSatisfy { $0 == \"0\" || $0 == \"1\" }\n}",
    "output": "/// Проверяет, является ли строка числом в двоичной системе.\n/// - Parameter str: Входная строка.\n/// - Returns: `true`, если строка является двоичным числом.\nfunc isBinaryNumber(_ str: String) -> Bool {\n    return str.allSatisfy { $0 == \"0\" || $0 == \"1\" }\n}"
  },
  {
    "input": "func joinStringsWithSeparator(_ strings: [String], separator: String) -> String {\n    return strings.joined(separator: separator)\n}",
    "output": "/// Преобразует массив строк в строку с разделителями.\n/// - Parameters:\n///   - strings: Массив строк.\n///   - separator: Разделитель.\n/// - Returns: Объединенная строка с разделителями.\nfunc joinStringsWithSeparator(_ strings: [String], separator: String) -> String {\n    return strings.joined(separator: separator)\n}"
  },
  {
    "input": "func stringToLowercaseCharArray(_ str: String) -> [Character] {\n    return Array(str.lowercased())\n}",
    "output": "/// Преобразует строку в массив символов в нижнем регистре.\n/// - Parameter str: Входная строка.\n/// - Returns: Массив символов в нижнем регистре.\nfunc stringToLowercaseCharArray(_ str: String) -> [Character] {\n    return Array(str.lowercased())\n}"
  },
  {
    "input": "func absoluteValue(_ number: Double) -> Double {\n    return abs(number)\n}",
    "output": "/// Возвращает абсолютное значение числа.\n/// - Parameter number: Входное число.\n/// - Returns: Абсолютное значение числа.\nfunc absoluteValue(_ number: Double) -> Double {\n    return abs(number)\n}"
  },
  {
    "input": "func extractNumbersFromString(_ str: String) -> [Int] {\n    return str.compactMap { Int(String($0)) }\n}",
    "output": "/// Преобразует строку в массив чисел, игнорируя символы, не являющиеся цифрами.\n/// - Parameter str: Входная строка.\n/// - Returns: Массив чисел.\nfunc extractNumbersFromString(_ str: String) -> [Int] {\n    return str.compactMap { Int(String($0)) }\n}"
  },
  {
    "input": "func isValidIPv4(_ ip: String) -> Bool {\n    let parts = ip.split(separator: \".\")\n    guard parts.count == 4 else { return false }\n    return parts.allSatisfy { part in\n        if let number = Int(part), number >= 0 && number <= 255 {\n            return true\n        }\n        return false\n    }\n}",
    "output": "/// Проверяет, является ли строка валидным IP-адресом (IPv4).\n/// - Parameter ip: Входная строка.\n/// - Returns: `true`, если строка является валидным IPv4-адресом.\nfunc isValidIPv4(_ ip: String) -> Bool {\n    let parts = ip.split(separator: \".\")\n    guard parts.count == 4 else { return false }\n    return parts.allSatisfy { part in\n        if let number = Int(part), number >= 0 && number <= 255 {\n            return true\n        }\n        return false\n    }\n}"
  },
  {
    "input": "func maxValue(of numbers: [Int]) -> Int? {\n    return numbers.max()\n}",
    "output": "/// Возвращает максимальное значение в массиве чисел.\n/// - Parameter numbers: Массив чисел.\n/// - Returns: Максимальное значение в массиве.\nfunc maxValue(of numbers: [Int]) -> Int? {\n    return numbers.max()\n}"
  },
  {
    "input": "func average(of numbers: [Double]) -> Double {\n    return numbers.reduce(0, +) / Double(numbers.count)\n}",
    "output": "/// Находит среднее значение массива чисел с плавающей точкой.\n/// - Parameter numbers: Массив чисел.\n/// - Returns: Среднее значение.\nfunc average(of numbers: [Double]) -> Double {\n    return numbers.reduce(0, +) / Double(numbers.count)\n}"
  },
  {
    "input": "func celsiusToKelvin(_ celsius: Double) -> Double {\n    return celsius + 273.15\n}",
    "output": "/// Преобразует температуру из Цельсия в Кельвины.\n/// - Parameter celsius: Температура в Цельсиях.\n/// - Returns: Температура в Кельвинах.\nfunc celsiusToKelvin(_ celsius: Double) -> Double {\n    return celsius + 273.15\n}"
  },
  {
    "input": "func isArrayAscending(_ array: [Int]) -> Bool {\n    return array == array.sorted()\n}",
    "output": "/// Проверяет, является ли массив чисел возрастающим.\n/// - Parameter array: Массив чисел.\n/// - Returns: `true`, если массив возрастающий.\nfunc isArrayAscending(_ array: [Int]) -> Bool {\n    return array == array.sorted()\n}"
  },
  {
    "input": "func fahrenheitToCelsius(_ fahrenheit: Double) -> Double {\n    return (fahrenheit - 32) * 5/9\n}",
    "output": "/// Переводит температуру из Фаренгейтов в Цельсии.\n/// - Parameter fahrenheit: Температура в Фаренгейтах.\n/// - Returns: Температура в Цельсиях.\nfunc fahrenheitToCelsius(_ fahrenheit: Double) -> Double {\n    return (fahrenheit - 32) * 5/9\n}"
  },
  {
    "input": "func isEven(number: Int) -> Bool {\n    return number % 2 == 0\n}",
    "output": "/// Проверяет, является ли число четным.\n/// - Parameter number: Входное число.\n/// - Returns: `true`, если число четное.\nfunc isEven(number: Int) -> Bool {\n    return number % 2 == 0\n}"
  },
  {
    "input": "func randomInRange(min: Int, max: Int) -> Int {\n    return Int.random(in: min...max)\n}",
    "output": "/// Генерирует случайное число в указанном диапазоне.\n/// - Parameters:\n///   - min: Минимальное значение.\n///   - max: Максимальное значение.\n/// - Returns: Случайное число в диапазоне от `min` до `max`.\nfunc randomInRange(min: Int, max: Int) -> Int {\n    return Int.random(in: min...max)\n}"
  },
  {
    "input": "func joinStringsWithComma(_ strings: [String]) -> String {\n    return strings.joined(separator: \", \")\n}",
    "output": "/// Преобразует массив строк в одну строку, разделяя их запятой.\n/// - Parameter strings: Массив строк.\n/// - Returns: Объединенная строка.\nfunc joinStringsWithComma(_ strings: [String]) -> String {\n    return strings.joined(separator: \", \")\n}"
  },
  {
    "input": "func rectanglePerimeter(length: Double, width: Double) -> Double {\n    return 2 * (length + width)\n}",
    "output": "/// Вычисляет периметр прямоугольника.\n/// - Parameters:\n///   - length: Длина.\n///   - width: Ширина.\n/// - Returns: Периметр прямоугольника.\nfunc rectanglePerimeter(length: Double, width: Double) -> Double {\n    return 2 * (length + width)\n}"
  },
  {
    "input": "func degreesToRadians(_ degrees: Double) -> Double {\n    return degrees * .pi / 180\n}",
    "output": "/// Конвертирует градусы в радианы.\n/// - Parameter degrees: Угол в градусах.\n/// - Returns: Угол в радианах.\nfunc degreesToRadians(_ degrees: Double) -> Double {\n    return degrees * .pi / 180\n}"
  },
  {
    "input": "func matrixMultiply(matrix1: [[Int]], matrix2: [[Int]]) -> [[Int]]? {\n    let rowCount = matrix1.count\n    let colCount = matrix2[0].count\n    let commonDim = matrix1[0].count\n    \n    guard matrix2.count == commonDim else { return nil }\n    \n    var result = Array(repeating: Array(repeating: 0, count: colCount), count: rowCount)\n    \n    for i in 0..<rowCount {\n        for j in 0..<colCount {\n            for k in 0..<commonDim {\n                result[i][j] += matrix1[i][k] * matrix2[k][j]\n            }\n        }\n    }\n    \n    return result\n}",
    "output": "/// Умножает два матричных массива.\n/// - Parameters:\n///   - matrix1: Первая матрица.\n///   - matrix2: Вторая матрица.\n/// - Returns: Результат умножения двух матриц.\nfunc matrixMultiply(matrix1: [[Int]], matrix2: [[Int]]) -> [[Int]]? {\n    let rowCount = matrix1.count\n    let colCount = matrix2[0].count\n    let commonDim = matrix1[0].count\n    \n    guard matrix2.count == commonDim else { return nil }\n    \n    var result = Array(repeating: Array(repeating: 0, count: colCount), count: rowCount)\n    \n    for i in 0..<rowCount {\n        for j in 0..<colCount {\n            for k in 0..<commonDim {\n                result[i][j] += matrix1[i][k] * matrix2[k][j]\n            }\n        }\n    }\n    \n    return result\n}"
  },
  {
    "input": "func isPrimeNumber(_ number: Int) -> Bool {\n    guard number > 1 else { return false }\n    for i in 2..<number {\n        if number % i == 0 { return false }\n    }\n    return true\n}",
    "output": "/// Проверяет, является ли число простым.\n/// - Parameter number: Входное число.\n/// - Returns: `true`, если число простое.\nfunc isPrimeNumber(_ number: Int) -> Bool {\n    guard number > 1 else { return false }\n    for i in 2..<number {\n        if number % i == 0 { return false }\n    }\n    return true\n}"
  },
  {
    "input": "func recursiveFactorial(_ n: Int) -> Int {\n    return n == 0 ? 1 : n * recursiveFactorial(n - 1)\n}",
    "output": "/// Вычисляет факториал числа с помощью рекурсии.\n/// - Parameter n: Число.\n/// - Returns: Факториал числа.\nfunc recursiveFactorial(_ n: Int) -> Int {\n    return n == 0 ? 1 : n * recursiveFactorial(n - 1)\n}"
  },
  {
    "input": "func isPalindromeCaseSensitive(_ str: String) -> Bool {\n    return str == String(str.reversed())\n}",
    "output": "/// Проверяет, является ли строка палиндромом (с учетом регистра).\n/// - Parameter str: Входная строка.\n/// - Returns: `true`, если строка палиндром.\nfunc isPalindromeCaseSensitive(_ str: String) -> Bool {\n    return str == String(str.reversed())\n}"
  },
  {
    "input": "func findMax(of numbers: [Int]) -> Int? {\n    return numbers.max()\n}",
    "output": "/// Находит максимальный элемент в массиве чисел.\n/// - Parameter numbers: Массив чисел.\n/// - Returns: Максимальное значение в массиве.\nfunc findMax(of numbers: [Int]) -> Int? {\n    return numbers.max()\n}"
  },
  {
    "input": "func bitsToBytes(_ bits: Int) -> Int {\n    return bits / 8\n}",
    "output": "/// Конвертирует значение в битах в байты.\n/// - Parameter bits: Значение в битах.\n/// - Returns: Значение в байтах.\nfunc bitsToBytes(_ bits: Int) -> Int {\n    return bits / 8\n}"
  },
  {
    "input": "func isSquareOf(a: Int, b: Int) -> Bool {\n    return a * a == b\n}",
    "output": "/// Проверяет, является ли число квадратом другого числа.\n/// - Parameters:\n///   - a: Число.\n///   - b: Число для проверки.\n/// - Returns: `true`, если b = a².\nfunc isSquareOf(a: Int, b: Int) -> Bool {\n    return a * a == b\n}"
  },
  {
    "input": "func stringToByteArray(_ str: String) -> [UInt8] {\n    return Array(str.utf8)\n}",
    "output": "/// Преобразует строку в массив байтов.\n/// - Parameter str: Входная строка.\n/// - Returns: Массив байтов.\nfunc stringToByteArray(_ str: String) -> [UInt8] {\n    return Array(str.utf8)\n}"
  },
  {
    "input": "func kelvinToCelsius(_ kelvin: Double) -> Double {\n    return kelvin - 273.15\n}",
    "output": "/// Преобразует температуру из Кельвинов в Цельсии.\n/// - Parameter kelvin: Температура в Кельвинах.\n/// - Returns: Температура в Цельсиях.\nfunc kelvinToCelsius(_ kelvin: Double) -> Double {\n    return kelvin - 273.15\n}"
  },
  {
    "input": "func intArrayToString(_ numbers: [Int]) -> String {\n    return numbers.map { String($0) }.joined(separator: \" \")\n}",
    "output": "/// Преобразует массив целых чисел в строку, разделенную пробелами.\n/// - Parameter numbers: Массив целых чисел.\n/// - Returns: Строка с числами, разделенными пробелами.\nfunc intArrayToString(_ numbers: [Int]) -> String {\n    return numbers.map { String($0) }.joined(separator: \" \")\n}"
  },
  {
    "input": "func intArrayToStringArray(_ numbers: [Int]) -> [String] {\n    return numbers.map { String($0) }\n}",
    "output": "/// Преобразует массив целых чисел в массив строк.\n/// - Parameter numbers: Массив целых чисел.\n/// - Returns: Массив строк, представляющих числа.\nfunc intArrayToStringArray(_ numbers: [Int]) -> [String] {\n    return numbers.map { String($0) }\n}"
  },
  {
    "input": "func sumOfSet(_ set: Set<Int>) -> Int {\n    return set.reduce(0, +)\n}",
    "output": "/// Вычисляет сумму элементов множества.\n/// - Parameter set: Множество чисел.\n/// - Returns: Сумма элементов множества.\nfunc sumOfSet(_ set: Set<Int>) -> Int {\n    return set.reduce(0, +)\n}"
  },
  {
    "input": "func isFutureDate(_ date: Date) -> Bool {\n    return date > Date()\n}",
    "output": "/// Проверяет, является ли переданная дата в будущем.\n/// - Parameter date: Дата для проверки.\n/// - Returns: `true`, если дата в будущем.\nfunc isFutureDate(_ date: Date) -> Bool {\n    return date > Date()\n}"
  },
  {
    "input": "func firstElement<T>(_ array: [T]) -> T? {\n    return array.first\n}",
    "output": "/// Возвращает первый элемент массива, если он существует.\n/// - Parameter array: Массив элементов.\n/// - Returns: Первый элемент массива или `nil`, если массив пуст.\nfunc firstElement<T>(_ array: [T]) -> T? {\n    return array.first\n}"
  },
  {
    "input": "func stringArrayToIntArray(_ strings: [String]) -> [Int]? {\n    return strings.compactMap { Int($0) }\n}",
    "output": "/// Преобразует массив строк в массив целых чисел, если возможно.\n/// - Parameter strings: Массив строк.\n/// - Returns: Массив целых чисел или `nil`, если не все строки могут быть преобразованы.\nfunc stringArrayToIntArray(_ strings: [String]) -> [Int]? {\n    return strings.compactMap { Int($0) }\n}"
  },
  {
    "input": "func isPositiveNumber(_ number: Int) -> Bool {\n    return number > 0\n}",
    "output": "/// Проверяет, является ли переданное число положительным.\n/// - Parameter number: Число для проверки.\n/// - Returns: `true`, если число положительное.\nfunc isPositiveNumber(_ number: Int) -> Bool {\n    return number > 0\n}"
  },
  {
    "input": "func bitwiseAndArrays(_ array1: [Int], _ array2: [Int]) -> [Int]? {\n    guard array1.count == array2.count else { return nil }\n    return zip(array1, array2).map { $0 & $1 }\n}",
    "output": "/// Выполняет побитовую операцию И для двух массивов чисел.\n/// - Parameters:\n///   - array1: Первый массив.\n///   - array2: Второй массив.\n/// - Returns: Массив, содержащий побитовые операции И для каждого соответствующего элемента.\nfunc bitwiseAndArrays(_ array1: [Int], _ array2: [Int]) -> [Int]? {\n    guard array1.count == array2.count else { return nil }\n    return zip(array1, array2).map { $0 & $1 }\n}"
  },
  {
    "input": "func countVowelsInString(_ str: String) -> Int {\n    let vowels: Set<Character> = [\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"]\n    return str.filter { vowels.contains($0) }.count\n}",
    "output": "/// Преобразует строку в массив символов и возвращает количество гласных.\n/// - Parameter str: Входная строка.\n/// - Returns: Количество гласных в строке.\nfunc countVowelsInString(_ str: String) -> Int {\n    let vowels: Set<Character> = [\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"]\n    return str.filter { vowels.contains($0) }.count\n}"
  },
  {
    "input": "func flattenMatrix(_ matrix: [[Int]]) -> [Int] {\n    return matrix.flatMap { $0 }\n}",
    "output": "/// Преобразует двухмерный массив чисел в одномерный массив.\n/// - Parameter matrix: Двухмерный массив чисел.\n/// - Returns: Одномерный массив.\nfunc flattenMatrix(_ matrix: [[Int]]) -> [Int] {\n    return matrix.flatMap { $0 }\n}"
  },
  {
    "input": "func longestString(_ strings: [String]) -> String? {\n    return strings.max { $0.count < $1.count }\n}",
    "output": "/// Находит строку с максимальной длиной в массиве строк.\n/// - Parameter strings: Массив строк.\n/// - Returns: Строка с максимальной длиной.\nfunc longestString(_ strings: [String]) -> String? {\n    return strings.max { $0.count < $1.count }\n}"
  },
  {
    "input": "func isValidURLString(_ urlString: String) -> Bool {\n    return URL(string: urlString) != nil\n}",
    "output": "/// Проверяет, является ли переданная строка валидным URL.\n/// - Parameter urlString: Строка, представляющая URL.\n/// - Returns: `true`, если строка является валидным URL.\nfunc isValidURLString(_ urlString: String) -> Bool {\n    return URL(string: urlString) != nil\n}"
  },
  {
    "input": "func averageOfDoubleArray(_ numbers: [Double]) -> Double {\n    return numbers.reduce(0, +) / Double(numbers.count)\n}",
    "output": "/// Вычисляет среднее значение чисел в массиве с плавающей точкой.\n/// - Parameter numbers: Массив чисел с плавающей точкой.\n/// - Returns: Среднее значение.\nfunc averageOfDoubleArray(_ numbers: [Double]) -> Double {\n    return numbers.reduce(0, +) / Double(numbers.count)\n}"
  },
  {
    "input": "func stringToUpperCaseArray(_ str: String) -> [Character] {\n    return Array(str.uppercased())\n}",
    "output": "/// Преобразует строку в массив символов в верхнем регистре.\n/// - Parameter str: Входная строка.\n/// - Returns: Массив символов в верхнем регистре.\nfunc stringToUpperCaseArray(_ str: String) -> [Character] {\n    return Array(str.uppercased())\n}"
  },
  {
    "input": "func sortWordsAlphabetically(_ words: [String]) -> [String] {\n    return words.sorted()\n}",
    "output": "/// Сортирует массив слов в алфавитном порядке.\n/// - Parameter words: Массив слов.\n/// - Returns: Отсортированный массив слов.\nfunc sortWordsAlphabetically(_ words: [String]) -> [String] {\n    return words.sorted()\n}"
  },
  {
    "input": "func intToBinaryString(_ number: Int) -> String {\n    return String(number, radix: 2)\n}",
    "output": "/// Преобразует число в двоичную строку.\n/// - Parameter number: Число.\n/// - Returns: Строка, представляющая число в двоичном формате.\nfunc intToBinaryString(_ number: Int) -> String {\n    return String(number, radix: 2)\n}"
  },
  {
    "input": "func extractDigitsFromString(_ str: String) -> [Int] {\n    return str.compactMap { $0.wholeNumberValue }\n}",
    "output": "/// Преобразует строку в массив чисел, извлекая только цифры.\n/// - Parameter str: Входная строка.\n/// - Returns: Массив чисел.\nfunc extractDigitsFromString(_ str: String) -> [Int] {\n    return str.compactMap { $0.wholeNumberValue }\n}"
  },
  {
    "input": "func findMaxKeyInDictionary(_ dictionary: [String: Int]) -> String? {\n    return dictionary.max(by: { $0.value < $1.value })?.key\n}",
    "output": "/// Находит наибольший элемент в словаре, используя его значение.\n/// - Parameter dictionary: Словарь с целочисленными значениями.\n/// - Returns: Ключ, связанный с наибольшим значением, или `nil`, если словарь пуст.\nfunc findMaxKeyInDictionary(_ dictionary: [String: Int]) -> String? {\n    return dictionary.max(by: { $0.value < $1.value })?.key\n}"
  },
  {
    "input": "func extractIntegersFromString(_ str: String) -> [Int] {\n    return str.compactMap { Int(String($0)) }\n}",
    "output": "/// Преобразует строку в массив целых чисел, игнорируя нечисловые символы.\n/// - Parameter str: Входная строка.\n/// - Returns: Массив целых чисел.\nfunc extractIntegersFromString(_ str: String) -> [Int] {\n    return str.compactMap { Int(String($0)) }\n}"
  },
  {
    "input": "func minMaxFromArray(_ numbers: [Int]) -> (min: Int, max: Int)? {\n    guard let minValue = numbers.min(), let maxValue = numbers.max() else { return nil }\n    return (minValue, maxValue)\n}",
    "output": "/// Создает кортеж с минимальным и максимальным значением из массива.\n/// - Parameter numbers: Массив чисел.\n/// - Returns: Кортеж с минимальным и максимальным значением.\nfunc minMaxFromArray(_ numbers: [Int]) -> (min: Int, max: Int)? {\n    guard let minValue = numbers.min(), let maxValue = numbers.max() else { return nil }\n    return (minValue, maxValue)\n}"
  },
  {
    "input": "func isDecimalNumber(_ str: String) -> Bool {\n    return Double(str) != nil\n}",
    "output": "/// Проверяет, является ли строка числом с плавающей точкой.\n/// - Parameter str: Входная строка.\n/// - Returns: `true`, если строка является числом с плавающей точкой.\nfunc isDecimalNumber(_ str: String) -> Bool {\n    return Double(str) != nil\n}"
  },
  {
    "input": "func sumOfFloatArray(_ numbers: [Float]) -> Float {\n    return numbers.reduce(0, +)\n}",
    "output": "/// Вычисляет сумму всех чисел в массиве с плавающей точкой.\n/// - Parameter numbers: Массив чисел с плавающей точкой.\n/// - Returns: Сумма чисел.\nfunc sumOfFloatArray(_ numbers: [Float]) -> Float {\n    return numbers.reduce(0, +)\n}"
  },
  {
    "input": "func stringToCharArrayWithoutSpaces(_ str: String) -> [Character] {\n    return str.filter { !$0.isWhitespace }\n}",
    "output": "/// Преобразует строку в массив символов, игнорируя пробелы.\n/// - Parameter str: Входная строка.\n/// - Returns: Массив символов без пробелов.\nfunc stringToCharArrayWithoutSpaces(_ str: String) -> [Character] {\n    return str.filter { !$0.isWhitespace }\n}"
  },
  {
    "input": "func isToday(_ date: Date) -> Bool {\n    let calendar = Calendar.current\n    let today = calendar.startOfDay(for: Date())\n    let targetDate = calendar.startOfDay(for: date)\n    return today == targetDate\n}",
    "output": "/// Проверяет, является ли переданная дата сегодняшним днем.\n/// - Parameter date: Дата для проверки.\n/// - Returns: `true`, если дата сегодня.\nfunc isToday(_ date: Date) -> Bool {\n    let calendar = Calendar.current\n    let today = calendar.startOfDay(for: Date())\n    let targetDate = calendar.startOfDay(for: date)\n    return today == targetDate\n}"
  },
  {
    "input": "func daysBetweenDates(startDate: Date, endDate: Date) -> Int {\n    return Calendar.current.dateComponents([.day], from: startDate, to: endDate).day ?? 0\n}",
    "output": "/// Вычисляет разницу в днях между двумя датами.\n/// - Parameters:\n///   - startDate: Начальная дата.\n///   - endDate: Конечная дата.\n/// - Returns: Количество дней между датами.\nfunc daysBetweenDates(startDate: Date, endDate: Date) -> Int {\n    return Calendar.current.dateComponents([.day], from: startDate, to: endDate).day ?? 0\n}"
  },
  {
    "input": "func flattenStringMatrix(_ matrix: [[String]]) -> [String] {\n    return matrix.flatMap { $0 }\n}",
    "output": "/// Преобразует двумерный массив строк в одномерный массив.\n/// - Parameter matrix: Двумерный массив строк.\n/// - Returns: Одномерный массив строк.\nfunc flattenStringMatrix(_ matrix: [[String]]) -> [String] {\n    return matrix.flatMap { $0 }\n}"
  },
  {
    "input": "func countEvenNumbers(_ numbers: [Int]) -> Int {\n    return numbers.filter { $0 % 2 == 0 }.count\n}",
    "output": "/// Возвращает количество элементов в массиве, которые являются четными.\n/// - Parameter numbers: Массив чисел.\n/// - Returns: Количество четных элементов.\nfunc countEvenNumbers(_ numbers: [Int]) -> Int {\n    return numbers.filter { $0 % 2 == 0 }.count\n}"
  },
  {
    "input": "func areStringsPalindrome(_ strings: [String]) -> Bool {\n    return strings.allSatisfy { $0 == String($0.reversed()) }\n}",
    "output": "/// Проверяет, является ли массив строк палиндромом.\n/// - Parameter strings: Массив строк.\n/// - Returns: `true`, если все строки в массиве палиндромы.\nfunc areStringsPalindrome(_ strings: [String]) -> Bool {\n    return strings.allSatisfy { $0 == String($0.reversed()) }\n}"
  },
  {
    "input": "func secondsToTimeFormat(_ seconds: Int) -> String {\n    let hours = seconds / 3600\n    let minutes = (seconds % 3600) / 60\n    let remainingSeconds = seconds % 60\n    return String(format: \"%02d:%02d:%02d\", hours, minutes, remainingSeconds)\n}",
    "output": "/// Конвертирует количество секунд в формат \"часы:минуты:секунды\".\n/// - Parameter seconds: Количество секунд.\n/// - Returns: Строка в формате \"часы:минуты:секунды\".\nfunc secondsToTimeFormat(_ seconds: Int) -> String {\n    let hours = seconds / 3600\n    let minutes = (seconds % 3600) / 60\n    let remainingSeconds = seconds % 60\n    return String(format: \"%02d:%02d:%02d\", hours, minutes, remainingSeconds)\n}"
  },
  {
    "input": "func stringToWordArray(_ str: String) -> [String] {\n    return str.split(separator: \" \").map { String($0) }\n}",
    "output": "/// Преобразует строку в массив слов, разделенных пробелами.\n/// - Parameter str: Входная строка.\n/// - Returns: Массив слов.\nfunc stringToWordArray(_ str: String) -> [String] {\n    return str.split(separator: \" \").map { String($0) }\n}"
  },
  {
    "input": "func isMultipleOf(_ number: Int, divisor: Int) -> Bool {\n    return number % divisor == 0\n}",
    "output": "/// Проверяет, является ли число кратным другому числу.\n/// - Parameters:\n///   - number: Число.\n///   - divisor: Делитель.\n/// - Returns: `true`, если число делится нацело.\nfunc isMultipleOf(_ number: Int, divisor: Int) -> Bool {\n    return number % divisor == 0\n}"
  },
  {
    "input": "func sumOfEvenNumbers(_ numbers: [Int]) -> Int {\n    return numbers.filter { $0 % 2 == 0 }.reduce(0, +)\n}",
    "output": "/// Находит сумму всех четных чисел в массиве.\n/// - Parameter numbers: Массив чисел.\n/// - Returns: Сумма четных чисел.\nfunc sumOfEvenNumbers(_ numbers: [Int]) -> Int {\n    return numbers.filter { $0 % 2 == 0 }.reduce(0, +)\n}"
  },
  {
    "input": "func capitalizeWords(_ str: String) -> String {\n    return str.capitalized\n}",
    "output": "/// Преобразует строку в строку, где каждое слово начинается с заглавной буквы.\n/// - Parameter str: Входная строка.\n/// - Returns: Строка с заглавной первой буквой каждого слова.\nfunc capitalizeWords(_ str: String) -> String {\n    return str.capitalized\n}"
  },
  {
    "input": "func sortArrayDescending(_ numbers: [Int]) -> [Int] {\n    return numbers.sorted(by: >)\n}",
    "output": "/// Сортирует массив чисел в порядке убывания.\n/// - Parameter numbers: Массив чисел.\n/// - Returns: Отсортированный массив в порядке убывания.\nfunc sortArrayDescending(_ numbers: [Int]) -> [Int] {\n    return numbers.sorted(by: >)\n}"
  },
  {
    "input": "func numberToStringWithLeadingZeros(_ number: Int, length: Int) -> String {\n    return String(format: \"%0\\(length)d\", number)\n}",
    "output": "/// Преобразует число в строку с ведущими нулями.\n/// - Parameters:\n///   - number: Число.\n///   - length: Общая длина строки.\n/// - Returns: Строка с ведущими нулями.\nfunc numberToStringWithLeadingZeros(_ number: Int, length: Int) -> String {\n    return String(format: \"%0\\(length)d\", number)\n}"
  },
  {
    "input": "func sumOfDictionaryValues(_ dictionary: [String: Int]) -> Int {\n    return dictionary.values.reduce(0, +)\n}",
    "output": "/// Суммирует все элементы словаря с целочисленными значениями.\n/// - Parameter dictionary: Словарь с целочисленными значениями.\n/// - Returns: Сумма значений.\nfunc sumOfDictionaryValues(_ dictionary: [String: Int]) -> Int {\n    return dictionary.values.reduce(0, +)\n}"
  },
  {
    "input": "func generateNumbers(upTo: Int) -> [Int] {\n    return Array(1...upTo)\n}",
    "output": "/// Генерирует массив чисел от 1 до заданного числа.\n/// - Parameter upTo: Число, до которого нужно сгенерировать массив.\n/// - Returns: Массив чисел.\nfunc generateNumbers(upTo: Int) -> [Int] {\n    return Array(1...upTo)\n}"
  },
  {
    "input": "func areSetsEqual<T>(_ set1: Set<T>, _ set2: Set<T>) -> Bool {\n    return set1 == set2\n}",
    "output": "/// Проверяет, являются ли два множества одинаковыми.\n/// - Parameters:\n///   - set1: Первое множество.\n///   - set2: Второе множество.\n/// - Returns: `true`, если множества одинаковы.\nfunc areSetsEqual<T>(_ set1: Set<T>, _ set2: Set<T>) -> Bool {\n    return set1 == set2\n}"
  },
  {
    "input": "func stringToLowerCaseCharArray(_ str: String) -> [Character] {\n    return Array(str.lowercased())\n}",
    "output": "/// Преобразует строку в массив символов в нижнем регистре.\n/// - Parameter str: Входная строка.\n/// - Returns: Массив символов в нижнем регистре.\nfunc stringToLowerCaseCharArray(_ str: String) -> [Character] {\n    return Array(str.lowercased())\n}"
  },
  {
    "input": "func sortStringsByLengthAscending(_ strings: [String]) -> [String] {\n    return strings.sorted { $0.count < $1.count }\n}",
    "output": "/// Сортирует массив строк по длине строки в порядке возрастания.\n/// - Parameter strings: Массив строк.\n/// - Returns: Отсортированный массив строк по длине.\nfunc sortStringsByLengthAscending(_ strings: [String]) -> [String] {\n    return strings.sorted { $0.count < $1.count }\n}"
  },
  {
    "input": "func isBlank(_ str: String) -> Bool {\n    return str.trimmingCharacters(in: .whitespaces).isEmpty\n}",
    "output": "/// Проверяет, является ли строка пустой или состоит только из пробелов.\n/// - Parameter str: Входная строка.\n/// - Returns: `true`, если строка пустая или состоит только из пробелов.\nfunc isBlank(_ str: String) -> Bool {\n    return str.trimmingCharacters(in: .whitespaces).isEmpty\n}"
  },
  {
    "input": "func flattenIntegerMatrix(_ matrix: [[Int]]) -> [Int] {\n    return matrix.flatMap { $0 }\n}",
    "output": "/// Преобразует двумерный массив чисел в одномерный массив.\n/// - Parameter matrix: Двумерный массив чисел.\n/// - Returns: Одномерный массив чисел.\nfunc flattenIntegerMatrix(_ matrix: [[Int]]) -> [Int] {\n    return matrix.flatMap { $0 }\n}"
  },
  {
    "input": "func isFloatingPointNumber(_ str: String) -> Bool {\n    return Double(str) != nil\n}",
    "output": "/// Проверяет, является ли строка числом с плавающей точкой.\n/// - Parameter str: Входная строка.\n/// - Returns: `true`, если строка является числом с плавающей точкой.\nfunc isFloatingPointNumber(_ str: String) -> Bool {\n    return Double(str) != nil\n}"
  },
  {
    "input": "func findMinValue(_ numbers: [Int]) -> Int? {\n    return numbers.min()\n}",
    "output": "/// Возвращает наименьший элемент массива чисел.\n/// - Parameter numbers: Массив чисел.\n/// - Returns: Наименьший элемент массива.\nfunc findMinValue(_ numbers: [Int]) -> Int? {\n    return numbers.min()\n}"
  },
  {
    "input": "func isValidEmail(_ email: String) -> Bool {\n    let pattern = \"[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\\\.[A-Za-z]{2,64}\"\n    return email.range(of: pattern, options: .regularExpression) != nil\n}",
    "output": "/// Проверяет, является ли строка в формате электронной почты.\n/// - Parameter email: Входная строка.\n/// - Returns: `true`, если строка является валидным email.\nfunc isValidEmail(_ email: String) -> Bool {\n    let pattern = \"[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\\\.[A-Za-z]{2,64}\"\n    return email.range(of: pattern, options: .regularExpression) != nil\n}"
  },
  {
    "input": "func randomFloat(inRange min: Double, max: Double) -> Double {\n    return Double.random(in: min...max)\n}",
    "output": "/// Генерирует случайное число с плавающей точкой в указанном диапазоне.\n/// - Parameters:\n///   - min: Минимальное значение.\n///   - max: Максимальное значение.\n/// - Returns: Случайное число с плавающей точкой.\nfunc randomFloat(inRange min: Double, max: Double) -> Double {\n    return Double.random(in: min...max)\n}"
  },
  {
    "input": "func stringToCommaSeparatedIntegers(_ str: String) -> [Int]? {\n    return str.split(separator: \",\").compactMap { Int($0) }\n}",
    "output": "/// Преобразует строку в массив чисел, разделенных запятой.\n/// - Parameter str: Входная строка.\n/// - Returns: Массив чисел.\nfunc stringToCommaSeparatedIntegers(_ str: String) -> [Int]? {\n    return str.split(separator: \",\").compactMap { Int($0) }\n}"
  },
  {
    "input": "func isFutureDate(_ date: Date) -> Bool {\n    return date > Date()\n}",
    "output": "/// Проверяет, является ли дата в будущем относительно текущей.\n/// - Parameter date: Дата для проверки.\n/// - Returns: `true`, если дата в будущем.\nfunc isFutureDate(_ date: Date) -> Bool {\n    return date > Date()\n}"
  },
  {
    "input": "func repeatCharacter(_ char: Character, count: Int) -> String {\n    return String(repeating: char, count: count)\n}",
    "output": "/// Генерирует строку с повторяющимися символами.\n/// - Parameters:\n///   - char: Символ.\n///   - count: Количество повторений.\n/// - Returns: Строка с повторяющимися символами.\nfunc repeatCharacter(_ char: Character, count: Int) -> String {\n    return String(repeating: char, count: count)\n}"
  },
  {
    "input": "func stringToWordArray(_ str: String) -> [String] {\n    return str.split(separator: \" \").map { String($0) }\n}",
    "output": "/// Преобразует строку в массив слов, разделенных пробелами.\n/// - Parameter str: Входная строка.\n/// - Returns: Массив слов.\nfunc stringToWordArray(_ str: String) -> [String] {\n    return str.split(separator: \" \").map { String($0) }\n}"
  },
  {
    "input": "func countCharactersWithoutSpaces(_ str: String) -> Int {\n    return str.replacingOccurrences(of: \" \", with: \"\").count\n}",
    "output": "/// Возвращает количество символов в строке, игнорируя пробелы.\n/// - Parameter str: Входная строка.\n/// - Returns: Количество символов без учета пробелов.\nfunc countCharactersWithoutSpaces(_ str: String) -> Int {\n    return str.replacingOccurrences(of: \" \", with: \"\").count\n}"
  },
  {
    "input": "func isSortedAscending(_ numbers: [Int]) -> Bool {\n    return numbers == numbers.sorted()\n}",
    "output": "/// Проверяет, является ли массив чисел отсортированным по возрастанию.\n/// - Parameter numbers: Массив чисел.\n/// - Returns: `true`, если массив отсортирован.\nfunc isSortedAscending(_ numbers: [Int]) -> Bool {\n    return numbers == numbers.sorted()\n}"
  },
  {
    "input": "func stringToUppercaseChars(_ str: String) -> [Character] {\n    return Array(str.uppercased())\n}",
    "output": "/// Преобразует строку в массив символов в верхнем регистре.\n/// - Parameter str: Входная строка.\n/// - Returns: Массив символов в верхнем регистре.\nfunc stringToUppercaseChars(_ str: String) -> [Character] {\n    return Array(str.uppercased())\n}"
  },
  {
    "input": "func isPalindromeIgnoringSpaces(_ str: String) -> Bool {\n    let cleaned = str.lowercased().filter { $0.isLetter }\n    return cleaned == String(cleaned.reversed())\n}",
    "output": "/// Проверяет, является ли строка палиндромом, игнорируя пробелы и регистр.\n/// - Parameter str: Входная строка.\n/// - Returns: `true`, если строка палиндром.\nfunc isPalindromeIgnoringSpaces(_ str: String) -> Bool {\n    let cleaned = str.lowercased().filter { $0.isLetter }\n    return cleaned == String(cleaned.reversed())\n}"
  },
  {
    "input": "func stringToSpaceSeparatedIntegers(_ str: String) -> [Int]? {\n    return str.split(separator: \" \").compactMap { Int($0) }\n}",
    "output": "/// Преобразует массив строк в массив чисел, разделенных пробелами.\n/// - Parameter str: Входная строка.\n/// - Returns: Массив целых чисел.\nfunc stringToSpaceSeparatedIntegers(_ str: String) -> [Int]? {\n    return str.split(separator: \" \").compactMap { Int($0) }\n}"
  },
  {
    "input": "func isBinaryString(_ str: String) -> Bool {\n    return str.allSatisfy { $0 == \"0\" || $0 == \"1\" }\n}",
    "output": "/// Проверяет, является ли строка числом в двоичной системе.\n/// - Parameter str: Входная строка.\n/// - Returns: `true`, если строка является двоичным числом.\nfunc isBinaryString(_ str: String) -> Bool {\n    return str.allSatisfy { $0 == \"0\" || $0 == \"1\" }\n}"
  },
  {
    "input": "func secondLargestNumber(_ numbers: [Int]) -> Int? {\n    let sorted = numbers.sorted(by: >)\n    return sorted.count > 1 ? sorted[1] : nil\n}",
    "output": "/// Находит второе наибольшее число в массиве.\n/// - Parameter numbers: Массив чисел.\n/// - Returns: Второе наибольшее число.\nfunc secondLargestNumber(_ numbers: [Int]) -> Int? {\n    let sorted = numbers.sorted(by: >)\n    return sorted.count > 1 ? sorted[1] : nil\n}"
  },
  {
    "input": "func stringToLowercaseChars(_ str: String) -> [Character] {\n    return Array(str.lowercased())\n}",
    "output": "/// Преобразует строку в массив символов в нижнем регистре.\n/// - Parameter str: Входная строка.\n/// - Returns: Массив символов в нижнем регистре.\nfunc stringToLowercaseChars(_ str: String) -> [Character] {\n    return Array(str.lowercased())\n}"
  },
  {
    "input": "func isArmstrongNumber(_ number: Int) -> Bool {\n    let digits = String(number).compactMap { Int(String($0)) }\n    let power = digits.count\n    let sum = digits.map { Int(pow(Double($0), Double(power))) }.reduce(0, +)\n    return sum == number\n}",
    "output": "/// Проверяет, является ли число числом Армстронга.\n/// - Parameter number: Входное число.\n/// - Returns: `true`, если число Армстронга.\nfunc isArmstrongNumber(_ number: Int) -> Bool {\n    let digits = String(number).compactMap { Int(String($0)) }\n    let power = digits.count\n    let sum = digits.map { Int(pow(Double($0), Double(power))) }.reduce(0, +)\n    return sum == number\n}"
  },
  {
    "input": "func extractDigits(_ str: String) -> [Int] {\n    return str.compactMap { $0.wholeNumberValue }\n}",
    "output": "/// Преобразует строку в массив целых чисел, извлекая только цифры.\n/// - Parameter str: Входная строка.\n/// - Returns: Массив чисел.\nfunc extractDigits(_ str: String) -> [Int] {\n    return str.compactMap { $0.wholeNumberValue }\n}"
  },
  {
    "input": "func stringToIntegerArrayWithDelimiter(_ str: String) -> [Int]? {\n    return str.split { $0 == \",\" || $0 == \" \" }.compactMap { Int($0) }\n}",
    "output": "/// Преобразует строку в массив чисел, разделенных запятыми и пробелами.\n/// - Parameter str: Входная строка.\n/// - Returns: Массив целых чисел.\nfunc stringToIntegerArrayWithDelimiter(_ str: String) -> [Int]? {\n    return str.split { $0 == \",\" || $0 == \" \" }.compactMap { Int($0) }\n}"
  },
  {
    "input": "func randomElementFromSet<T>(_ set: Set<T>) -> T? {\n    return set.randomElement()\n}",
    "output": "/// Генерирует случайный элемент из множества.\n/// - Parameter set: Множество элементов.\n/// - Returns: Случайный элемент из множества или `nil`, если множество пустое.\nfunc randomElementFromSet<T>(_ set: Set<T>) -> T? {\n    return set.randomElement()\n}"
  },
  {
    "input": "func stringToDashSeparatedCharArray(_ str: String) -> [Character] {\n    return str.split(separator: \"-\").flatMap { $0 }\n}",
    "output": "/// Преобразует строку в массив символов, разделенных тире.\n/// - Parameter str: Входная строка.\n/// - Returns: Массив символов, разделенных тире.\nfunc stringToDashSeparatedCharArray(_ str: String) -> [Character] {\n    return str.split(separator: \"-\").flatMap { $0 }\n}"
  },
  {
    "input": "func distanceBetweenPoints(x1: Double, y1: Double, x2: Double, y2: Double) -> Double {\n    return sqrt(pow(x2 - x1, 2) + pow(y2 - y1, 2))\n}",
    "output": "/// Вычисляет расстояние между двумя точками в двумерном пространстве.\n/// - Parameters:\n///   - x1: X координата первой точки.\n///   - y1: Y координата первой точки.\n///   - x2: X координата второй точки.\n///   - y2: Y координата второй точки.\n/// - Returns: Расстояние между точками.\nfunc distanceBetweenPoints(x1: Double, y1: Double, x2: Double, y2: Double) -> Double {\n    return sqrt(pow(x2 - x1, 2) + pow(y2 - y1, 2))\n}"
  },
  {
    "input": "func isHexadecimal(_ str: String) -> Bool {\n    return Int(str, radix: 16) != nil\n}",
    "output": "/// Проверяет, является ли строка числом в шестнадцатеричной системе.\n/// - Parameter str: Входная строка.\n/// - Returns: `true`, если строка представляет собой шестнадцатеричное число.\nfunc isHexadecimal(_ str: String) -> Bool {\n    return Int(str, radix: 16) != nil\n}"
  },
  {
    "input": "func isPerfectSquare(_ number: Int) -> Bool {\n    let root = sqrt(Double(number))\n    return root == floor(root)\n}",
    "output": "/// Проверяет, является ли число квадратом целого числа.\n/// - Parameter number: Входное число.\n/// - Returns: `true`, если число является квадратом целого числа.\nfunc isPerfectSquare(_ number: Int) -> Bool {\n    let root = sqrt(Double(number))\n    return root == floor(root)\n}"
  },
  {
    "input": "func stringToFloatArray(_ str: String) -> [Float]? {\n    return str.split(separator: \",\").compactMap { Float($0) }\n}",
    "output": "/// Преобразует строку в массив чисел с плавающей точкой.\n/// - Parameter str: Входная строка.\n/// - Returns: Массив чисел с плавающей точкой.\nfunc stringToFloatArray(_ str: String) -> [Float]? {\n    return str.split(separator: \",\").compactMap { Float($0) }\n}"
  },
  {
    "input": "func isBinaryNumber(_ str: String) -> Bool {\n    return str.allSatisfy { $0 == \"0\" || $0 == \"1\" }\n}",
    "output": "/// Проверяет, является ли строка числом в двоичной системе.\n/// - Parameter str: Входная строка.\n/// - Returns: `true`, если строка представляет собой двоичное число.\nfunc isBinaryNumber(_ str: String) -> Bool {\n    return str.allSatisfy { $0 == \"0\" || $0 == \"1\" }\n}"
  },
  {
    "input": "func wordsToStringWithSpaces(_ words: [String]) -> String {\n    return words.joined(separator: \" \")\n}",
    "output": "/// Преобразует массив строк в строку, разделенную пробелами.\n/// - Parameter words: Массив строк.\n/// - Returns: Объединенная строка с пробелами между словами.\nfunc wordsToStringWithSpaces(_ words: [String]) -> String {\n    return words.joined(separator: \" \")\n}"
  },
  {
    "input": "func extractNumbersFromString(_ str: String) -> [Int] {\n    return str.compactMap { $0.wholeNumberValue }\n}",
    "output": "/// Преобразует строку в массив целых чисел, игнорируя символы, которые не являются цифрами.\n/// - Parameter str: Входная строка.\n/// - Returns: Массив целых чисел.\nfunc extractNumbersFromString(_ str: String) -> [Int] {\n    return str.compactMap { $0.wholeNumberValue }\n}"
  },
  {
    "input": "func maxFloatValue(_ numbers: [Float]) -> Float? {\n    return numbers.max()\n}",
    "output": "/// Находит наибольшее число в массиве чисел с плавающей точкой.\n/// - Parameter numbers: Массив чисел с плавающей точкой.\n/// - Returns: Наибольшее число в массиве.\nfunc maxFloatValue(_ numbers: [Float]) -> Float? {\n    return numbers.max()\n}"
  },
  {
    "input": "func stringToFixedLengthCharArray(_ str: String, length: Int) -> [String] {\n    return str.map { String($0).padding(toLength: length, withPad: \" \", startingAt: 0) }\n}",
    "output": "/// Преобразует строку в массив символов с заданной длиной.\n/// - Parameters:\n///   - str: Входная строка.\n///   - length: Длина каждого символа.\n/// - Returns: Массив строк с символами фиксированной длины.\nfunc stringToFixedLengthCharArray(_ str: String, length: Int) -> [String] {\n    return str.map { String($0).padding(toLength: length, withPad: \" \", startingAt: 0) }\n}"
  },
  {
    "input": "func isEmptyOrWhitespace(_ str: String) -> Bool {\n    return str.trimmingCharacters(in: .whitespaces).isEmpty\n}",
    "output": "/// Проверяет, является ли строка пустой или содержит только пробелы.\n/// - Parameter str: Входная строка.\n/// - Returns: `true`, если строка пустая или состоит только из пробелов.\nfunc isEmptyOrWhitespace(_ str: String) -> Bool {\n    return str.trimmingCharacters(in: .whitespaces).isEmpty\n}"
  },
  {
    "input": "func stringToUppercaseArray(_ str: String) -> [Character] {\n    return Array(str.uppercased())\n}",
    "output": "/// Преобразует строку в массив символов в верхнем регистре.\n/// - Parameter str: Входная строка.\n/// - Returns: Массив символов в верхнем регистре.\nfunc stringToUppercaseArray(_ str: String) -> [Character] {\n    return Array(str.uppercased())\n}"
  },
  {
    "input": "func countUniqueElements<T>(_ array: [T]) -> Int where T: Hashable {\n    return Set(array).count\n}",
    "output": "/// Возвращает количество уникальных элементов в массиве.\n/// - Parameter array: Массив элементов.\n/// - Returns: Количество уникальных элементов в массиве.\nfunc countUniqueElements<T>(_ array: [T]) -> Int where T: Hashable {\n    return Set(array).count\n}"
  },
  {
    "input": "func extractFloatsFromString(_ str: String) -> [Float] {\n    let numbers = str.split(separator: \" \").compactMap { Float($0) }\n    return numbers\n}",
    "output": "/// Преобразует строку в массив чисел с плавающей точкой, извлекая только числа.\n/// - Parameter str: Входная строка.\n/// - Returns: Массив чисел с плавающей точкой.\nfunc extractFloatsFromString(_ str: String) -> [Float] {\n    let numbers = str.split(separator: \" \").compactMap { Float($0) }\n    return numbers\n}"
  },
  {
    "input": "func generateUniqueIdentifier() -> String {\n    return UUID().uuidString\n}",
    "output": "/// Генерирует уникальный идентификатор в формате строки.\n/// - Returns: Уникальный идентификатор.\nfunc generateUniqueIdentifier() -> String {\n    return UUID().uuidString\n}"
  },
  {
    "input": "func stringToCharacterArrayWithoutSpecials(_ str: String) -> [Character] {\n    return str.filter { $0.isLetter || $0.isNumber }\n}",
    "output": "/// Преобразует строку в массив символов, игнорируя все специальные символы.\n/// - Parameter str: Входная строка.\n/// - Returns: Массив символов без специальных символов.\nfunc stringToCharacterArrayWithoutSpecials(_ str: String) -> [Character] {\n    return str.filter { $0.isLetter || $0.isNumber }\n}"
  },
  {
    "input": "func isDecimalNumber(_ str: String) -> Bool {\n    return Double(str) != nil\n}",
    "output": "/// Проверяет, является ли строка числом в десятичной системе.\n/// - Parameter str: Входная строка.\n/// - Returns: `true`, если строка представляет собой десятичное число.\nfunc isDecimalNumber(_ str: String) -> Bool {\n    return Double(str) != nil\n}"
  },
  {
    "input": "func containsKey<Key, Value>(_ dictionary: [Key: Value], key: Key) -> Bool where Key: Hashable {\n    return dictionary.keys.contains(key)\n}",
    "output": "/// Проверяет, содержит ли словарь заданный ключ.\n/// - Parameters:\n///   - dictionary: Словарь.\n///   - key: Ключ для поиска.\n/// - Returns: `true`, если словарь содержит ключ.\nfunc containsKey<Key, Value>(_ dictionary: [Key: Value], key: Key) -> Bool where Key: Hashable {\n    return dictionary.keys.contains(key)\n}"
  },
  {
    "input": "func valueForKey<Key, Value>(_ dictionary: [Key: Value], key: Key) -> Value? where Key: Hashable {\n    return dictionary[key]\n}",
    "output": "/// Получает значение для заданного ключа, если оно существует, или возвращает `nil`.\n/// - Parameters:\n///   - dictionary: Словарь.\n///   - key: Ключ для поиска.\n/// - Returns: Значение для ключа или `nil`, если ключ отсутствует.\nfunc valueForKey<Key, Value>(_ dictionary: [Key: Value], key: Key) -> Value? where Key: Hashable {\n    return dictionary[key]\n}"
  },
  {
    "input": "func keysForDuplicateValues<Key, Value>(_ dictionary: [Key: Value]) -> [Value: [Key]] where Key: Hashable {\n    var result: [Value: [Key]] = [:]\n    for (key, value) in dictionary {\n        result[value, default: []].append(key)\n    }\n    return result\n}",
    "output": "/// Возвращает все ключи, которые связаны с одинаковыми значениями в словаре.\n/// - Parameters:\n///   - dictionary: Словарь.\n/// - Returns: Словарь, где ключи — это значения исходного словаря.\nfunc keysForDuplicateValues<Key, Value>(_ dictionary: [Key: Value]) -> [Value: [Key]] where Key: Hashable {\n    var result: [Value: [Key]] = [:]\n    for (key, value) in dictionary {\n        result[value, default: []].append(key)\n    }\n    return result\n}"
  },
  {
    "input": "func filterDictionary<Key, Value>(_ dictionary: [Key: Value], condition: (Key, Value) -> Bool) -> [Key: Value] where Key: Hashable {\n    return dictionary.filter(condition)\n}",
    "output": "/// Создает новый словарь, который исключает пары ключ-значение, удовлетворяющие условию.\n/// - Parameters:\n///   - dictionary: Исходный словарь.\n///   - condition: Условие для исключения.\n/// - Returns: Новый словарь без элементов, которые не удовлетворяют условию.\nfunc filterDictionary<Key, Value>(_ dictionary: [Key: Value], condition: (Key, Value) -> Bool) -> [Key: Value] where Key: Hashable {\n    return dictionary.filter(condition)\n}"
  },
  {
    "input": "func mergeDictionaries<Key, Value>(_ dictionary1: [Key: Value], _ dictionary2: [Key: Value]) -> [Key: Value] where Key: Hashable {\n    var merged = dictionary1\n    for (key, value) in dictionary2 {\n        merged[key] = value\n    }\n    return merged\n}",
    "output": "/// Объединяет два словаря, при этом значения из второго словаря заменяют значения из первого, если ключи одинаковы.\n/// - Parameters:\n///   - dictionary1: Первый словарь.\n///   - dictionary2: Второй словарь.\n/// - Returns: Новый объединенный словарь.\nfunc mergeDictionaries<Key, Value>(_ dictionary1: [Key: Value], _ dictionary2: [Key: Value]) -> [Key: Value] where Key: Hashable {\n    var merged = dictionary1\n    for (key, value) in dictionary2 {\n        merged[key] = value\n    }\n    return merged\n}"
  },
  {
    "input": "func dictionaryToArray<Key, Value>(_ dictionary: [Key: Value]) -> [(Key, Value)] where Key: Hashable {\n    return Array(dictionary)\n}",
    "output": "/// Преобразует словарь в массив кортежей ключ-значение.\n/// - Parameter dictionary: Словарь.\n/// - Returns: Массив кортежей.\nfunc dictionaryToArray<Key, Value>(_ dictionary: [Key: Value]) -> [(Key, Value)] where Key: Hashable {\n    return Array(dictionary)\n}"
  },
  {
    "input": "func filterDictionaryByValue<Key, Value>(_ dictionary: [Key: Value], condition: (Value) -> Bool) -> [Key: Value] where Key: Hashable {\n    return dictionary.filter { condition($0.value) }\n}",
    "output": "/// Возвращает только те элементы словаря, чьи значения удовлетворяют условию.\n/// - Parameters:\n///   - dictionary: Словарь.\n///   - condition: Условие для проверки значений.\n/// - Returns: Новый словарь с отфильтрованными элементами.\nfunc filterDictionaryByValue<Key, Value>(_ dictionary: [Key: Value], condition: (Value) -> Bool) -> [Key: Value] where Key: Hashable {\n    return dictionary.filter { condition($0.value) }\n}"
  },
  {
    "input": "func valuesFromDictionary<Key, Value>(_ dictionary: [Key: Value]) -> [Value] where Key: Hashable {\n    return Array(dictionary.values)\n}",
    "output": "/// Получает все значения из словаря в виде массива.\n/// - Parameter dictionary: Словарь.\n/// - Returns: Массив значений.\nfunc valuesFromDictionary<Key, Value>(_ dictionary: [Key: Value]) -> [Value] where Key: Hashable {\n    return Array(dictionary.values)\n}"
  },
  {
    "input": "func maxValueInDictionary<Key, Value>(_ dictionary: [Key: Value], transform: (Value) -> Double) -> (Key, Value)? where Key: Hashable {\n    return dictionary.max { transform($0.value) < transform($1.value) }\n}",
    "output": "/// Находит максимальное значение по ключу в словаре.\n/// - Parameters:\n///   - dictionary: Словарь.\n///   - transform: Преобразование значения для поиска максимума.\n/// - Returns: Максимальное значение.\nfunc maxValueInDictionary<Key, Value>(_ dictionary: [Key: Value], transform: (Value) -> Double) -> (Key, Value)? where Key: Hashable {\n    return dictionary.max { transform($0.value) < transform($1.value) }\n}"
  },
  {
    "input": "func minValueInDictionary<Key, Value>(_ dictionary: [Key: Value], transform: (Value) -> Double) -> (Key, Value)? where Key: Hashable {\n    return dictionary.min { transform($0.value) < transform($1.value) }\n}",
    "output": "/// Находит минимальное значение по ключу в словаре.\n/// - Parameters:\n///   - dictionary: Словарь.\n///   - transform: Преобразование значения для поиска минимума.\n/// - Returns: Минимальное значение.\nfunc minValueInDictionary<Key, Value>(_ dictionary: [Key: Value], transform: (Value) -> Double) -> (Key, Value)? where Key: Hashable {\n    return dictionary.min { transform($0.value) < transform($1.value) }\n}"
  },
  {
    "input": "func dictionaryToJsonString<Key, Value>(_ dictionary: [Key: Value]) -> String? where Key: Hashable, Value: Codable {\n    let encoder = JSONEncoder()\n    if let data = try? encoder.encode(dictionary) {\n        return String(data: data, encoding: .utf8)\n    }\n    return nil\n}",
    "output": "/// Преобразует словарь в строку JSON.\n/// - Parameter dictionary: Словарь.\n/// - Returns: Строка JSON, если преобразование удалось.\nfunc dictionaryToJsonString<Key, Value>(_ dictionary: [Key: Value]) -> String? where Key: Hashable, Value: Codable {\n    let encoder = JSONEncoder()\n    if let data = try? encoder.encode(dictionary) {\n        return String(data: data, encoding: .utf8)\n    }\n    return nil\n}"
  },
  {
    "input": "func dictionaryWithIndexes<Key, Value>(_ dictionary: [Key: Value]) -> [Key: (Value, Int)] where Key: Hashable {\n    return Dictionary(uniqueKeysWithValues: dictionary.enumerated().map { ($1.key, ($1.value, $0)) })\n}",
    "output": "/// Создает словарь, где каждый элемент словаря является парой ключ-значение, состоящей из оригинального ключа и его индекса.\n/// - Parameter dictionary: Словарь.\n/// - Returns: Словарь с индексами элементов.\nfunc dictionaryWithIndexes<Key, Value>(_ dictionary: [Key: Value]) -> [Key: (Value, Int)] where Key: Hashable {\n    return Dictionary(uniqueKeysWithValues: dictionary.enumerated().map { ($1.key, ($1.value, $0)) })\n}"
  },
  {
    "input": "func keysToDictionary<Key, Value>(_ keys: [Key], value: Value) -> [Key: Value] where Key: Hashable {\n    return Dictionary(uniqueKeysWithValues: keys.map { ($0, value) })\n}",
    "output": "/// Преобразует массив ключей в словарь с одинаковыми значениями.\n/// - Parameters:\n///   - keys: Массив ключей.\n///   - value: Значение, которое будет присвоено всем ключам.\n/// - Returns: Новый словарь с ключами и одинаковыми значениями.\nfunc keysToDictionary<Key, Value>(_ keys: [Key], value: Value) -> [Key: Value] where Key: Hashable {\n    return Dictionary(uniqueKeysWithValues: keys.map { ($0, value) })\n}"
  },
  {
    "input": "func keysNotInSecondDictionary<Key, Value>(_ dictionary1: [Key: Value], dictionary2: [Key: Value]) -> [Key] where Key: Hashable {\n    return dictionary1.keys.filter { !dictionary2.keys.contains($0) }\n}",
    "output": "/// Возвращает список ключей, которые не содержат значения в другом словаре.\n/// - Parameters:\n///   - dictionary1: Первый словарь.\n///   - dictionary2: Второй словарь.\n/// - Returns: Список ключей, которые присутствуют в первом словаре, но отсутствуют во втором.\nfunc keysNotInSecondDictionary<Key, Value>(_ dictionary1: [Key: Value], dictionary2: [Key: Value]) -> [Key] where Key: Hashable {\n    return dictionary1.keys.filter { !dictionary2.keys.contains($0) }\n}"
  },
  {
    "input": "func arrayToDictionary<Key, Value>(_ keys: [Key], _ values: [Value]) -> [Key: Value] where Key: Hashable {\n    var dictionary: [Key: Value] = [:]\n    for (index, key) in keys.enumerated() {\n        if index < values.count {\n            dictionary[key] = values[index]\n        }\n    }\n    return dictionary\n}",
    "output": "/// Преобразует массив ключей и массив значений в словарь.\n/// - Parameters:\n///   - keys: Массив ключей.\n///   - values: Массив значений.\n/// - Returns: Словарь, который содержит пары ключ-значение.\nfunc arrayToDictionary<Key, Value>(_ keys: [Key], _ values: [Value]) -> [Key: Value] where Key: Hashable {\n    var dictionary: [Key: Value] = [:]\n    for (index, key) in keys.enumerated() {\n        if index < values.count {\n            dictionary[key] = values[index]\n        }\n    }\n    return dictionary\n}"
  },
  {
    "input": "func dictionaryToStringArray<Key, Value>(_ dictionary: [Key: Value]) -> [String] where Key: Hashable {\n    return dictionary.map { \"\\($0.key): \\($0.value)\" }\n}",
    "output": "/// Преобразует словарь в массив строк в формате \"ключ: значение\".\n/// - Parameter dictionary: Словарь.\n/// - Returns: Массив строк в формате \"ключ: значение\".\nfunc dictionaryToStringArray<Key, Value>(_ dictionary: [Key: Value]) -> [String] where Key: Hashable {\n    return dictionary.map { \"\\($0.key): \\($0.value)\" }\n}"
  },
  {
    "input": "func transformValues<Key, Value>(_ dictionary: [Key: Value], transform: (Value) -> Value) -> [Key: Value] where Key: Hashable {\n    return dictionary.mapValues(transform)\n}",
    "output": "/// Возвращает новый словарь, где значения изменены с помощью указанной функции.\n/// - Parameters:\n///   - dictionary: Исходный словарь.\n///   - transform: Функция для преобразования значений.\n/// - Returns: Новый словарь с преобразованными значениями.\nfunc transformValues<Key, Value>(_ dictionary: [Key: Value], transform: (Value) -> Value) -> [Key: Value] where Key: Hashable {\n    return dictionary.mapValues(transform)\n}"
  },
  {
    "input": "func stringToArrayBySeparators(_ str: String) -> [String] {\n    return str.split { !$0.isLetter && !$0.isNumber }.map { String($0) }\n}",
    "output": "/// Преобразует строку в массив слов, разделенных пробелами или другими разделителями.\n/// - Parameter str: Входная строка.\n/// - Returns: Массив слов.\nfunc stringToArrayBySeparators(_ str: String) -> [String] {\n    return str.split { !$0.isLetter && !$0.isNumber }.map { String($0) }\n}"
  },
  {
    "input": "func mostFrequentValue<Key, Value>(_ dictionary: [Key: Value]) -> Value? where Value: Hashable {\n    let frequencies = dictionary.values.reduce(into: [:]) { counts, value in\n        counts[value, default: 0] += 1\n    }\n    return frequencies.max { $0.value < $1.value }?.key\n}",
    "output": "/// Находит значение, которое встречается чаще всего в словаре по значениям.\n/// - Parameter dictionary: Словарь с ключами и значениями.\n/// - Returns: Значение, которое встречается чаще всего.\nfunc mostFrequentValue<Key, Value>(_ dictionary: [Key: Value]) -> Value? where Value: Hashable {\n    let frequencies = dictionary.values.reduce(into: [:]) { counts, value in\n        counts[value, default: 0] += 1\n    }\n    return frequencies.max { $0.value < $1.value }?.key\n}"
  },
  {
    "input": "func uniqueDictionaryFromArrays<Key, Value>(_ keys: [Key], _ values: [Value]) -> [Key: Value] where Key: Hashable {\n    var dict: [Key: Value] = [:]\n    for (index, key) in keys.enumerated() {\n        if index < values.count {\n            dict[key] = values[index]\n        }\n    }\n    return dict\n}",
    "output": "/// Генерирует словарь с уникальными значениями из двух массивов ключей и значений.\n/// - Parameters:\n///   - keys: Массив ключей.\n///   - values: Массив значений.\n/// - Returns: Новый словарь.\nfunc uniqueDictionaryFromArrays<Key, Value>(_ keys: [Key], _ values: [Value]) -> [Key: Value] where Key: Hashable {\n    var dict: [Key: Value] = [:]\n    for (index, key) in keys.enumerated() {\n        if index < values.count {\n            dict[key] = values[index]\n        }\n    }\n    return dict\n}"
  },
  {
    "input": "func countUniqueValues<Key, Value>(_ dictionary: [Key: Value]) -> Int where Value: Hashable {\n    return Set(dictionary.values).count\n}",
    "output": "/// Возвращает количество уникальных значений в словаре.\n/// - Parameter dictionary: Словарь.\n/// - Returns: Количество уникальных значений в словаре.\nfunc countUniqueValues<Key, Value>(_ dictionary: [Key: Value]) -> Int where Value: Hashable {\n    return Set(dictionary.values).count\n}"
  },
  {
    "input": "func valuesToArray<Key, Value>(_ dictionary: [Key: Value]) -> [Value] where Key: Hashable {\n    return Array(dictionary.values)\n}",
    "output": "/// Извлекает все значения из словаря и преобразует их в массив.\n/// - Parameter dictionary: Словарь.\n/// - Returns: Массив значений.\nfunc valuesToArray<Key, Value>(_ dictionary: [Key: Value]) -> [Value] where Key: Hashable {\n    return Array(dictionary.values)\n}"
  },
  {
    "input": "func combineDictionaries<Key, Value>(_ dict1: [Key: Value], _ dict2: [Key: Value]) -> [Key: Value] where Key: Hashable {\n    var combined = dict1\n    for (key, value) in dict2 {\n        combined[key] = value\n    }\n    return combined\n}",
    "output": "/// Объединяет два словаря, при этом элементы из второго словаря заменяют элементы из первого, если они совпадают по ключу.\n/// - Parameters:\n///   - dict1: Первый словарь.\n///   - dict2: Второй словарь.\n/// - Returns: Объединенный словарь.\nfunc combineDictionaries<Key, Value>(_ dict1: [Key: Value], _ dict2: [Key: Value]) -> [Key: Value] where Key: Hashable {\n    var combined = dict1\n    for (key, value) in dict2 {\n        combined[key] = value\n    }\n    return combined\n}"
  },
  {
    "input": "func incrementValues<Key>(_ dictionary: [Key: Int], by increment: Int) -> [Key: Int] where Key: Hashable {\n    return dictionary.mapValues { $0 + increment }\n}",
    "output": "/// Возвращает новый словарь, где все значения увеличены на заданную величину.\n/// - Parameters:\n///   - dictionary: Исходный словарь.\n///   - increment: Величина увеличения.\n/// - Returns: Новый словарь с увеличенными значениями.\nfunc incrementValues<Key>(_ dictionary: [Key: Int], by increment: Int) -> [Key: Int] where Key: Hashable {\n    return dictionary.mapValues { $0 + increment }\n}"
  },
  {
    "input": "func isDictionaryEmpty<Key, Value>(_ dictionary: [Key: Value]) -> Bool where Key: Hashable {\n    return dictionary.isEmpty\n}",
    "output": "/// Проверяет, является ли словарь пустым.\n/// - Parameter dictionary: Словарь.\n/// - Returns: `true`, если словарь пуст.\nfunc isDictionaryEmpty<Key, Value>(_ dictionary: [Key: Value]) -> Bool where Key: Hashable {\n    return dictionary.isEmpty\n}"
  },
  {
    "input": "func dictionaryToTupleArray<Key, Value>(_ dictionary: [Key: Value]) -> [(Key, Value)] where Key: Hashable {\n    return Array(dictionary)\n}",
    "output": "/// Преобразует словарь в массив кортежей, где каждый кортеж представляет собой пару \"ключ-значение\".\n/// - Parameter dictionary: Словарь.\n/// - Returns: Массив кортежей.\nfunc dictionaryToTupleArray<Key, Value>(_ dictionary: [Key: Value]) -> [(Key, Value)] where Key: Hashable {\n    return Array(dictionary)\n}"
  },
  {
    "input": "func dictionaryToString<Key, Value>(_ dictionary: [Key: Value]) -> String where Key: Hashable {\n    return dictionary.map { \"\\($0.key): \\($0.value)\" }.joined(separator: \", \")\n}",
    "output": "/// Преобразует словарь в строку с форматом \"ключ: значение\", разделенную запятыми.\n/// - Parameter dictionary: Словарь.\n/// - Returns: Строка в формате \"ключ: значение\".\nfunc dictionaryToString<Key, Value>(_ dictionary: [Key: Value]) -> String where Key: Hashable {\n    return dictionary.map { \"\\($0.key): \\($0.value)\" }.joined(separator: \", \")\n}"
  },
  {
    "input": "func valuesForKeys<Key, Value>(_ dictionary: [Key: Value], keys: [Key]) -> [Value?] where Key: Hashable {\n    return keys.map { dictionary[$0] }\n}",
    "output": "/// Преобразует массив ключей в массив значений из словаря.\n/// - Parameters:\n///   - dictionary: Словарь.\n///   - keys: Массив ключей.\n/// - Returns: Массив значений для указанных ключей.\nfunc valuesForKeys<Key, Value>(_ dictionary: [Key: Value], keys: [Key]) -> [Value?] where Key: Hashable {\n    return keys.map { dictionary[$0] }\n}"
  },
  {
    "input": "func stringsToLengthDictionary(_ strings: [String]) -> [String: Int] {\n    return Dictionary(uniqueKeysWithValues: strings.map { ($0, $0.count) })\n}",
    "output": "/// Преобразует строки в словарь, где каждый ключ — это строка, а значение — это длина строки.\n/// - Parameter strings: Массив строк.\n/// - Returns: Словарь, где ключ — это строка, а значение — длина строки.\nfunc stringsToLengthDictionary(_ strings: [String]) -> [String: Int] {\n    return Dictionary(uniqueKeysWithValues: strings.map { ($0, $0.count) })\n}"
  },
  {
    "input": "func keysWithValuesGreaterThanThreshold<Key, Value>(_ dictionary: [Key: Value], threshold: Value) -> [Key] where Key: Hashable, Value: Comparable {\n    return dictionary.filter { $0.value > threshold }.map { $0.key }\n}",
    "output": "/// Извлекает ключи, для которых значения больше заданного порога.\n/// - Parameters:\n///   - dictionary: Словарь.\n///   - threshold: Пороговое значение.\n/// - Returns: Массив ключей, чьи значения больше порога.\nfunc keysWithValuesGreaterThanThreshold<Key, Value>(_ dictionary: [Key: Value], threshold: Value) -> [Key] where Key: Hashable, Value: Comparable {\n    return dictionary.filter { $0.value > threshold }.map { $0.key }\n}"
  },
  {
    "input": "func containsValue<Key, Value>(_ dictionary: [Key: Value], value: Value) -> Bool where Key: Hashable, Value: Equatable {\n    return dictionary.values.contains(value)\n}",
    "output": "/// Проверяет, существует ли ключ с заданным значением в словаре.\n/// - Parameters:\n///   - dictionary: Словарь.\n///   - value: Значение для проверки.\n/// - Returns: `true`, если значение присутствует в словаре.\nfunc containsValue<Key, Value>(_ dictionary: [Key: Value], value: Value) -> Bool where Key: Hashable, Value: Equatable {\n    return dictionary.values.contains(value)\n}"
  },
  {
    "input": "func keyWithMinValue<Key, Value>(_ dictionary: [Key: Value]) -> Key? where Key: Hashable, Value: Comparable {\n    return dictionary.min { $0.value < $1.value }?.key\n}",
    "output": "/// Находит ключ, связанный с минимальным значением в словаре.\n/// - Parameter dictionary: Словарь.\n/// - Returns: Ключ с минимальным значением.\nfunc keyWithMinValue<Key, Value>(_ dictionary: [Key: Value]) -> Key? where Key: Hashable, Value: Comparable {\n    return dictionary.min { $0.value < $1.value }?.key\n}"
  },
  {
    "input": "func keyWithMaxValue<Key, Value>(_ dictionary: [Key: Value]) -> Key? where Key: Hashable, Value: Comparable {\n    return dictionary.max { $0.value < $1.value }?.key\n}",
    "output": "/// Находит ключ, связанный с максимальным значением в словаре.\n/// - Parameter dictionary: Словарь.\n/// - Returns: Ключ с максимальным значением.\nfunc keyWithMaxValue<Key, Value>(_ dictionary: [Key: Value]) -> Key? where Key: Hashable, Value: Comparable {\n    return dictionary.max { $0.value < $1.value }?.key\n}"
  },
  {
    "input": "func dictionaryToStringArray<Key, Value>(_ dictionary: [Key: Value]) -> [String] where Key: Hashable {\n    return dictionary.map { \"\\($0.key): \\($0.value)\" }\n}",
    "output": "/// Преобразует словарь в массив строк, где каждый элемент представляет собой пару \"ключ: значение\".\n/// - Parameter dictionary: Словарь.\n/// - Returns: Массив строк.\nfunc dictionaryToStringArray<Key, Value>(_ dictionary: [Key: Value]) -> [String] where Key: Hashable {\n    return dictionary.map { \"\\($0.key): \\($0.value)\" }\n}"
  },
  {
    "input": "func incrementDictionaryValues<Key>(_ dictionary: [Key: Int], by increment: Int) -> [Key: Int] where Key: Hashable {\n    return dictionary.mapValues { $0 + increment }\n}",
    "output": "/// Преобразует словарь в новый, где все значения инкрементируются на заданное число.\n/// - Parameters:\n///   - dictionary: Словарь.\n///   - increment: Число для инкрементации.\n/// - Returns: Новый словарь с инкрементированными значениями.\nfunc incrementDictionaryValues<Key>(_ dictionary: [Key: Int], by increment: Int) -> [Key: Int] where Key: Hashable {\n    return dictionary.mapValues { $0 + increment }\n}"
  },
  {
    "input": "func isValidFloat(_ str: String) -> Bool {\n    return Float(str) != nil\n}",
    "output": "/// Проверяет, является ли строка валидным числом с плавающей точкой.\n/// - Parameter str: Входная строка.\n/// - Returns: `true`, если строка является числом с плавающей точкой.\nfunc isValidFloat(_ str: String) -> Bool {\n    return Float(str) != nil\n}"
  },
  {
    "input": "func stringToCommaSeparatedIntegers(_ str: String) -> [Int] {\n    return str.split(separator: \",\").compactMap { Int($0) }\n}",
    "output": "/// Преобразует строку в массив целых чисел, разделенных запятыми.\n/// - Parameter str: Входная строка.\n/// - Returns: Массив целых чисел, извлеченных из строки.\nfunc stringToCommaSeparatedIntegers(_ str: String) -> [Int] {\n    return str.split(separator: \",\").compactMap { Int($0) }\n}"
  },
  {
    "input": "func isBlankString(_ str: String) -> Bool {\n    return str.trimmingCharacters(in: .whitespaces).isEmpty\n}",
    "output": "/// Проверяет, является ли строка пустой или состоит только из пробелов.\n/// - Parameter str: Входная строка.\n/// - Returns: `true`, если строка пуста или состоит только из пробелов.\nfunc isBlankString(_ str: String) -> Bool {\n    return str.trimmingCharacters(in: .whitespaces).isEmpty\n}"
  },
  {
    "input": "func stringToFloatArray(_ str: String) -> [Float] {\n    return str.split(separator: \",\").compactMap { Float($0) }\n}",
    "output": "/// Преобразует строку в массив чисел с плавающей точкой.\n/// - Parameter str: Входная строка.\n/// - Returns: Массив чисел с плавающей точкой.\nfunc stringToFloatArray(_ str: String) -> [Float] {\n    return str.split(separator: \",\").compactMap { Float($0) }\n}"
  },
  {
    "input": "func stringToCharacterArrayFromWords(_ str: String) -> [Character] {\n    return str.split { $0 == \" \" || $0 == \",\" }.flatMap { $0 }\n}",
    "output": "/// Преобразует строку в массив символов, разделенных пробелами или запятыми.\n/// - Parameter str: Входная строка.\n/// - Returns: Массив символов.\nfunc stringToCharacterArrayFromWords(_ str: String) -> [Character] {\n    return str.split { $0 == \" \" || $0 == \",\" }.flatMap { $0 }\n}"
  },
  {
    "input": "func isPrimeNumber(_ number: Int) -> Bool {\n    guard number > 1 else { return false }\n    for i in 2..<number {\n        if number % i == 0 {\n            return false\n        }\n    }\n    return true\n}",
    "output": "/// Проверяет, является ли переданное число простым.\n/// - Parameter number: Число для проверки.\n/// - Returns: `true`, если число простое.\nfunc isPrimeNumber(_ number: Int) -> Bool {\n    guard number > 1 else { return false }\n    for i in 2..<number {\n        if number % i == 0 {\n            return false\n        }\n    }\n    return true\n}"
  },
  {
    "input": "func stringToUppercaseCharList(_ str: String) -> [Character] {\n    return Array(str.uppercased())\n}",
    "output": "/// Преобразует строку в список символов в верхнем регистре.\n/// - Parameter str: Входная строка.\n/// - Returns: Массив символов в верхнем регистре.\nfunc stringToUppercaseCharList(_ str: String) -> [Character] {\n    return Array(str.uppercased())\n}"
  },
  {
    "input": "func uniqueElementsFromArray<T>(_ array: [T]) -> [T] where T: Hashable {\n    return Array(Set(array))\n}",
    "output": "/// Извлекает только уникальные элементы из массива.\n/// - Parameter array: Входной массив.\n/// - Returns: Массив уникальных элементов.\nfunc uniqueElementsFromArray<T>(_ array: [T]) -> [T] where T: Hashable {\n    return Array(Set(array))\n}"
  },
  {
    "input": "func extractDigitsFromString(_ str: String) -> [Int] {\n    return str.compactMap { $0.wholeNumberValue }\n}",
    "output": "/// Преобразует строку в массив чисел, игнорируя нецифровые символы.\n/// - Parameter str: Входная строка.\n/// - Returns: Массив целых чисел.\nfunc extractDigitsFromString(_ str: String) -> [Int] {\n    return str.compactMap { $0.wholeNumberValue }\n}"
  },
  {
    "input": "func stringToArrayByWhitespaceAndDelimiters(_ str: String) -> [String] {\n    return str.split { $0.isWhitespace || $0 == \",\" || $0 == \";\" }.map { String($0) }\n}",
    "output": "/// Преобразует строку в массив строк, разделяя её по пробелам и другим разделителям.\n/// - Parameter str: Входная строка.\n/// - Returns: Массив строк.\nfunc stringToArrayByWhitespaceAndDelimiters(_ str: String) -> [String] {\n    return str.split { $0.isWhitespace || $0 == \",\" || $0 == \";\" }.map { String($0) }\n}"
  },
  {
    "input": "func isPalindromeIgnoringSpacesAndCase(_ str: String) -> Bool {\n    let cleaned = str.lowercased().filter { $0.isLetter }\n    return cleaned == String(cleaned.reversed())\n}",
    "output": "/// Проверяет, является ли строка палиндромом без учета регистра и пробелов.\n/// - Parameter str: Входная строка.\n/// - Returns: `true`, если строка является палиндромом.\nfunc isPalindromeIgnoringSpacesAndCase(_ str: String) -> Bool {\n    let cleaned = str.lowercased().filter { $0.isLetter }\n    return cleaned == String(cleaned.reversed())\n}"
  },
  {
    "input": "func intArrayToStringWithSeparator(_ array: [Int], separator: String) -> String {\n    return array.map { String($0) }.joined(separator: separator)\n}",
    "output": "/// Преобразует массив целых чисел в строку с разделителями.\n/// - Parameters:\n///   - array: Массив целых чисел.\n///   - separator: Разделитель для элементов.\n/// - Returns: Строка, содержащая элементы массива, разделённые указанным разделителем.\nfunc intArrayToStringWithSeparator(_ array: [Int], separator: String) -> String {\n    return array.map { String($0) }.joined(separator: separator)\n}"
  },
  {
    "input": "func reverseArray<T>(_ array: [T]) -> [T] {\n    return array.reversed()\n}",
    "output": "/// Возвращает элементы массива в обратном порядке.\n/// - Parameter array: Массив.\n/// - Returns: Массив в обратном порядке.\nfunc reverseArray<T>(_ array: [T]) -> [T] {\n    return array.reversed()\n}"
  },
  {
    "input": "func randomElementFromDictionary<Key, Value>(_ dictionary: [Key: Value]) -> (Key, Value)? where Key: Hashable {\n    return dictionary.randomElement()\n}",
    "output": "/// Генерирует случайный элемент из словаря по его значениям.\n/// - Parameter dictionary: Словарь.\n/// - Returns: Случайный элемент словаря.\nfunc randomElementFromDictionary<Key, Value>(_ dictionary: [Key: Value]) -> (Key, Value)? where Key: Hashable {\n    return dictionary.randomElement()\n}"
  },
  {
    "input": "func keysWithMinValues<Key, Value>(_ dictionary: [Key: Value]) -> [Key] where Key: Hashable, Value: Comparable {\n    guard let minValue = dictionary.values.min() else { return [] }\n    return dictionary.filter { $0.value == minValue }.map { $0.key }\n}",
    "output": "/// Возвращает ключи из словаря, которые связаны с минимальными значениями.\n/// - Parameter dictionary: Словарь.\n/// - Returns: Ключи с минимальными значениями.\nfunc keysWithMinValues<Key, Value>(_ dictionary: [Key: Value]) -> [Key] where Key: Hashable, Value: Comparable {\n    guard let minValue = dictionary.values.min() else { return [] }\n    return dictionary.filter { $0.value == minValue }.map { $0.key }\n}"
  },
  {
    "input": "func isFutureDate(_ date: Date) -> Bool {\n    return date > Date()\n}",
    "output": "/// Проверяет, является ли переданная дата в будущем относительно текущей.\n/// - Parameter date: Дата для проверки.\n/// - Returns: `true`, если дата в будущем.\nfunc isFutureDate(_ date: Date) -> Bool {\n    return date > Date()\n}"
  },
  {
    "input": "func stringToAlphabeticCharArray(_ str: String) -> [Character] {\n    return str.filter { $0.isLetter }\n}",
    "output": "/// Преобразует строку в массив символов, фильтруя только буквы.\n/// - Parameter str: Входная строка.\n/// - Returns: Массив символов, содержащих только буквы.\nfunc stringToAlphabeticCharArray(_ str: String) -> [Character] {\n    return str.filter { $0.isLetter }\n}"
  },
  {
    "input": "func daysBetweenDates(startDate: Date, endDate: Date) -> Int {\n    return Calendar.current.dateComponents([.day], from: startDate, to: endDate).day ?? 0\n}",
    "output": "/// Находит разницу между двумя датами в днях.\n/// - Parameters:\n///   - startDate: Начальная дата.\n///   - endDate: Конечная дата.\n/// - Returns: Количество дней между датами.\nfunc daysBetweenDates(startDate: Date, endDate: Date) -> Int {\n    return Calendar.current.dateComponents([.day], from: startDate, to: endDate).day ?? 0\n}"
  },
  {
    "input": "func sumOfNumbersInString(_ str: String) -> Int {\n    let numbers = str.split(separator: \" \").compactMap { Int($0) }\n    return numbers.reduce(0, +)\n}",
    "output": "/// Преобразует строку в массив чисел, разделенных пробелами, и возвращает сумму.\n/// - Parameter str: Входная строка.\n/// - Returns: Сумма чисел в строке.\nfunc sumOfNumbersInString(_ str: String) -> Int {\n    let numbers = str.split(separator: \" \").compactMap { Int($0) }\n    return numbers.reduce(0, +)\n}"
  },
  {
    "input": "func isHexadecimalNumber(_ str: String) -> Bool {\n    return Int(str, radix: 16) != nil\n}",
    "output": "/// Проверяет, является ли строка числом в шестнадцатеричной системе.\n/// - Parameter str: Входная строка.\n/// - Returns: `true`, если строка представляет собой шестнадцатеричное число.\nfunc isHexadecimalNumber(_ str: String) -> Bool {\n    return Int(str, radix: 16) != nil\n}"
  },
  {
    "input": "func stringToTabSeparatedArray(_ str: String) -> [String] {\n    return str.split(separator: \"\\t\").map { String($0) }\n}",
    "output": "/// Преобразует строку в массив строк, разделённых по символу табуляции.\n/// - Parameter str: Входная строка.\n/// - Returns: Массив строк, разделённых символом табуляции.\nfunc stringToTabSeparatedArray(_ str: String) -> [String] {\n    return str.split(separator: \"\\t\").map { String($0) }\n}"
  },
  {
    "input": "func isDecimalString(_ str: String) -> Bool {\n    return Double(str) != nil\n}",
    "output": "/// Проверяет, является ли строка числом в десятичной системе.\n/// - Parameter str: Входная строка.\n/// - Returns: `true`, если строка является десятичным числом.\nfunc isDecimalString(_ str: String) -> Bool {\n    return Double(str) != nil\n}"
  },
  {
    "input": "func stringToDoubleArray(_ str: String) -> [Double] {\n    return str.split(separator: \",\").compactMap { Double($0) }\n}",
    "output": "/// Преобразует строку в массив чисел с плавающей точкой.\n/// - Parameter str: Входная строка.\n/// - Returns: Массив чисел с плавающей точкой.\nfunc stringToDoubleArray(_ str: String) -> [Double] {\n    return str.split(separator: \",\").compactMap { Double($0) }\n}"
  },
  {
    "input": "func extractDigitsAsString(_ str: String) -> String {\n    return str.filter { $0.isNumber }\n}",
    "output": "/// Извлекает из строки все символы, являющиеся цифрами, и возвращает их как строку.\n/// - Parameter str: Входная строка.\n/// - Returns: Строка, состоящая только из цифр.\nfunc extractDigitsAsString(_ str: String) -> String {\n    return str.filter { $0.isNumber }\n}"
  },
  {
    "input": "func isScientificNotation(_ str: String) -> Bool {\n    let regex = \"^[-+]?[0-9]*\\\\.?[0-9]+([eE][-+]?[0-9]+)?$\"\n    return str.range(of: regex, options: .regularExpression) != nil\n}",
    "output": "/// Проверяет, является ли строка числом в научной (экспоненциальной) записи.\n/// - Parameter str: Входная строка.\n/// - Returns: `true`, если строка является числом в научной записи.\nfunc isScientificNotation(_ str: String) -> Bool {\n    let regex = \"^[-+]?[0-9]*\\\\.?[0-9]+([eE][-+]?[0-9]+)?$\"\n    return str.range(of: regex, options: .regularExpression) != nil\n}"
  },
  {
    "input": "func stringToCleanCharacterArray(_ str: String) -> [Character] {\n    return str.filter { $0.isLetter || $0.isNumber }\n}",
    "output": "/// Преобразует строку в массив символов, игнорируя все пробелы и специальные символы.\n/// - Parameter str: Входная строка.\n/// - Returns: Массив символов без пробелов и специальных символов.\nfunc stringToCleanCharacterArray(_ str: String) -> [Character] {\n    return str.filter { $0.isLetter || $0.isNumber }\n}"
  },
  {
    "input": "func isEvenNumber(_ number: Int) -> Bool {\n    return number % 2 == 0\n}",
    "output": "/// Проверяет, является ли переданное число чётным.\n/// - Parameter number: Число для проверки.\n/// - Returns: `true`, если число чётное.\nfunc isEvenNumber(_ number: Int) -> Bool {\n    return number % 2 == 0\n}"
  },
  {
    "input": "func sortStringsByLengthDescending(_ strings: [String]) -> [String] {\n    return strings.sorted { $0.count > $1.count }\n}",
    "output": "/// Сортирует массив строк в порядке убывания длины.\n/// - Parameter strings: Массив строк.\n/// - Returns: Массив строк, отсортированных по убыванию длины.\nfunc sortStringsByLengthDescending(_ strings: [String]) -> [String] {\n    return strings.sorted { $0.count > $1.count }\n}"
  },
  {
    "input": "func stringToUnicodeString(_ str: String) -> String {\n    return str.map { \"\\\\u{\\($0.asciiValue ?? 0)}\" }.joined()\n}",
    "output": "/// Преобразует строку в строку, где каждый символ заменён на его Unicode-значение.\n/// - Parameter str: Входная строка.\n/// - Returns: Строка, где каждый символ заменён на его Unicode-значение.\nfunc stringToUnicodeString(_ str: String) -> String {\n    return str.map { \"\\\\u{\\($0.asciiValue ?? 0)}\" }.joined()\n}"
  },
  {
    "input": "func stringToCommaSeparatedIntegers(_ str: String) -> [Int] {\n    return str.split(separator: \",\").compactMap { Int($0) }\n}",
    "output": "/// Преобразует строку в массив чисел, разделённых запятыми.\n/// - Parameter str: Входная строка.\n/// - Returns: Массив целых чисел.\nfunc stringToCommaSeparatedIntegers(_ str: String) -> [Int] {\n    return str.split(separator: \",\").compactMap { Int($0) }\n}"
  },
  {
    "input": "func isPalindromeIgnoringSpacesAndCase(_ str: String) -> Bool {\n    let cleaned = str.lowercased().filter { $0.isLetter }\n    return cleaned == String(cleaned.reversed())\n}",
    "output": "/// Проверяет, является ли строка палиндромом, игнорируя пробелы и регистр.\n/// - Parameter str: Входная строка.\n/// - Returns: `true`, если строка является палиндромом.\nfunc isPalindromeIgnoringSpacesAndCase(_ str: String) -> Bool {\n    let cleaned = str.lowercased().filter { $0.isLetter }\n    return cleaned == String(cleaned.reversed())\n}"
  },
  {
    "input": "func sumOfNumbersInString(_ str: String) -> Double {\n    let numbers = str.split(separator: \" \").compactMap { Double($0) }\n    return numbers.reduce(0, +)\n}",
    "output": "/// Преобразует строку в массив чисел с плавающей точкой и возвращает их сумму.\n/// - Parameter str: Входная строка.\n/// - Returns: Сумма чисел в строке.\nfunc sumOfNumbersInString(_ str: String) -> Double {\n    let numbers = str.split(separator: \" \").compactMap { Double($0) }\n    return numbers.reduce(0, +)\n}"
  },
  {
    "input": "func stringToTabbedAndSpaceSeparatedCharArray(_ str: String) -> [Character] {\n    return str.split { $0 == \"\\t\" || $0 == \" \" }.flatMap { $0 }\n}",
    "output": "/// Преобразует строку в массив символов, разделённых символами табуляции и пробела.\n/// - Parameter str: Входная строка.\n/// - Returns: Массив символов, разделённых табуляцией и пробелами.\nfunc stringToTabbedAndSpaceSeparatedCharArray(_ str: String) -> [Character] {\n    return str.split { $0 == \"\\t\" || $0 == \" \" }.flatMap { $0 }\n}"
  },
  {
    "input": "func productOfNumbersInString(_ str: String) -> Double {\n    let numbers = str.split(separator: \" \").compactMap { Double($0) }\n    return numbers.reduce(1, *)\n}",
    "output": "/// Преобразует строку в массив чисел с плавающей точкой и возвращает их произведение.\n/// - Parameter str: Входная строка.\n/// - Returns: Произведение чисел в строке.\nfunc productOfNumbersInString(_ str: String) -> Double {\n    let numbers = str.split(separator: \" \").compactMap { Double($0) }\n    return numbers.reduce(1, *)\n}"
  },
  {
    "input": "func isValidIPv4(_ ip: String) -> Bool {\n    let components = ip.split(separator: \".\")\n    guard components.count == 4 else { return false }\n    return components.allSatisfy { component in\n        if let num = Int(component), num >= 0, num <= 255 {\n            return true\n        }\n        return false\n    }\n}",
    "output": "/// Проверяет, является ли строка допустимым IP-адресом версии 4.\n/// - Parameter ip: Входная строка.\n/// - Returns: `true`, если строка является валидным IPv4-адресом.\nfunc isValidIPv4(_ ip: String) -> Bool {\n    let components = ip.split(separator: \".\")\n    guard components.count == 4 else { return false }\n    return components.allSatisfy { component in\n        if let num = Int(component), num >= 0, num <= 255 {\n            return true\n        }\n        return false\n    }\n}"
  },
  {
    "input": "func stringToSemicolonSeparatedDoubles(_ str: String) -> [Double] {\n    return str.split(separator: \";\").compactMap { Double($0) }\n}",
    "output": "/// Преобразует строку в массив чисел с плавающей точкой, разделённых точкой с запятой.\n/// - Parameter str: Входная строка.\n/// - Returns: Массив чисел с плавающей точкой.\nfunc stringToSemicolonSeparatedDoubles(_ str: String) -> [Double] {\n    return str.split(separator: \";\").compactMap { Double($0) }\n}"
  },
  {
    "input": "func elementsInFirstNotInSecond<T>(_ array1: [T], _ array2: [T]) -> [T] where T: Hashable {\n    return Array(Set(array1).subtracting(array2))\n}",
    "output": "/// Возвращает массив элементов, которые присутствуют в одном массиве, но отсутствуют в другом.\n/// - Parameters:\n///   - array1: Первый массив.\n///   - array2: Второй массив.\n/// - Returns: Массив элементов, присутствующих в первом, но отсутствующих во втором.\nfunc elementsInFirstNotInSecond<T>(_ array1: [T], _ array2: [T]) -> [T] where T: Hashable {\n    return Array(Set(array1).subtracting(array2))\n}"
  },
  {
    "input": "func generateRandomString(ofLength length: Int) -> String {\n    let characters = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\"\n    return String((0..<length).compactMap { _ in characters.randomElement() })\n}",
    "output": "/// Генерирует случайную строку заданной длины, состоящую из букв и цифр.\n/// - Parameter length: Длина строки.\n/// - Returns: Случайная строка.\nfunc generateRandomString(ofLength length: Int) -> String {\n    let characters = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\"\n    return String((0..<length).compactMap { _ in characters.randomElement() })\n}"
  },
  {
    "input": "func stringToSpaceSeparatedCharArray(_ str: String) -> [Character] {\n    return str.split(separator: \" \").flatMap { $0 }\n}",
    "output": "/// Преобразует строку в массив символов, разделённых пробелами.\n/// - Parameter str: Входная строка.\n/// - Returns: Массив символов.\nfunc stringToSpaceSeparatedCharArray(_ str: String) -> [Character] {\n    return str.split(separator: \" \").flatMap { $0 }\n}"
  },
  {
    "input": "func isBinaryString(_ str: String) -> Bool {\n    return str.allSatisfy { $0 == \"0\" || $0 == \"1\" }\n}",
    "output": "/// Проверяет, является ли строка числом в бинарной системе.\n/// - Parameter str: Входная строка.\n/// - Returns: `true`, если строка представляет собой двоичное число.\nfunc isBinaryString(_ str: String) -> Bool {\n    return str.allSatisfy { $0 == \"0\" || $0 == \"1\" }\n}"
  },
  {
    "input": "func averageOfNumbersInString(_ str: String) -> Double {\n    let numbers = str.split(separator: \" \").compactMap { Double($0) }\n    return numbers.reduce(0, +) / Double(numbers.count)\n}",
    "output": "/// Преобразует строку в массив чисел с плавающей точкой и возвращает среднее значение.\n/// - Parameter str: Входная строка.\n/// - Returns: Среднее значение чисел в строке.\nfunc averageOfNumbersInString(_ str: String) -> Double {\n    let numbers = str.split(separator: \" \").compactMap { Double($0) }\n    return numbers.reduce(0, +) / Double(numbers.count)\n}"
  },
  {
    "input": "func stringToArrayBySpacesAndCommas(_ str: String) -> [Int] {\n    return str.split { $0 == \" \" || $0 == \",\" }.compactMap { Int($0) }\n}",
    "output": "/// Преобразует строку в массив целых чисел, разделённых пробелами или запятыми.\n/// - Parameter str: Входная строка.\n/// - Returns: Массив целых чисел.\nfunc stringToArrayBySpacesAndCommas(_ str: String) -> [Int] {\n    return str.split { $0 == \" \" || $0 == \",\" }.compactMap { Int($0) }\n}"
  },
  {
    "input": "func isValidIPv6(_ ip: String) -> Bool {\n    let regex = \"^([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}$\"\n    return ip.range(of: regex, options: .regularExpression) != nil\n}",
    "output": "/// Проверяет, является ли строка допустимым IP-адресом версии 6.\n/// - Parameter ip: Входная строка.\n/// - Returns: `true`, если строка является валидным IPv6-адресом.\nfunc isValidIPv6(_ ip: String) -> Bool {\n    let regex = \"^([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}$\"\n    return ip.range(of: regex, options: .regularExpression) != nil\n}"
  },
  {
    "input": "func stringToDelimitedCharArray(_ str: String) -> [Character] {\n    return str.split { $0 == \" \" || $0 == \";\" }.flatMap { $0 }\n}",
    "output": "/// Преобразует строку в массив символов, разделённых пробелами или точками с запятой.\n/// - Parameter str: Входная строка.\n/// - Returns: Массив символов.\nfunc stringToDelimitedCharArray(_ str: String) -> [Character] {\n    return str.split { $0 == \" \" || $0 == \";\" }.flatMap { $0 }\n}"
  },
  {
    "input": "func stringToAlphabeticCharArray(_ str: String) -> [Character] {\n    return str.filter { $0.isLetter }\n}",
    "output": "/// Преобразует строку в массив символов, исключая пробелы и символы препинания.\n/// - Parameter str: Входная строка.\n/// - Returns: Массив символов без пробелов и препинания.\nfunc stringToAlphabeticCharArray(_ str: String) -> [Character] {\n    return str.filter { $0.isLetter }\n}"
  },
  {
    "input": "func stringToSemicolonSeparatedIntegers(_ str: String) -> [Int] {\n    return str.split(separator: \";\").compactMap { Int($0) }\n}",
    "output": "/// Преобразует строку в массив целых чисел, разделённых точками с запятой.\n/// - Parameter str: Входная строка.\n/// - Returns: Массив целых чисел.\nfunc stringToSemicolonSeparatedIntegers(_ str: String) -> [Int] {\n    return str.split(separator: \";\").compactMap { Int($0) }\n}"
  },
  {
    "input": "func maxFloatInArray(_ numbers: [Float]) -> Float? {\n    return numbers.max()\n}",
    "output": "/// Находит наибольшее число в массиве чисел с плавающей точкой.\n/// - Parameter numbers: Массив чисел с плавающей точкой.\n/// - Returns: Наибольшее число в массиве.\nfunc maxFloatInArray(_ numbers: [Float]) -> Float? {\n    return numbers.max()\n}"
  },
  {
    "input": "func stringToTabSeparatedIntegers(_ str: String) -> [Int] {\n    return str.split(separator: \"\\t\").compactMap { Int($0) }\n}",
    "output": "/// Преобразует строку в массив целых чисел, разделённых символами табуляции.\n/// - Parameter str: Входная строка.\n/// - Returns: Массив целых чисел.\nfunc stringToTabSeparatedIntegers(_ str: String) -> [Int] {\n    return str.split(separator: \"\\t\").compactMap { Int($0) }\n}"
  },
  {
    "input": "func stringToFloatArrayBySpaces(_ str: String) -> [Float] {\n    return str.split(separator: \" \").compactMap { Float($0) }\n}",
    "output": "/// Преобразует строку в массив чисел с плавающей точкой, разделённых пробелами.\n/// - Parameter str: Входная строка.\n/// - Returns: Массив чисел с плавающей точкой.\nfunc stringToFloatArrayBySpaces(_ str: String) -> [Float] {\n    return str.split(separator: \" \").compactMap { Float($0) }\n}"
  },
  {
    "input": "func isScientificNumber(_ str: String) -> Bool {\n    return Double(str) != nil\n}",
    "output": "/// Проверяет, является ли строка числом с плавающей точкой в экспоненциальной записи.\n/// - Parameter str: Входная строка.\n/// - Returns: `true`, если строка представляет собой число с плавающей точкой в экспоненциальной записи.\nfunc isScientificNumber(_ str: String) -> Bool {\n    return Double(str) != nil\n}"
  },
  {
    "input": "func stringToCharArrayWithoutDigits(_ str: String) -> [Character] {\n    return str.filter { !$0.isNumber }\n}",
    "output": "/// Преобразует строку в массив символов, игнорируя пробелы и цифры.\n/// - Parameter str: Входная строка.\n/// - Returns: Массив символов без пробелов и цифр.\nfunc stringToCharArrayWithoutDigits(_ str: String) -> [Character] {\n    return str.filter { !$0.isNumber }\n}"
  },
  {
    "input": "func generateRandomAlphaNumericString(length: Int) -> String {\n    let characters = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\"\n    return String((0..<length).compactMap { _ in characters.randomElement() })\n}",
    "output": "/// Генерирует случайную строку заданной длины, состоящую из символов латинского алфавита и цифр.\n/// - Parameter length: Длина строки.\n/// - Returns: Случайная строка.\nfunc generateRandomAlphaNumericString(length: Int) -> String {\n    let characters = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\"\n    return String((0..<length).compactMap { _ in characters.randomElement() })\n}"
  },
  {
    "input": "func stringToCharArrayWithSpaces(_ str: String) -> [Character] {\n    return Array(str)\n}",
    "output": "/// Преобразует строку в массив символов с сохранением всех пробелов.\n/// - Parameter str: Входная строка.\n/// - Returns: Массив символов, включая пробелы.\nfunc stringToCharArrayWithSpaces(_ str: String) -> [Character] {\n    return Array(str)\n}"
  },
  {
    "input": "func uniqueElementsFromTwoArrays<T>(_ array1: [T], _ array2: [T]) -> [T] where T: Hashable {\n    return Array(Set(array1).union(Set(array2)))\n}",
    "output": "/// Возвращает уникальные элементы из двух массивов.\n/// - Parameters:\n///   - array1: Первый массив.\n///   - array2: Второй массив.\n/// - Returns: Массив уникальных элементов.\nfunc uniqueElementsFromTwoArrays<T>(_ array1: [T], _ array2: [T]) -> [T] where T: Hashable {\n    return Array(Set(array1).union(Set(array2)))\n}"
  },
  {
    "input": "func stringToFloatArrayWithCommasAndSpaces(_ str: String) -> [Float] {\n    return str.split { $0 == \" \" || $0 == \",\" }.compactMap { Float($0) }\n}",
    "output": "/// Преобразует строку в массив чисел с плавающей точкой, разделённых пробелами и запятыми.\n/// - Parameter str: Входная строка.\n/// - Returns: Массив чисел с плавающей точкой.\nfunc stringToFloatArrayWithCommasAndSpaces(_ str: String) -> [Float] {\n    return str.split { $0 == \" \" || $0 == \",\" }.compactMap { Float($0) }\n}"
  },
  {
    "input": "func stringToAlphanumericCharArray(_ str: String) -> [Character] {\n    return str.filter { $0.isLetter || $0.isNumber }\n}",
    "output": "/// Преобразует строку в массив символов, игнорируя все специальные символы.\n/// - Parameter str: Входная строка.\n/// - Returns: Массив символов, содержащих только буквы и цифры.\nfunc stringToAlphanumericCharArray(_ str: String) -> [Character] {\n    return str.filter { $0.isLetter || $0.isNumber }\n}"
  },
  {
    "input": "func stringToArrayWithSpaceAndSemicolonSeparators(_ str: String) -> [Int] {\n    return str.split { $0 == \" \" || $0 == \";\" }.compactMap { Int($0) }\n}",
    "output": "/// Преобразует строку в массив целых чисел, разделённых пробелами и точками с запятой.\n/// - Parameter str: Входная строка.\n/// - Returns: Массив целых чисел.\nfunc stringToArrayWithSpaceAndSemicolonSeparators(_ str: String) -> [Int] {\n    return str.split { $0 == \" \" || $0 == \";\" }.compactMap { Int($0) }\n}"
  },
  {
    "input": "func stringToFloatArrayWithSpaceAndSemicolon(_ str: String) -> [Float] {\n    return str.split { $0 == \" \" || $0 == \";\" }.compactMap { Float($0) }\n}",
    "output": "/// Преобразует строку в массив чисел с плавающей точкой, разделённых пробелами и точками с запятой.\n/// - Parameter str: Входная строка.\n/// - Returns: Массив чисел с плавающей точкой.\nfunc stringToFloatArrayWithSpaceAndSemicolon(_ str: String) -> [Float] {\n    return str.split { $0 == \" \" || $0 == \";\" }.compactMap { Float($0) }\n}"
  },
  {
    "input": "func isFormattedNumber(_ str: String) -> Bool {\n    let regex = \"^[0-9]{1,3}(?:,([0-9]{3}))*$\"\n    return str.range(of: regex, options: .regularExpression) != nil\n}",
    "output": "/// Проверяет, является ли строка строкой с числовым значением, содержащей разделитель тысяч.\n/// - Parameter str: Входная строка.\n/// - Returns: `true`, если строка является числом с разделителем тысяч.\nfunc isFormattedNumber(_ str: String) -> Bool {\n    let regex = \"^[0-9]{1,3}(?:,([0-9]{3}))*$\"\n    return str.range(of: regex, options: .regularExpression) != nil\n}"
  },
  {
    "input": "func stringToAlphabeticCharsWithoutPunctuation(_ str: String) -> [Character] {\n    return str.filter { $0.isLetter }\n}",
    "output": "/// Преобразует строку в массив символов, игнорируя все пробелы и символы препинания.\n/// - Parameter str: Входная строка.\n/// - Returns: Массив символов, исключая пробелы и препинания.\nfunc stringToAlphabeticCharsWithoutPunctuation(_ str: String) -> [Character] {\n    return str.filter { $0.isLetter }\n}"
  },
  {
    "input": "func differenceBetweenArrays<T>(_ array1: [T], _ array2: [T]) -> [T] where T: Hashable {\n    return Array(Set(array1).symmetricDifference(Set(array2)))\n}",
    "output": "/// Возвращает разницу между двумя массивами, в том числе уникальные элементы, которые присутствуют только в одном из них.\n/// - Parameters:\n///   - array1: Первый массив.\n///   - array2: Второй массив.\n/// - Returns: Массив уникальных элементов.\nfunc differenceBetweenArrays<T>(_ array1: [T], _ array2: [T]) -> [T] where T: Hashable {\n    return Array(Set(array1).symmetricDifference(Set(array2)))\n}"
  },
  {
    "input": "func averageOfFloatsInString(_ str: String) -> Double {\n    let numbers = str.split(separator: \" \").compactMap { Double($0) }\n    return numbers.isEmpty ? 0 : numbers.reduce(0, +) / Double(numbers.count)\n}",
    "output": "/// Преобразует строку в массив чисел с плавающей точкой, разделённых пробелами, и возвращает их среднее значение.\n/// - Parameter str: Входная строка.\n/// - Returns: Среднее значение чисел.\nfunc averageOfFloatsInString(_ str: String) -> Double {\n    let numbers = str.split(separator: \" \").compactMap { Double($0) }\n    return numbers.isEmpty ? 0 : numbers.reduce(0, +) / Double(numbers.count)\n}"
  },
  {
    "input": "func stringToFloatArrayWithCommaAndSpace(_ str: String) -> [Float] {\n    return str.split { $0 == \",\" || $0 == \" \" }.compactMap { Float($0) }\n}",
    "output": "/// Преобразует строку в массив чисел с плавающей точкой, разделённых запятыми и пробелами.\n/// - Parameter str: Входная строка.\n/// - Returns: Массив чисел с плавающей точкой.\nfunc stringToFloatArrayWithCommaAndSpace(_ str: String) -> [Float] {\n    return str.split { $0 == \",\" || $0 == \" \" }.compactMap { Float($0) }\n}"
  },
  {
    "input": "func randomDouble(inRange min: Double, max: Double) -> Double {\n    return Double.random(in: min...max)\n}",
    "output": "/// Генерирует случайное число с плавающей точкой в заданном диапазоне.\n/// - Parameters:\n///   - min: Минимальное значение.\n///   - max: Максимальное значение.\n/// - Returns: Случайное число с плавающей точкой.\nfunc randomDouble(inRange min: Double, max: Double) -> Double {\n    return Double.random(in: min...max)\n}"
  },
  {
    "input": "func stringToCharArrayByCommaOrSpace(_ str: String) -> [Character] {\n    return str.split { $0 == \" \" || $0 == \",\" }.flatMap { $0 }\n}",
    "output": "/// Преобразует строку в массив символов, разделённых запятыми или пробелами.\n/// - Parameter str: Входная строка.\n/// - Returns: Массив символов.\nfunc stringToCharArrayByCommaOrSpace(_ str: String) -> [Character] {\n    return str.split { $0 == \" \" || $0 == \",\" }.flatMap { $0 }\n}"
  },
  {
    "input": "func isPositiveInteger(_ number: Int) -> Bool {\n    return number > 0\n}",
    "output": "/// Проверяет, является ли переданное число целым и положительным.\n/// - Parameter number: Число для проверки.\n/// - Returns: `true`, если число положительное.\nfunc isPositiveInteger(_ number: Int) -> Bool {\n    return number > 0\n}"
  },
  {
    "input": "func stringToWordArrayBySpaces(_ str: String) -> [String] {\n    return str.split(separator: \" \").map { String($0) }\n}",
    "output": "/// Преобразует строку в массив строк, где каждый элемент состоит из слов по пробелам.\n/// - Parameter str: Входная строка.\n/// - Returns: Массив строк.\nfunc stringToWordArrayBySpaces(_ str: String) -> [String] {\n    return str.split(separator: \" \").map { String($0) }\n}"
  },
  {
    "input": "func stringToFloatArrayWithSpaceAndSemicolon(_ str: String) -> [Float] {\n    return str.split { $0 == \" \" || $0 == \";\" }.compactMap { Float($0) }\n}",
    "output": "/// Преобразует строку в массив чисел с плавающей точкой, разделённых пробелами и точками с запятой.\n/// - Parameter str: Входная строка.\n/// - Returns: Массив чисел с плавающей точкой.\nfunc stringToFloatArrayWithSpaceAndSemicolon(_ str: String) -> [Float] {\n    return str.split { $0 == \" \" || $0 == \";\" }.compactMap { Float($0) }\n}"
  },
  {
    "input": "func stringToCharArrayWithoutNumbers(_ str: String) -> [Character] {\n    return str.filter { !$0.isNumber }\n}",
    "output": "/// Преобразует строку в массив символов, разделённых пробелами, игнорируя цифры.\n/// - Parameter str: Входная строка.\n/// - Returns: Массив символов без цифр.\nfunc stringToCharArrayWithoutNumbers(_ str: String) -> [Character] {\n    return str.filter { !$0.isNumber }\n}"
  },
  {
    "input": "func keysInFirstNotInSecond<Key, Value>(_ dict1: [Key: Value], dict2: [Key: Value]) -> [Key] where Key: Hashable {\n    return Array(dict1.keys.filter { !dict2.keys.contains($0) })\n}",
    "output": "/// Возвращает ключи, которые не содержатся в другом словаре.\n/// - Parameters:\n///   - dict1: Первый словарь.\n///   - dict2: Второй словарь.\n/// - Returns: Массив ключей, которые присутствуют в первом, но отсутствуют во втором.\nfunc keysInFirstNotInSecond<Key, Value>(_ dict1: [Key: Value], dict2: [Key: Value]) -> [Key] where Key: Hashable {\n    return Array(dict1.keys.filter { !dict2.keys.contains($0) })\n}"
  },
  {
    "input": "func floatArrayToString(_ numbers: [Float]) -> String {\n    return numbers.map { String($0) }.joined(separator: \" \")\n}",
    "output": "/// Возвращает строку, составленную из чисел с плавающей точкой, разделённых пробелами.\n/// - Parameter numbers: Массив чисел.\n/// - Returns: Строка с числами.\nfunc floatArrayToString(_ numbers: [Float]) -> String {\n    return numbers.map { String($0) }.joined(separator: \" \")\n}"
  },
  {
    "input": "func generateRandomIntegers(length: Int, min: Int, max: Int) -> [Int] {\n    return (0..<length).map { _ in Int.random(in: min...max) }\n}",
    "output": "/// Генерирует массив случайных чисел заданной длины в определённом диапазоне.\n/// - Parameters:\n///   - length: Длина массива.\n///   - min: Минимальное значение.\n///   - max: Максимальное значение.\n/// - Returns: Массив случайных чисел.\nfunc generateRandomIntegers(length: Int, min: Int, max: Int) -> [Int] {\n    return (0..<length).map { _ in Int.random(in: min...max) }\n}"
  },
  {
    "input": "func containsUppercaseLetter(_ str: String) -> Bool {\n    return str.contains { $0.isUppercase }\n}",
    "output": "/// Проверяет, содержит ли строка хотя бы одну заглавную букву.\n/// - Parameter str: Входная строка.\n/// - Returns: `true`, если строка содержит хотя бы одну заглавную букву.\nfunc containsUppercaseLetter(_ str: String) -> Bool {\n    return str.contains { $0.isUppercase }\n}"
  },
  {
    "input": "func mostFrequentElement<T: Hashable>(_ array: [T]) -> T? {\n    let frequencies = array.reduce(into: [:]) { counts, item in\n        counts[item, default: 0] += 1\n    }\n    return frequencies.max { $0.value < $1.value }?.key\n}",
    "output": "/// Возвращает элемент, который встречается чаще всего в массиве.\n/// - Parameter array: Массив элементов.\n/// - Returns: Элемент, который встречается чаще всего.\nfunc mostFrequentElement<T: Hashable>(_ array: [T]) -> T? {\n    let frequencies = array.reduce(into: [:]) { counts, item in\n        counts[item, default: 0] += 1\n    }\n    return frequencies.max { $0.value < $1.value }?.key\n}"
  },
  {
    "input": "func stringToFloatArrayByDots(_ str: String) -> [Float] {\n    return str.split(separator: \".\").compactMap { Float($0) }\n}",
    "output": "/// Преобразует строку в массив чисел с плавающей точкой, разделённых точками.\n/// - Parameter str: Входная строка.\n/// - Returns: Массив чисел с плавающей точкой.\nfunc stringToFloatArrayByDots(_ str: String) -> [Float] {\n    return str.split(separator: \".\").compactMap { Float($0) }\n}"
  },
  {
    "input": "func stringToCleanCharArray(_ str: String) -> [Character] {\n    return str.filter { $0.isLetter }\n}",
    "output": "/// Преобразует строку в массив символов, исключая пробелы и знаки препинания.\n/// - Parameter str: Входная строка.\n/// - Returns: Массив символов без пробелов и знаков препинания.\nfunc stringToCleanCharArray(_ str: String) -> [Character] {\n    return str.filter { $0.isLetter }\n}"
  },
  {
    "input": "func stringToFloatArrayWithDotAndComma(_ str: String) -> [Float] {\n    return str.split { $0 == \",\" || $0 == \".\" }.compactMap { Float($0) }\n}",
    "output": "/// Преобразует строку в массив чисел с плавающей точкой, разделённых точками и запятыми.\n/// - Parameter str: Входная строка.\n/// - Returns: Массив чисел с плавающей точкой.\nfunc stringToFloatArrayWithDotAndComma(_ str: String) -> [Float] {\n    return str.split { $0 == \",\" || $0 == \".\" }.compactMap { Float($0) }\n}"
  },
  {
    "input": "func stringToIntegerArrayByColon(_ str: String) -> [Int] {\n    return str.split(separator: \":\").compactMap { Int($0) }\n}",
    "output": "/// Преобразует строку в массив целых чисел, разделённых двоеточиями.\n/// - Parameter str: Входная строка.\n/// - Returns: Массив целых чисел.\nfunc stringToIntegerArrayByColon(_ str: String) -> [Int] {\n    return str.split(separator: \":\").compactMap { Int($0) }\n}"
  },
  {
    "input": "func isFixedPointNumber(_ str: String) -> Bool {\n    let regex = \"^[-+]?\\\\d+\\\\.(\\\\d+)$\"\n    return str.range(of: regex, options: .regularExpression) != nil\n}",
    "output": "/// Проверяет, является ли строка числом с фиксированной запятой.\n/// - Parameter str: Входная строка.\n/// - Returns: `true`, если строка является числом с фиксированной запятой.\nfunc isFixedPointNumber(_ str: String) -> Bool {\n    let regex = \"^[-+]?\\\\d+\\\\.(\\\\d+)$\"\n    return str.range(of: regex, options: .regularExpression) != nil\n}"
  },
  {
    "input": "func stringToAlphabeticCharArrayWithoutDigits(_ str: String) -> [Character] {\n    return str.filter { $0.isLetter }\n}",
    "output": "/// Преобразует строку в массив символов, исключая все цифры и пробелы.\n/// - Parameter str: Входная строка.\n/// - Returns: Массив символов без цифр и пробелов.\nfunc stringToAlphabeticCharArrayWithoutDigits(_ str: String) -> [Character] {\n    return str.filter { $0.isLetter }\n}"
  },
  {
    "input": "func stringToFloatArrayByDot(_ str: String) -> [Float] {\n    return str.split(separator: \".\").compactMap { Float($0) }\n}",
    "output": "/// Преобразует строку в массив чисел, разделённых точками.\n/// - Parameter str: Входная строка.\n/// - Returns: Массив чисел с плавающей точкой.\nfunc stringToFloatArrayByDot(_ str: String) -> [Float] {\n    return str.split(separator: \".\").compactMap { Float($0) }\n}"
  },
  {
    "input": "func stringToArrayByCommaOrSemicolon(_ str: String) -> [String] {\n    return str.split { $0 == \",\" || $0 == \";\" }.map { String($0) }\n}",
    "output": "/// Преобразует строку в массив слов, разделённых запятыми или точками с запятой.\n/// - Parameter str: Входная строка.\n/// - Returns: Массив слов.\nfunc stringToArrayByCommaOrSemicolon(_ str: String) -> [String] {\n    return str.split { $0 == \",\" || $0 == \";\" }.map { String($0) }\n}"
  },
  {
    "input": "func randomElementFromStringArray(_ array: [String]) -> String? {\n    return array.randomElement()\n}",
    "output": "/// Генерирует случайный элемент из массива строк.\n/// - Parameter array: Массив строк.\n/// - Returns: Случайный элемент из массива.\nfunc randomElementFromStringArray(_ array: [String]) -> String? {\n    return array.randomElement()\n}"
  },
  {
    "input": "func isBinaryStringWithLeadingZeros(_ str: String) -> Bool {\n    let regex = \"^0b[01]+$\"\n    return str.range(of: regex, options: .regularExpression) != nil\n}",
    "output": "/// Проверяет, является ли строка числом в двоичной системе с ведущими нулями.\n/// - Parameter str: Входная строка.\n/// - Returns: `true`, если строка является двоичным числом с ведущими нулями.\nfunc isBinaryStringWithLeadingZeros(_ str: String) -> Bool {\n    let regex = \"^0b[01]+$\"\n    return str.range(of: regex, options: .regularExpression) != nil\n}"
  },
  {
    "input": "func stringToTrimmedStringArray(_ str: String) -> [String] {\n    return str.split(separator: \" \").map { String($0).trimmingCharacters(in: .whitespaces) }\n}",
    "output": "/// Преобразует строку в массив строк с удалением всех лишних пробелов.\n/// - Parameter str: Входная строка.\n/// - Returns: Массив строк без лишних пробелов.\nfunc stringToTrimmedStringArray(_ str: String) -> [String] {\n    return str.split(separator: \" \").map { String($0).trimmingCharacters(in: .whitespaces) }\n}"
  },
  {
    "input": "func stringToSignedIntegerArray(_ str: String) -> [Int] {\n    return str.split(separator: \" \").compactMap { Int($0) }\n}",
    "output": "/// Преобразует строку в массив целых чисел с сохранением знаков.\n/// - Parameter str: Входная строка.\n/// - Returns: Массив целых чисел.\nfunc stringToSignedIntegerArray(_ str: String) -> [Int] {\n    return str.split(separator: \" \").compactMap { Int($0) }\n}"
  },
  {
    "input": "func isExponentialNumber(_ str: String) -> Bool {\n    return Double(str) != nil\n}",
    "output": "/// Проверяет, является ли строка допустимым числом с плавающей точкой в экспоненциальной записи.\n/// - Parameter str: Входная строка.\n/// - Returns: `true`, если строка является числом в экспоненциальной записи.\nfunc isExponentialNumber(_ str: String) -> Bool {\n    return Double(str) != nil\n}"
  },
  {
    "input": "func stringToCommaAndSpaceSeparatedFloats(_ str: String) -> [Float] {\n    return str.split { $0 == \",\" || $0 == \" \" }.compactMap { Float($0) }\n}",
    "output": "/// Преобразует строку в массив чисел с плавающей точкой, разделённых запятыми и пробелами.\n/// - Parameter str: Входная строка.\n/// - Returns: Массив чисел с плавающей точкой.\nfunc stringToCommaAndSpaceSeparatedFloats(_ str: String) -> [Float] {\n    return str.split { $0 == \",\" || $0 == \" \" }.compactMap { Float($0) }\n}"
  },
  {
    "input": "func isLowercaseHexadecimal(_ str: String) -> Bool {\n    let regex = \"^[a-f0-9]+$\"\n    return str.range(of: regex, options: .regularExpression) != nil\n}",
    "output": "/// Проверяет, является ли строка шестнадцатеричным числом в нижнем регистре.\n/// - Parameter str: Входная строка.\n/// - Returns: `true`, если строка является шестнадцатеричным числом в нижнем регистре.\nfunc isLowercaseHexadecimal(_ str: String) -> Bool {\n    let regex = \"^[a-f0-9]+$\"\n    return str.range(of: regex, options: .regularExpression) != nil\n}"
  },
  {
    "input": "func stringToIntegerArrayByDotAndSpace(_ str: String) -> [Int] {\n    return str.split { $0 == \".\" || $0 == \" \" }.compactMap { Int($0) }\n}",
    "output": "/// Преобразует строку в массив целых чисел, разделённых точками и пробелами.\n/// - Parameter str: Входная строка.\n/// - Returns: Массив целых чисел.\nfunc stringToIntegerArrayByDotAndSpace(_ str: String) -> [Int] {\n    return str.split { $0 == \".\" || $0 == \" \" }.compactMap { Int($0) }\n}"
  },
  {
    "input": "func generateRandomAlphanumericString(length: Int) -> String {\n    let characters = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\"\n    return String((0..<length).compactMap { _ in characters.randomElement() })\n}",
    "output": "/// Генерирует случайную строку заданной длины, состоящую из латинских букв и цифр.\n/// - Parameter length: Длина строки.\n/// - Returns: Случайная строка.\nfunc generateRandomAlphanumericString(length: Int) -> String {\n    let characters = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\"\n    return String((0..<length).compactMap { _ in characters.randomElement() })\n}"
  },
  {
    "input": "func stringToCharArrayBySpaceOrSemicolon(_ str: String) -> [Character] {\n    return str.split { $0 == \" \" || $0 == \";\" }.flatMap { $0 }\n}",
    "output": "/// Преобразует строку в массив символов, разделённых пробелами или точками с запятой.\n/// - Parameter str: Входная строка.\n/// - Returns: Массив символов.\nfunc stringToCharArrayBySpaceOrSemicolon(_ str: String) -> [Character] {\n    return str.split { $0 == \" \" || $0 == \";\" }.flatMap { $0 }\n}"
  },
  {
    "input": "func stringToFloatArrayBySpaceAndDot(_ str: String) -> [Float] {\n    return str.split { $0 == \" \" || $0 == \".\" }.compactMap { Float($0) }\n}",
    "output": "/// Преобразует строку в массив чисел, разделённых пробелами и точками.\n/// - Parameter str: Входная строка.\n/// - Returns: Массив чисел с плавающей точкой.\nfunc stringToFloatArrayBySpaceAndDot(_ str: String) -> [Float] {\n    return str.split { $0 == \" \" || $0 == \".\" }.compactMap { Float($0) }\n}"
  },
  {
    "input": "func generateRandomStringArray(length: Int) -> [String] {\n    let characters = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\"\n    return (0..<length).map { _ in String((0..<10).compactMap { _ in characters.randomElement() }) }\n}",
    "output": "/// Генерирует массив случайных строк заданной длины.\n/// - Parameter length: Длина массива строк.\n/// - Returns: Массив случайных строк.\nfunc generateRandomStringArray(length: Int) -> [String] {\n    let characters = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\"\n    return (0..<length).map { _ in String((0..<10).compactMap { _ in characters.randomElement() }) }\n}"
  },
  {
    "input": "func stringToIntegerArrayByNewLine(_ str: String) -> [Int] {\n    return str.split(separator: \"\\n\").compactMap { Int($0) }\n}",
    "output": "/// Преобразует строку в массив чисел, разделённых символами новой строки.\n/// - Parameter str: Входная строка.\n/// - Returns: Массив целых чисел.\nfunc stringToIntegerArrayByNewLine(_ str: String) -> [Int] {\n    return str.split(separator: \"\\n\").compactMap { Int($0) }\n}"
  },
  {
    "input": "func isValidIPv4Address(_ ip: String) -> Bool {\n    let components = ip.split(separator: \".\")\n    return components.count == 4 && components.allSatisfy { component in\n        if let num = Int(component), num >= 0, num <= 255 {\n            return true\n        }\n        return false\n    }\n}",
    "output": "/// Проверяет, является ли строка представлением действительного IP-адреса версии 4.\n/// - Parameter ip: Входная строка.\n/// - Returns: `true`, если строка является валидным IPv4-адресом.\nfunc isValidIPv4Address(_ ip: String) -> Bool {\n    let components = ip.split(separator: \".\")\n    return components.count == 4 && components.allSatisfy { component in\n        if let num = Int(component), num >= 0, num <= 255 {\n            return true\n        }\n        return false\n    }\n}"
  },
  {
    "input": "func stringToFloatArrayByDotSeparator(_ str: String) -> [Float] {\n    return str.split(separator: \".\").compactMap { Float($0) }\n}",
    "output": "/// Преобразует строку в массив чисел с плавающей точкой, разделённых точками.\n/// - Parameter str: Входная строка.\n/// - Returns: Массив чисел с плавающей точкой.\nfunc stringToFloatArrayByDotSeparator(_ str: String) -> [Float] {\n    return str.split(separator: \".\").compactMap { Float($0) }\n}"
  },
  {
    "input": "func isExponentialFormatNumber(_ str: String) -> Bool {\n    let regex = \"^[-+]?[0-9]*\\\\.?[0-9]+([eE][-+]?[0-9]+)?$\"\n    return str.range(of: regex, options: .regularExpression) != nil\n}",
    "output": "/// Проверяет, является ли строка допустимым числом в экспоненциальной записи.\n/// - Parameter str: Входная строка.\n/// - Returns: `true`, если строка является числом в экспоненциальной записи.\nfunc isExponentialFormatNumber(_ str: String) -> Bool {\n    let regex = \"^[-+]?[0-9]*\\\\.?[0-9]+([eE][-+]?[0-9]+)?$\"\n    return str.range(of: regex, options: .regularExpression) != nil\n}"
  },
  {
    "input": "func generateRandomStringArray(length: Int, stringLength: Int) -> [String] {\n    let characters = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\"\n    return (0..<length).map { _ in\n        String((0..<stringLength).compactMap { _ in characters.randomElement() })\n    }\n}",
    "output": "/// Генерирует случайный массив строк заданной длины.\n/// - Parameters:\n///   - length: Длина массива.\n///   - stringLength: Длина каждой строки в массиве.\n/// - Returns: Массив случайных строк.\nfunc generateRandomStringArray(length: Int, stringLength: Int) -> [String] {\n    let characters = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\"\n    return (0..<length).map { _ in\n        String((0..<stringLength).compactMap { _ in characters.randomElement() })\n    }\n}"
  },
  {
    "input": "func averageOfIntegersInString(_ str: String) -> Double {\n    let numbers = str.split(separator: \" \").compactMap { Int($0) }\n    return numbers.isEmpty ? 0 : Double(numbers.reduce(0, +)) / Double(numbers.count)\n}",
    "output": "/// Преобразует строку в массив чисел, разделённых пробелами, и находит их среднее значение.\n/// - Parameter str: Входная строка.\n/// - Returns: Среднее значение чисел в строке.\nfunc averageOfIntegersInString(_ str: String) -> Double {\n    let numbers = str.split(separator: \" \").compactMap { Int($0) }\n    return numbers.isEmpty ? 0 : Double(numbers.reduce(0, +)) / Double(numbers.count)\n}"
  },
  {
    "input": "func stringToFloatArrayWithSpaceAndSemicolon(_ str: String) -> [Float] {\n    return str.split { $0 == \" \" || $0 == \";\" }.compactMap { Float($0) }\n}",
    "output": "/// Преобразует строку в массив чисел с плавающей точкой, разделённых пробелами и точками с запятой.\n/// - Parameter str: Входная строка.\n/// - Returns: Массив чисел с плавающей точкой.\nfunc stringToFloatArrayWithSpaceAndSemicolon(_ str: String) -> [Float] {\n    return str.split { $0 == \" \" || $0 == \";\" }.compactMap { Float($0) }\n}"
  },
  {
    "input": "func keysWithSameValues<Key, Value>(_ dictionary: [Key: Value]) -> [Key] where Key: Hashable {\n    let grouped = Dictionary(grouping: dictionary.keys, by: { dictionary[$0]! })\n    return grouped.filter { $0.value.count > 1 }.flatMap { $0.value }\n}",
    "output": "/// Возвращает ключи словаря, которые имеют одинаковые значения.\n/// - Parameter dictionary: Словарь.\n/// - Returns: Массив ключей с одинаковыми значениями.\nfunc keysWithSameValues<Key, Value>(_ dictionary: [Key: Value]) -> [Key] where Key: Hashable {\n    let grouped = Dictionary(grouping: dictionary.keys, by: { dictionary[$0]! })\n    return grouped.filter { $0.value.count > 1 }.flatMap { $0.value }\n}"
  },
  {
    "input": "func stringToFloatArrayWithSpaceAndComma(_ str: String) -> [Float] {\n    return str.split { $0 == \" \" || $0 == \",\" }.compactMap { Float($0) }\n}",
    "output": "/// Преобразует строку в массив чисел с плавающей точкой, разделённых пробелами и запятыми.\n/// - Parameter str: Входная строка.\n/// - Returns: Массив чисел с плавающей точкой.\nfunc stringToFloatArrayWithSpaceAndComma(_ str: String) -> [Float] {\n    return str.split { $0 == \" \" || $0 == \",\" }.compactMap { Float($0) }\n}"
  },
  {
    "input": "func stringToIntegerArrayBySemicolon(_ str: String) -> [Int] {\n    return str.split(separator: \";\").compactMap { Int($0) }\n}",
    "output": "/// Преобразует строку в массив целых чисел, разделённых точками с запятой.\n/// - Parameter str: Входная строка.\n/// - Returns: Массив целых чисел.\nfunc stringToIntegerArrayBySemicolon(_ str: String) -> [Int] {\n    return str.split(separator: \";\").compactMap { Int($0) }\n}"
  },
  {
    "input": "func isValidEmailAddress(_ email: String) -> Bool {\n    let regex = \"[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\\\.[A-Za-z]{2,64}\"\n    return email.range(of: regex, options: .regularExpression) != nil\n}",
    "output": "/// Проверяет, является ли строка допустимым электронным адресом.\n/// - Parameter email: Входная строка.\n/// - Returns: `true`, если строка является валидным email.\nfunc isValidEmailAddress(_ email: String) -> Bool {\n    let regex = \"[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\\\.[A-Za-z]{2,64}\"\n    return email.range(of: regex, options: .regularExpression) != nil\n}"
  },
  {
    "input": "func differenceBetweenArrays<T>(_ array1: [T], _ array2: [T]) -> [T] where T: Hashable {\n    return Array(Set(array1).subtracting(array2))\n}",
    "output": "/// Возвращает все элементы массива, которые не присутствуют в другом массиве.\n/// - Parameters:\n///   - array1: Первый массив.\n///   - array2: Второй массив.\n/// - Returns: Массив уникальных элементов, которые присутствуют только в первом массиве.\nfunc differenceBetweenArrays<T>(_ array1: [T], _ array2: [T]) -> [T] where T: Hashable {\n    return Array(Set(array1).subtracting(array2))\n}"
  },
  {
    "input": "func stringToFloatArrayBySpaceAndPeriod(_ str: String) -> [Float] {\n    return str.split { $0 == \" \" || $0 == \".\" }.compactMap { Float($0) }\n}",
    "output": "/// Преобразует строку в массив чисел с плавающей точкой, разделённых пробелами и точками.\n/// - Parameter str: Входная строка.\n/// - Returns: Массив чисел с плавающей точкой.\nfunc stringToFloatArrayBySpaceAndPeriod(_ str: String) -> [Float] {\n    return str.split { $0 == \" \" || $0 == \".\" }.compactMap { Float($0) }\n}"
  },
  {
    "input": "func randomIntInRange(min: Int, max: Int) -> Int {\n    return Int.random(in: min...max)\n}",
    "output": "/// Генерирует случайное целое число в заданном диапазоне, включая оба конца диапазона.\n/// - Parameters:\n///   - min: Минимальное значение.\n///   - max: Максимальное значение.\n/// - Returns: Случайное целое число.\nfunc randomIntInRange(min: Int, max: Int) -> Int {\n    return Int.random(in: min...max)\n}"
  },
  {
    "input": "func stringToFloatArrayBySpaceOrTab(_ str: String) -> [Float] {\n    return str.split { $0 == \" \" || $0 == \"\\t\" }.compactMap { Float($0) }\n}",
    "output": "/// Преобразует строку в массив чисел с плавающей точкой, разделённых пробелами или табуляцией.\n/// - Parameter str: Входная строка.\n/// - Returns: Массив чисел с плавающей точкой.\nfunc stringToFloatArrayBySpaceOrTab(_ str: String) -> [Float] {\n    return str.split { $0 == \" \" || $0 == \"\\t\" }.compactMap { Float($0) }\n}"
  },
  {
    "input": "func isHexadecimalNumber(_ str: String) -> Bool {\n    let regex = \"^[0-9a-fA-F]+$\"\n    return str.range(of: regex, options: .regularExpression) != nil\n}",
    "output": "/// Проверяет, является ли строка числом в шестнадцатеричной системе.\n/// - Parameter str: Входная строка.\n/// - Returns: `true`, если строка является шестнадцатеричным числом.\nfunc isHexadecimalNumber(_ str: String) -> Bool {\n    let regex = \"^[0-9a-fA-F]+$\"\n    return str.range(of: regex, options: .regularExpression) != nil\n}"
  },
  {
    "input": "func sumOfArrayElements<T>(_ numbers: [T]) -> T where T: AdditiveArithmetic {\n    return numbers.reduce(.zero, +)\n}",
    "output": "/// Возвращает сумму всех чисел в массиве.\n/// - Parameter numbers: Массив чисел.\n/// - Returns: Сумма чисел в массиве.\nfunc sumOfArrayElements<T>(_ numbers: [T]) -> T where T: AdditiveArithmetic {\n    return numbers.reduce(.zero, +)\n}"
  },
  {
    "input": "func rectanglePerimeter(length: Double, width: Double) -> Double {\n    return 2 * (length + width)\n}",
    "output": "/// Вычисляет периметр прямоугольника\n/// - Parameters:\n///   - length: Длина прямоугольника\n///   - width: Ширина прямоугольника\n/// - Returns: Периметр прямоугольника\nfunc rectanglePerimeter(length: Double, width: Double) -> Double {\n    return 2 * (length + width)\n}"
  },
  {
    "input": "func isEven(number: Int) -> Bool {\n    return number % 2 == 0\n}",
    "output": "/// Проверяет, является ли число четным\n/// - Parameter number: Число для проверки\n/// - Returns: `true`, если число четное, иначе `false`\nfunc isEven(number: Int) -> Bool {\n    return number % 2 == 0\n}"
  },
  {
    "input": "func stringToInt(str: String) -> Int? {\n    return Int(str)\n}",
    "output": "/// Преобразует строку в целое число\n/// - Parameter str: Строка, которая будет преобразована\n/// - Returns: Число, если преобразование успешно, иначе `nil`\nfunc stringToInt(str: String) -> Int? {\n    return Int(str)\n}"
  },
  {
    "input": "func maxNumber(in numbers: [Int]) -> Int? {\n    return numbers.max()\n}",
    "output": "/// Находит максимальное число в массиве\n/// - Parameter numbers: Массив чисел\n/// - Returns: Максимальное число\nfunc maxNumber(in numbers: [Int]) -> Int? {\n    return numbers.max()\n}"
  },
  {
    "input": "func celsiusToFahrenheit(celsius: Double) -> Double {\n    return celsius * 9/5 + 32\n}",
    "output": "/// Переводит температуру из Цельсия в Фаренгейт\n/// - Parameter celsius: Температура в градусах Цельсия\n/// - Returns: Температура в градусах Фаренгейта\nfunc celsiusToFahrenheit(celsius: Double) -> Double {\n    return celsius * 9/5 + 32\n}"
  },
  {
    "input": "func reverseString(input: String) -> String {\n    return String(input.reversed())\n}",
    "output": "/// Возвращает строку с обратным порядком символов\n/// - Parameter input: Строка, которую нужно перевернуть\n/// - Returns: Перевернутая строка\nfunc reverseString(input: String) -> String {\n    return String(input.reversed())\n}"
  },
  {
    "input": "func isPalindrome(input: String) -> Bool {\n    return input == String(input.reversed())\n}",
    "output": "/// Проверяет, является ли строка палиндромом\n/// - Parameter input: Строка для проверки\n/// - Returns: `true`, если строка палиндром, иначе `false`\nfunc isPalindrome(input: String) -> Bool {\n    return input == String(input.reversed())\n}"
  },
  {
    "input": "func sum(of numbers: [Int]) -> Int {\n    return numbers.reduce(0, +)\n}",
    "output": "/// Вычисляет сумму всех элементов в массиве\n/// - Parameter numbers: Массив чисел\n/// - Returns: Сумма элементов\nfunc sum(of numbers: [Int]) -> Int {\n    return numbers.reduce(0, +)\n}"
  },
  {
    "input": "func stringToCharacterArray(str: String) -> [Character] {\n    return Array(str)\n}",
    "output": "/// Преобразует строку в массив символов\n/// - Parameter str: Строка для преобразования\n/// - Returns: Массив символов\nfunc stringToCharacterArray(str: String) -> [Character] {\n    return Array(str)\n}"
  },
  {
    "input": "func factorial(of n: Int) -> Int {\n    return n == 0 ? 1 : n * factorial(of: n - 1)\n}",
    "output": "/// Вычисляет факториал числа\n/// - Parameter n: Число для вычисления факториала\n/// - Returns: Факториал числа\nfunc factorial(of n: Int) -> Int {\n    return n == 0 ? 1 : n * factorial(of: n - 1)\n}"
  },
  {
    "input": "func toUpperCase(input: String) -> String {\n    return input.uppercased()\n}",
    "output": "/// Преобразует строку в заглавные буквы\n/// - Parameter input: Строка для преобразования\n/// - Returns: Строка в верхнем регистре\nfunc toUpperCase(input: String) -> String {\n    return input.uppercased()\n}"
  },
  {
    "input": "func isPositive(number: Int) -> Bool {\n    return number > 0\n}",
    "output": "/// Проверяет, является ли число положительным\n/// - Parameter number: Число для проверки\n/// - Returns: `true`, если число положительное, иначе `false`\nfunc isPositive(number: Int) -> Bool {\n    return number > 0\n}"
  },
  {
    "input": "func square(of number: Double) -> Double {\n    return number * number\n}",
    "output": "/// Вычисляет квадрат числа\n/// - Parameter number: Число для возведения в квадрат\n/// - Returns: Квадрат числа\nfunc square(of number: Double) -> Double {\n    return number * number\n}"
  },
  {
    "input": "func indexOf<T>(in array: [T], element: T) -> Int? where T: Equatable {\n    return array.firstIndex(of: element)\n}",
    "output": "/// Получает индекс первого вхождения элемента в массив\n/// - Parameters:\n///   - array: Массив для поиска\n///   - element: Элемент для поиска\n/// - Returns: Индекс первого вхождения элемента или `nil`, если элемент не найден\nfunc indexOf<T>(in array: [T], element: T) -> Int? where T: Equatable {\n    return array.firstIndex(of: element)\n}"
  },
  {
    "input": "func isEmpty(input: String) -> Bool {\n    return input.isEmpty\n}",
    "output": "/// Проверяет, является ли строка пустой\n/// - Parameter input: Строка для проверки\n/// - Returns: `true`, если строка пустая, иначе `false`\nfunc isEmpty(input: String) -> Bool {\n    return input.isEmpty\n}"
  },
  {
    "input": "func average(of numbers: [Double]) -> Double? {\n    guard !numbers.isEmpty else { return nil }\n    let sum = numbers.reduce(0, +)\n    return sum / Double(numbers.count)\n}",
    "output": "/// Находит среднее арифметическое чисел в массиве\n/// - Parameter numbers: Массив чисел\n/// - Returns: Среднее арифметическое\nfunc average(of numbers: [Double]) -> Double? {\n    guard !numbers.isEmpty else { return nil }\n    let sum = numbers.reduce(0, +)\n    return sum / Double(numbers.count)\n}"
  },
  {
    "input": "func isNumber(input: String) -> Bool {\n    return Double(input) != nil\n}",
    "output": "/// Определяет, является ли строка числом\n/// - Parameter input: Строка для проверки\n/// - Returns: `true`, если строка является числом, иначе `false`\nfunc isNumber(input: String) -> Bool {\n    return Double(input) != nil\n}"
  },
  {
    "input": "func minutesToSeconds(minutes: Int) -> Int {\n    return minutes * 60\n}",
    "output": "/// Преобразует минут в секунды\n/// - Parameter minutes: Количество минут\n/// - Returns: Количество секунд\nfunc minutesToSeconds(minutes: Int) -> Int {\n    return minutes * 60\n}"
  },
  {
    "input": "func isLeapYear(year: Int) -> Bool {\n    return (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0)\n}",
    "output": "/// Проверяет, является ли год високосным\n/// - Parameter year: Год для проверки\n/// - Returns: `true`, если год високосный, иначе `false`\nfunc isLeapYear(year: Int) -> Bool {\n    return (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0)\n}"
  },
  {
    "input": "func stringToWords(input: String) -> [String] {\n    return input.split(separator: \" \").map { String($0) }\n}",
    "output": "/// Преобразует строку в массив слов\n/// - Parameter input: Строка для преобразования\n/// - Returns: Массив слов\nfunc stringToWords(input: String) -> [String] {\n    return input.split(separator: \" \").map { String($0) }\n}"
  },
  {
    "input": "func circleArea(radius: Double) -> Double {\n    return .pi * pow(radius, 2)\n}",
    "output": "/// Вычисляет площадь круга\n/// - Parameter radius: Радиус круга\n/// - Returns: Площадь круга\nfunc circleArea(radius: Double) -> Double {\n    return .pi * pow(radius, 2)\n}"
  },
  {
    "input": "func isFloat(input: String) -> Bool {\n    return Float(input) != nil\n}",
    "output": "/// Проверяет, является ли строка числом с плавающей запятой\n/// - Parameter input: Строка для проверки\n/// - Returns: `true`, если строка является числом с плавающей запятой, иначе `false`\nfunc isFloat(input: String) -> Bool {\n    return Float(input) != nil\n}"
  },
  {
    "input": "func isBlank(input: String) -> Bool {\n    return input.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty\n}",
    "output": "/// Проверяет, является ли строка пустой или содержит только пробелы\n/// - Parameter input: Строка для проверки\n/// - Returns: `true`, если строка пустая или состоит только из пробелов\nfunc isBlank(input: String) -> Bool {\n    return input.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty\n}"
  },
  {
    "input": "func longestString(in strings: [String]) -> String? {\n    return strings.max { $0.count < $1.count }\n}",
    "output": "/// Возвращает максимальный элемент из массива строк по длине\n/// - Parameter strings: Массив строк\n/// - Returns: Строка с наибольшей длиной\nfunc longestString(in strings: [String]) -> String? {\n    return strings.max { $0.count < $1.count }\n}"
  },
  {
    "input": "func isNegative(number: Int) -> Bool {\n    return number < 0\n}",
    "output": "/// Проверяет, является ли число отрицательным\n/// - Parameter number: Число для проверки\n/// - Returns: `true`, если число отрицательное, иначе `false`\nfunc isNegative(number: Int) -> Bool {\n    return number < 0\n}"
  },
  {
    "input": "func squareRoot(of number: Double) -> Double {\n    return sqrt(number)\n}",
    "output": "/// Вычисляет квадратный корень числа\n/// - Parameter number: Число для вычисления квадратного корня\n/// - Returns: Квадратный корень числа\nfunc squareRoot(of number: Double) -> Double {\n    return sqrt(number)\n}"
  },
  {
    "input": "func isValidEmail(input: String) -> Bool {\n    let emailRegex = \"[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\\\.[A-Za-z]{2,}\"\n    let emailTest = NSPredicate(format: \"SELF MATCHES %@\", emailRegex)\n    return emailTest.evaluate(with: input)\n}",
    "output": "/// Проверяет, является ли строка валидным email-адресом\n/// - Parameter input: Строка для проверки\n/// - Returns: `true`, если строка является валидным email-адресом, иначе `false`\nfunc isValidEmail(input: String) -> Bool {\n    let emailRegex = \"[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\\\.[A-Za-z]{2,}\"\n    let emailTest = NSPredicate(format: \"SELF MATCHES %@\", emailRegex)\n    return emailTest.evaluate(with: input)\n}"
  },
  {
    "input": "func stringToNumbers(input: String) -> [Int]? {\n    return input.split(separator: \" \").compactMap { Int($0) }\n}",
    "output": "/// Конвертирует строку в массив чисел\n/// - Parameter input: Строка для преобразования\n/// - Returns: Массив чисел\nfunc stringToNumbers(input: String) -> [Int]? {\n    return input.split(separator: \" \").compactMap { Int($0) }\n}"
  },
  {
    "input": "func product(of numbers: [Int]) -> Int {\n    return numbers.reduce(1, *)\n}",
    "output": "/// Вычисляет произведение всех элементов в массиве\n/// - Parameter numbers: Массив чисел\n/// - Returns: Произведение элементов\nfunc product(of numbers: [Int]) -> Int {\n    return numbers.reduce(1, *)\n}"
  },
  {
    "input": "func randomInRange(min: Int, max: Int) -> Int {\n    return Int.random(in: min...max)\n}",
    "output": "/// Генерирует случайное число в заданном диапазоне\n/// - Parameters:\n///   - min: Минимальное значение диапазона\n///   - max: Максимальное значение диапазона\n/// - Returns: Случайное число в диапазоне\nfunc randomInRange(min: Int, max: Int) -> Int {\n    return Int.random(in: min...max)\n}"
  },
  {
    "input": "func isDecimal(input: String) -> Bool {\n    return input.range(of: \"^[0-9]+(\\\\.[0-9]+)?$\", options: .regularExpression) != nil\n}",
    "output": "/// Проверяет, является ли строка числом в десятичной системе\n/// - Parameter input: Строка для проверки\n/// - Returns: `true`, если строка является числом в десятичной системе, иначе `false`\nfunc isDecimal(input: String) -> Bool {\n    return input.range(of: \"^[0-9]+(\\\\.[0-9]+)?$\", options: .regularExpression) != nil\n}"
  },
  {
    "input": "func stringToCharacterArrayWithoutSpaces(input: String) -> [Character] {\n    return input.filter { !$0.isWhitespace }\n}",
    "output": "/// Конвертирует строку в массив символов с удалением пробелов\n/// - Parameter input: Строка для преобразования\n/// - Returns: Массив символов без пробелов\nfunc stringToCharacterArrayWithoutSpaces(input: String) -> [Character] {\n    return input.filter { !$0.isWhitespace }\n}"
  },
  {
    "input": "func isDigitsOnly(input: String) -> Bool {\n    return input.allSatisfy { $0.isNumber }\n}",
    "output": "/// Проверяет, является ли строка состоит только из чисел\n/// - Parameter input: Строка для проверки\n/// - Returns: `true`, если строка состоит только из чисел, иначе `false`\nfunc isDigitsOnly(input: String) -> Bool {\n    return input.allSatisfy { $0.isNumber }\n}"
  },
  {
    "input": "func replaceSpacesWithHyphens(input: String) -> String {\n    return input.replacingOccurrences(of: \" \", with: \"-\")\n}",
    "output": "/// Возвращает строку с заменой всех пробелов на дефисы\n/// - Parameter input: Строка для преобразования\n/// - Returns: Строка с дефисами вместо пробелов\nfunc replaceSpacesWithHyphens(input: String) -> String {\n    return input.replacingOccurrences(of: \" \", with: \"-\")\n}"
  },
  {
    "input": "func arithmeticSum(firstTerm: Int, lastTerm: Int, count: Int) -> Int {\n    return count * (firstTerm + lastTerm) / 2\n}",
    "output": "/// Вычисляет сумму чисел в массиве с использованием формулы арифметической прогрессии\n/// - Parameters:\n///   - firstTerm: Первый элемент прогрессии\n///   - lastTerm: Последний элемент прогрессии\n///   - count: Количество элементов\n/// - Returns: Сумма чисел в массиве\nfunc arithmeticSum(firstTerm: Int, lastTerm: Int, count: Int) -> Int {\n    return count * (firstTerm + lastTerm) / 2\n}"
  },
  {
    "input": "func numbersToString(numbers: [Int]) -> String {\n    return numbers.map { String($0) }.joined(separator: \", \")\n}",
    "output": "/// Преобразует массив целых чисел в строку, разделённую запятыми\n/// - Parameter numbers: Массив целых чисел\n/// - Returns: Строка чисел, разделённых запятыми\nfunc numbersToString(numbers: [Int]) -> String {\n    return numbers.map { String($0) }.joined(separator: \", \")\n}"
  },
  {
    "input": "func isLetter(input: String) -> Bool {\n    return input.count == 1 && input.rangeOfCharacter(from: .letters) != nil\n}",
    "output": "/// Проверяет, является ли строка буквой\n/// - Parameter input: Строка для проверки\n/// - Returns: `true`, если строка является буквой, иначе `false`\nfunc isLetter(input: String) -> Bool {\n    return input.count == 1 && input.rangeOfCharacter(from: .letters) != nil\n}"
  },
  {
    "input": "func stringToWordsWithoutPunctuation(input: String) -> [String] {\n    let punctuationSet = CharacterSet.punctuationCharacters\n    let cleanInput = input.components(separatedBy: punctuationSet).joined(separator: \" \")\n    return cleanInput.split(separator: \" \").map { String($0) }\n}",
    "output": "/// Преобразует строку в массив слов с удалением пунктуации\n/// - Parameter input: Строка для преобразования\n/// - Returns: Массив слов\nfunc stringToWordsWithoutPunctuation(input: String) -> [String] {\n    let punctuationSet = CharacterSet.punctuationCharacters\n    let cleanInput = input.components(separatedBy: punctuationSet).joined(separator: \" \")\n    return cleanInput.split(separator: \" \").map { String($0) }\n}"
  },
  {
    "input": "func isMultiple(of number: Int, divisor: Int) -> Bool {\n    return number % divisor == 0\n}",
    "output": "/// Проверяет, является ли число кратным другому числу\n/// - Parameters:\n///   - number: Число для проверки\n///   - divisor: Делитель для проверки кратности\n/// - Returns: `true`, если число кратно делителю, иначе `false`\nfunc isMultiple(of number: Int, divisor: Int) -> Bool {\n    return number % divisor == 0\n}"
  },
  {
    "input": "func randomElement<T>(from array: [T]) -> T? {\n    return array.randomElement()\n}",
    "output": "/// Генерирует случайный элемент из массива\n/// - Parameter array: Массив, из которого нужно выбрать случайный элемент\n/// - Returns: Случайный элемент массива\nfunc randomElement<T>(from array: [T]) -> T? {\n    return array.randomElement()\n}"
  },
  {
    "input": "func stringToIntArray(input: String) -> [Int]? {\n    return input.split(separator: \",\").compactMap { Int($0.trimmingCharacters(in: .whitespaces)) }\n}",
    "output": "/// Преобразует строку в массив целых чисел, используя запятую как разделитель\n/// - Parameter input: Строка для преобразования\n/// - Returns: Массив целых чисел\nfunc stringToIntArray(input: String) -> [Int]? {\n    return input.split(separator: \",\").compactMap { Int($0.trimmingCharacters(in: .whitespaces)) }\n}"
  },
  {
    "input": "func absoluteValue(of number: Int) -> Int {\n    return abs(number)\n}",
    "output": "/// Возвращает абсолютное значение числа\n/// - Parameter number: Число для нахождения абсолютного значения\n/// - Returns: Абсолютное значение числа\nfunc absoluteValue(of number: Int) -> Int {\n    return abs(number)\n}"
  },
  {
    "input": "func isBinary(input: String) -> Bool {\n    let binaryRegex = \"^[01]+$\"\n    let binaryTest = NSPredicate(format: \"SELF MATCHES %@\", binaryRegex)\n    return binaryTest.evaluate(with: input)\n}",
    "output": "/// Проверяет, является ли строка числом в двоичной системе счисления\n/// - Parameter input: Строка для проверки\n/// - Returns: `true`, если строка является числом в двоичной системе, иначе `false`\nfunc isBinary(input: String) -> Bool {\n    let binaryRegex = \"^[01]+$\"\n    let binaryTest = NSPredicate(format: \"SELF MATCHES %@\", binaryRegex)\n    return binaryTest.evaluate(with: input)\n}"
  },
  {
    "input": "func isValidURL(input: String) -> Bool {\n    return URL(string: input) != nil\n}",
    "output": "/// Проверяет, является ли строка валидным URL\n/// - Parameter input: Строка для проверки\n/// - Returns: `true`, если строка является валидным URL, иначе `false`\nfunc isValidURL(input: String) -> Bool {\n    return URL(string: input) != nil\n}"
  },
  {
    "input": "func wordCount(in input: String) -> Int {\n    return input.split { $0.isWhitespace }.count\n}",
    "output": "/// Получает количество слов в строке\n/// - Parameter input: Строка для подсчета слов\n/// - Returns: Количество слов в строке\nfunc wordCount(in input: String) -> Int {\n    return input.split { $0.isWhitespace }.count\n}"
  },
  {
    "input": "func minNumber(in numbers: [Int]) -> Int? {\n    return numbers.min()\n}",
    "output": "/// Находит минимальное число в массиве\n/// - Parameter numbers: Массив чисел\n/// - Returns: Минимальное число в массиве\nfunc minNumber(in numbers: [Int]) -> Int? {\n    return numbers.min()\n}"
  },
  {
    "input": "func isAlphaNumeric(input: String) -> Bool {\n    return input.rangeOfCharacter(from: .alphanumerics) != nil\n}",
    "output": "/// Проверяет, является ли строка состоящей из цифр и символов\n/// - Parameter input: Строка для проверки\n/// - Returns: `true`, если строка состоит только из цифр и символов, иначе `false`\nfunc isAlphaNumeric(input: String) -> Bool {\n    return input.rangeOfCharacter(from: .alphanumerics) != nil\n}"
  },
  {
    "input": "func isUpperCase(input: String) -> Bool {\n    return input == input.uppercased()\n}",
    "output": "/// Проверяет, является ли строка только заглавными буквами\n/// - Parameter input: Строка для проверки\n/// - Returns: `true`, если строка состоит только из заглавных букв, иначе `false`\nfunc isUpperCase(input: String) -> Bool {\n    return input == input.uppercased()\n}"
  },
  {
    "input": "func hypotenuse(sideA: Double, sideB: Double) -> Double {\n    return sqrt(pow(sideA, 2) + pow(sideB, 2))\n}",
    "output": "/// Вычисляет гипотенузу прямоугольного треугольника\n/// - Parameters:\n///   - sideA: Одна из сторон треугольника\n///   - sideB: Другая сторона треугольника\n/// - Returns: Длина гипотенузы\nfunc hypotenuse(sideA: Double, sideB: Double) -> Double {\n    return sqrt(pow(sideA, 2) + pow(sideB, 2))\n}"
  },
  {
    "input": "func toLowerCase(input: String) -> String {\n    return input.lowercased()\n}",
    "output": "/// Преобразует строку в нижний регистр\n/// - Parameter input: Строка для преобразования\n/// - Returns: Строка в нижнем регистре\nfunc toLowerCase(input: String) -> String {\n    return input.lowercased()\n}"
  },
  {
    "input": "func degreesToRadians(degrees: Double) -> Double {\n    return degrees * .pi / 180\n}",
    "output": "/// Преобразует градусы в радианы\n/// - Parameter degrees: Угол в градусах\n/// - Returns: Угол в радианах\nfunc degreesToRadians(degrees: Double) -> Double {\n    return degrees * .pi / 180\n}"
  },
  {
    "input": "func radiansToDegrees(radians: Double) -> Double {\n    return radians * 180 / .pi\n}",
    "output": "/// Преобразует радианы в градусы\n/// - Parameter radians: Угол в радианах\n/// - Returns: Угол в градусах\nfunc radiansToDegrees(radians: Double) -> Double {\n    return radians * 180 / .pi\n}"
  },
  {
    "input": "func isFloatingPointNumber(input: String) -> Bool {\n    return input.range(of: \"^[0-9]*\\\\.[0-9]+$\", options: .regularExpression) != nil\n}",
    "output": "/// Проверяет, является ли строка числом с плавающей запятой\n/// - Parameter input: Строка для проверки\n/// - Returns: `true`, если строка является числом с плавающей запятой, иначе `false`\nfunc isFloatingPointNumber(input: String) -> Bool {\n    return input.range(of: \"^[0-9]*\\\\.[0-9]+$\", options: .regularExpression) != nil\n}"
  },
  {
    "input": "func stringToIntegerArray(input: String) -> [Int]? {\n    return input.split(separator: \" \").compactMap { Int($0) }\n}",
    "output": "/// Преобразует строку в массив целых чисел, разделённых пробелами\n/// - Parameter input: Строка с числами, разделёнными пробелами\n/// - Returns: Массив целых чисел\nfunc stringToIntegerArray(input: String) -> [Int]? {\n    return input.split(separator: \" \").compactMap { Int($0) }\n}"
  },
  {
    "input": "func isNotBlank(input: String) -> Bool {\n    return !input.trimmingCharacters(in: .whitespaces).isEmpty\n}",
    "output": "/// Проверяет, является ли строка непустой и не состоит только из пробелов\n/// - Parameter input: Строка для проверки\n/// - Returns: `true`, если строка не пуста и не состоит только из пробелов\nfunc isNotBlank(input: String) -> Bool {\n    return !input.trimmingCharacters(in: .whitespaces).isEmpty\n}"
  },
  {
    "input": "func firstWord(from input: String) -> String? {\n    return input.split(separator: \" \").first.map { String($0) }\n}",
    "output": "/// Возвращает первое слово из строки\n/// - Parameter input: Строка для извлечения первого слова\n/// - Returns: Первое слово из строки\nfunc firstWord(from input: String) -> String? {\n    return input.split(separator: \" \").first.map { String($0) }\n}"
  },
  {
    "input": "func removeSpaces(input: String) -> String {\n    return input.replacingOccurrences(of: \" \", with: \"\")\n}",
    "output": "/// Возвращает строку с удалением всех пробелов\n/// - Parameter input: Строка для удаления пробелов\n/// - Returns: Строка без пробелов\nfunc removeSpaces(input: String) -> String {\n    return input.replacingOccurrences(of: \" \", with: \"\")\n}"
  },
  {
    "input": "func isPalindromeIgnoreCase(input: String) -> Bool {\n    let cleanedInput = input.lowercased()\n    return cleanedInput == String(cleanedInput.reversed())\n}",
    "output": "/// Проверяет, является ли строка палиндромом игнорируя регистр\n/// - Parameter input: Строка для проверки\n/// - Returns: `true`, если строка является палиндромом, иначе `false`\nfunc isPalindromeIgnoreCase(input: String) -> Bool {\n    let cleanedInput = input.lowercased()\n    return cleanedInput == String(cleanedInput.reversed())\n}"
  },
  {
    "input": "func reverseCharacters(in input: String) -> [Character] {\n    return Array(input.reversed())\n}",
    "output": "/// Преобразует строку в массив символов в обратном порядке\n/// - Parameter input: Строка для преобразования\n/// - Returns: Массив символов в обратном порядке\nfunc reverseCharacters(in input: String) -> [Character] {\n    return Array(input.reversed())\n}"
  },
  {
    "input": "func average(of numbers: [Int]) -> Double? {\n    guard !numbers.isEmpty else { return nil }\n    let sum = numbers.reduce(0, +)\n    return Double(sum) / Double(numbers.count)\n}",
    "output": "/// Возвращает среднее значение чисел в массиве\n/// - Parameter numbers: Массив чисел\n/// - Returns: Среднее значение чисел\nfunc average(of numbers: [Int]) -> Double? {\n    guard !numbers.isEmpty else { return nil }\n    let sum = numbers.reduce(0, +)\n    return Double(sum) / Double(numbers.count)\n}"
  },
  {
    "input": "func replaceVowelsWithHash(input: String) -> String {\n    let vowels: [Character] = [\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"]\n    return input.map { vowels.contains($0) ? \"#\" : $0 }.reduce(\"\") { $0 + String($1) }\n}",
    "output": "/// Возвращает строку, в которой каждая гласная заменена на символ '#'\n/// - Parameter input: Строка для преобразования\n/// - Returns: Строка с заменёнными гласными\nfunc replaceVowelsWithHash(input: String) -> String {\n    let vowels: [Character] = [\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"]\n    return input.map { vowels.contains($0) ? \"#\" : $0 }.reduce(\"\") { $0 + String($1) }\n}"
  },
  {
    "input": "func truncateString(input: String, maxLength: Int) -> String {\n    return String(input.prefix(maxLength))\n}",
    "output": "/// Возвращает строку, которая является обрезанной версией другой строки\n/// - Parameters:\n///   - input: Строка для обрезки\n///   - maxLength: Максимальная длина строки\n/// - Returns: Строка, обрезанная до заданной длины\nfunc truncateString(input: String, maxLength: Int) -> String {\n    return String(input.prefix(maxLength))\n}"
  },
  {
    "input": "func isEven(value: Int) -> Bool {\n    return value % 2 == 0\n}",
    "output": "/// Проверяет, является ли число чётным или нечётным\n/// - Parameter value: Число для проверки\n/// - Returns: `true`, если число чётное, иначе `false`\nfunc isEven(value: Int) -> Bool {\n    return value % 2 == 0\n}"
  },
  {
    "input": "func capitalizeFirstLetter(of input: String) -> String {\n    return input.prefix(1).uppercased() + input.dropFirst()\n}",
    "output": "/// Возвращает строку с заглавной буквы\n/// - Parameter input: Строка для преобразования\n/// - Returns: Строка с заглавной буквы\nfunc capitalizeFirstLetter(of input: String) -> String {\n    return input.prefix(1).uppercased() + input.dropFirst()\n}"
  },
  {
    "input": "func sumOfFloats(numbers: [Float]) -> Float {\n    return numbers.reduce(0, +)\n}",
    "output": "/// Возвращает сумму чисел в массиве с плавающей запятой\n/// - Parameter numbers: Массив чисел\n/// - Returns: Сумма чисел\nfunc sumOfFloats(numbers: [Float]) -> Float {\n    return numbers.reduce(0, +)\n}"
  },
  {
    "input": "func isBlankString(text: String) -> Bool {\n    return text.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty\n}",
    "output": "/// Проверяет, является ли строка пустой или содержит только пробелы\n/// - Parameter text: Строка для проверки\n/// - Returns: `true`, если строка пуста или состоит только из пробелов\nfunc isBlankString(text: String) -> Bool {\n    return text.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty\n}"
  },
  {
    "input": "func extractDigits(from input: String) -> String {\n    return input.filter { $0.isNumber }\n}",
    "output": "/// Возвращает строку, содержащую только цифры из исходной строки\n/// - Parameter input: Строка для обработки\n/// - Returns: Строка, содержащая только цифры\nfunc extractDigits(from input: String) -> String {\n    return input.filter { $0.isNumber }\n}"
  },
  {
    "input": "func stringToWordsArray(input: String) -> [String] {\n    return input.split(separator: \" \").map { String($0) }\n}",
    "output": "/// Преобразует строку в массив слов, разделённых пробелами\n/// - Parameter input: Строка для преобразования\n/// - Returns: Массив слов\nfunc stringToWordsArray(input: String) -> [String] {\n    return input.split(separator: \" \").map { String($0) }\n}"
  },
  {
    "input": "func longestString(in strings: [String]) -> String? {\n    return strings.max { $0.count < $1.count }\n}",
    "output": "/// Возвращает максимальное значение в массиве строк по длине\n/// - Parameter strings: Массив строк\n/// - Returns: Строка с наибольшей длиной\nfunc longestString(in strings: [String]) -> String? {\n    return strings.max { $0.count < $1.count }\n}"
  },
  {
    "input": "func integerDivision(numerator: Int, denominator: Int) -> Int {\n    return numerator / denominator\n}",
    "output": "/// Возвращает целочисленный результат деления с округлением\n/// - Parameters:\n///   - numerator: Числитель\n///   - denominator: Знаменатель\n/// - Returns: Целочисленный результат деления\nfunc integerDivision(numerator: Int, denominator: Int) -> Int {\n    return numerator / denominator\n}"
  },
  {
    "input": "func numberToBinaryString(number: Int) -> String {\n    return String(number, radix: 2)\n}",
    "output": "/// Возвращает строку, которая является эквивалентом другого числа в двоичной системе\n/// - Parameter number: Число для преобразования\n/// - Returns: Число в двоичной системе\nfunc numberToBinaryString(number: Int) -> String {\n    return String(number, radix: 2)\n}"
  },
  {
    "input": "func isHexadecimal(input: String) -> Bool {\n    let hexRegex = \"^[0-9A-Fa-f]+$\"\n    let hexTest = NSPredicate(format: \"SELF MATCHES %@\", hexRegex)\n    return hexTest.evaluate(with: input)\n}",
    "output": "/// Проверяет, является ли строка числом в шестнадцатеричной системе\n/// - Parameter input: Строка для проверки\n/// - Returns: `true`, если строка является числом в шестнадцатеричной системе\nfunc isHexadecimal(input: String) -> Bool {\n    let hexRegex = \"^[0-9A-Fa-f]+$\"\n    let hexTest = NSPredicate(format: \"SELF MATCHES %@\", hexRegex)\n    return hexTest.evaluate(with: input)\n}"
  },
  {
    "input": "func squarePerimeter(side: Double) -> Double {\n    return 4 * side\n}",
    "output": "/// Вычисляет периметр квадрата\n/// - Parameter side: Длина стороны квадрата\n/// - Returns: Периметр квадрата\nfunc squarePerimeter(side: Double) -> Double {\n    return 4 * side\n}"
  },
  {
    "input": "func flipCase(input: String) -> String {\n    return input.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }.joined()\n}",
    "output": "/// Возвращает строку с заменёнными символами на противоположные\n/// - Parameter input: Строка для обработки\n/// - Returns: Строка с заменёнными символами\nfunc flipCase(input: String) -> String {\n    return input.map { $0.isUppercase ? $0.lowercased() : $0.uppercased() }.joined()\n}"
  },
  {
    "input": "func secondsToTimeFormat(seconds: Int) -> String {\n    let hours = seconds / 3600\n    let minutes = (seconds % 3600) / 60\n    let remainingSeconds = seconds % 60\n    return String(format: \"%02d:%02d:%02d\", hours, minutes, remainingSeconds)\n}",
    "output": "/// Конвертирует количество секунд в формат ЧЧ:ММ:СС\n/// - Parameter seconds: Количество секунд\n/// - Returns: Время в формате ЧЧ:ММ:СС\nfunc secondsToTimeFormat(seconds: Int) -> String {\n    let hours = seconds / 3600\n    let minutes = (seconds % 3600) / 60\n    let remainingSeconds = seconds % 60\n    return String(format: \"%02d:%02d:%02d\", hours, minutes, remainingSeconds)\n}"
  },
  {
    "input": "func extractVowels(from input: String) -> [Character] {\n    let vowels: Set<Character> = [\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"]\n    return input.filter { vowels.contains($0) }\n}",
    "output": "/// Преобразует строку в массив символов, состоящих из гласных\n/// - Parameter input: Строка для обработки\n/// - Returns: Массив символов-гласных\nfunc extractVowels(from input: String) -> [Character] {\n    let vowels: Set<Character> = [\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"]\n    return input.filter { vowels.contains($0) }\n}"
  },
  {
    "input": "func replaceSpacesWithUnderscores(input: String) -> String {\n    return input.replacingOccurrences(of: \" \", with: \"_\")\n}",
    "output": "/// Возвращает строку, в которой все пробелы заменены на подчеркивания\n/// - Parameter input: Строка для преобразования\n/// - Returns: Строка с подчеркиваниями вместо пробелов\nfunc replaceSpacesWithUnderscores(input: String) -> String {\n    return input.replacingOccurrences(of: \" \", with: \"_\")\n}"
  },
  {
    "input": "func power(base: Double, exponent: Double) -> Double {\n    return pow(base, exponent)\n}",
    "output": "/// Возвращает значение числа в степени\n/// - Parameters:\n///   - base: Основание\n///   - exponent: Показатель степени\n/// - Returns: Результат возведения в степень\nfunc power(base: Double, exponent: Double) -> Double {\n    return pow(base, exponent)\n}"
  },
  {
    "input": "func longestString(inArray array: [String]) -> String? {\n    return array.max { $0.count < $1.count }\n}",
    "output": "/// Находит строку, которая является максимальной по количеству символов среди элементов массива\n/// - Parameter array: Массив строк\n/// - Returns: Строка с максимальной длиной\nfunc longestString(inArray array: [String]) -> String? {\n    return array.max { $0.count < $1.count }\n}"
  },
  {
    "input": "func isDecimalNumber(input: String) -> Bool {\n    return input.contains(\".\")\n}",
    "output": "/// Проверяет, является ли строка числом с запятой (десятичным числом)\n/// - Parameter input: Строка для проверки\n/// - Returns: `true`, если строка является десятичным числом, иначе `false`\nfunc isDecimalNumber(input: String) -> Bool {\n    return input.contains(\".\")\n}"
  },
  {
    "input": "func uniqueCount<T>(in array: [T]) -> Int where T: Hashable {\n    return Set(array).count\n}",
    "output": "/// Возвращает количество уникальных элементов в массиве\n/// - Parameter array: Массив для анализа\n/// - Returns: Количество уникальных элементов\nfunc uniqueCount<T>(in array: [T]) -> Int where T: Hashable {\n    return Set(array).count\n}"
  },
  {
    "input": "func isDecimalString(input: String) -> Bool {\n    return Double(input) != nil\n}",
    "output": "/// Проверяет, является ли строка числом в десятичной системе\n/// - Parameter input: Строка для проверки\n/// - Returns: `true`, если строка является десятичным числом, иначе `false`\nfunc isDecimalString(input: String) -> Bool {\n    return Double(input) != nil\n}"
  },
  {
    "input": "func lowercaseCharacters(from input: String) -> [Character] {\n    return input.lowercased().map { $0 }\n}",
    "output": "/// Преобразует строку в массив символов в нижнем регистре\n/// - Parameter input: Строка для преобразования\n/// - Returns: Массив символов в нижнем регистре\nfunc lowercaseCharacters(from input: String) -> [Character] {\n    return input.lowercased().map { $0 }\n}"
  },
  {
    "input": "func isPrime(number: Int) -> Bool {\n    guard number > 1 else { return false }\n    for i in 2..<number {\n        if number % i == 0 {\n            return false\n        }\n    }\n    return true\n}",
    "output": "/// Проверяет, является ли число простым\n/// - Parameter number: Число для проверки\n/// - Returns: `true`, если число простое, иначе `false`\nfunc isPrime(number: Int) -> Bool {\n    guard number > 1 else { return false }\n    for i in 2..<number {\n        if number % i == 0 {\n            return false\n        }\n    }\n    return true\n}"
  },
  {
    "input": "func stringToIntArrayWithSpaces(text: String) -> [Int]? {\n    return text.split(separator: \" \").compactMap { Int($0) }\n}",
    "output": "/// Преобразует строку в массив чисел, разделённых пробелами\n/// - Parameter text: Строка с числами\n/// - Returns: Массив чисел\nfunc stringToIntArrayWithSpaces(text: String) -> [Int]? {\n    return text.split(separator: \" \").compactMap { Int($0) }\n}"
  },
  {
    "input": "func cube(of number: Double) -> Double {\n    return pow(number, 3)\n}",
    "output": "/// Вычисляет куб числа\n/// - Parameter number: Число для вычисления\n/// - Returns: Куб числа\nfunc cube(of number: Double) -> Double {\n    return pow(number, 3)\n}"
  },
  {
    "input": "func removeDigitsFromString(input: String) -> [Character] {\n    return input.filter { !$0.isNumber }\n}",
    "output": "/// Преобразует строку в массив символов, исключая цифры\n/// - Parameter input: Строка для преобразования\n/// - Returns: Массив символов без цифр\nfunc removeDigitsFromString(input: String) -> [Character] {\n    return input.filter { !$0.isNumber }\n}"
  },
  {
    "input": "func average(of values: [Int]) -> Double? {\n    guard !values.isEmpty else { return nil }\n    let sum = values.reduce(0, +)\n    return Double(sum) / Double(values.count)\n}",
    "output": "/// Возвращает среднее значение всех чисел в массиве\n/// - Parameter values: Массив чисел\n/// - Returns: Среднее значение\nfunc average(of values: [Int]) -> Double? {\n    guard !values.isEmpty else { return nil }\n    let sum = values.reduce(0, +)\n    return Double(sum) / Double(values.count)\n}"
  },
  {
    "input": "func toUppercase(input: String) -> String {\n    return input.uppercased()\n}",
    "output": "/// Преобразует строку в верхний регистр\n/// - Parameter input: Строка для преобразования\n/// - Returns: Строка в верхнем регистре\nfunc toUppercase(input: String) -> String {\n    return input.uppercased()\n}"
  },
  {
    "input": "func isValidNumber(input: String) -> Bool {\n    return Double(input) != nil\n}",
    "output": "/// Проверяет, является ли строка числом\n/// - Parameter input: Строка для проверки\n/// - Returns: `true`, если строка является числом, иначе `false`\nfunc isValidNumber(input: String) -> Bool {\n    return Double(input) != nil\n}"
  },
  {
    "input": "func minutesToHoursAndMinutes(minutes: Int) -> (Int, Int) {\n    let hours = minutes / 60\n    let remainingMinutes = minutes % 60\n    return (hours, remainingMinutes)\n}",
    "output": "/// Преобразует количество минут в часы и минуты\n/// - Parameter minutes: Количество минут\n/// - Returns: Кортеж с количеством часов и минут\nfunc minutesToHoursAndMinutes(minutes: Int) -> (Int, Int) {\n    let hours = minutes / 60\n    let remainingMinutes = minutes % 60\n    return (hours, remainingMinutes)\n}"
  },
  {
    "input": "func extractUppercaseLetters(from input: String) -> String {\n    return input.filter { $0.isUppercase }\n}",
    "output": "/// Возвращает строку, содержащую только заглавные буквы из исходной строки\n/// - Parameter input: Строка для обработки\n/// - Returns: Строка с заглавными буквами\nfunc extractUppercaseLetters(from input: String) -> String {\n    return input.filter { $0.isUppercase }\n}"
  },
  {
    "input": "func isFloatingPoint(input: String) -> Bool {\n    return input.contains(\".\") && Double(input) != nil\n}",
    "output": "/// Проверяет, является ли строка числом с плавающей запятой\n/// - Parameter input: Строка для проверки\n/// - Returns: `true`, если строка является числом с плавающей запятой, иначе `false`\nfunc isFloatingPoint(input: String) -> Bool {\n    return input.contains(\".\") && Double(input) != nil\n}"
  },
  {
    "input": "func maxNumber(in numbers: [Int]) -> Int? {\n    return numbers.max()\n}",
    "output": "/// Находит наибольшее число в массиве\n/// - Parameter numbers: Массив чисел\n/// - Returns: Наибольшее число\nfunc maxNumber(in numbers: [Int]) -> Int? {\n    return numbers.max()\n}"
  },
  {
    "input": "func stringToWordsUsingDash(input: String) -> [String] {\n    return input.split(separator: \"-\").map { String($0) }\n}",
    "output": "/// Преобразует строку в массив слов, разделённых дефисами\n/// - Parameter input: Строка для преобразования\n/// - Returns: Массив слов\nfunc stringToWordsUsingDash(input: String) -> [String] {\n    return input.split(separator: \"-\").map { String($0) }\n}"
  },
  {
    "input": "func minValue(in numbers: [Int]) -> Int? {\n    return numbers.min()\n}",
    "output": "/// Находит минимальное значение в массиве чисел\n/// - Parameter numbers: Массив чисел\n/// - Returns: Минимальное число\nfunc minValue(in numbers: [Int]) -> Int? {\n    return numbers.min()\n}"
  },
  {
    "input": "func triangleArea(base: Double, height: Double) -> Double {\n    return 0.5 * base * height\n}",
    "output": "/// Вычисляет площадь прямоугольного треугольника\n/// - Parameters:\n///   - base: Основание треугольника\n///   - height: Высота треугольника\n/// - Returns: Площадь треугольника\nfunc triangleArea(base: Double, height: Double) -> Double {\n    return 0.5 * base * height\n}"
  },
  {
    "input": "func isPalindromeIgnoringCase(input: String) -> Bool {\n    let lowercasedInput = input.lowercased()\n    return lowercasedInput == String(lowercasedInput.reversed())\n}",
    "output": "/// Проверяет, является ли строка палиндромом (игнорируя регистр)\n/// - Parameter input: Строка для проверки\n/// - Returns: `true`, если строка палиндром, иначе `false`\nfunc isPalindromeIgnoringCase(input: String) -> Bool {\n    let lowercasedInput = input.lowercased()\n    return lowercasedInput == String(lowercasedInput.reversed())\n}"
  },
  {
    "input": "func extractDigitsOnly(input: String) -> String {\n    return input.filter { $0.isNumber }\n}",
    "output": "/// Возвращает строку, состоящую только из цифр\n/// - Parameter input: Строка для обработки\n/// - Returns: Строка, содержащая только цифры\nfunc extractDigitsOnly(input: String) -> String {\n    return input.filter { $0.isNumber }\n}"
  },
  {
    "input": "func isValidEmail(email: String) -> Bool {\n    let emailRegex = \"^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\\\.[A-Za-z]{2,}$\"\n    let emailTest = NSPredicate(format: \"SELF MATCHES %@\", emailRegex)\n    return emailTest.evaluate(with: email)\n}",
    "output": "/// Проверяет, является ли строка валидным email-адресом\n/// - Parameter email: Строка для проверки\n/// - Returns: `true`, если строка является валидным email-адресом\nfunc isValidEmail(email: String) -> Bool {\n    let emailRegex = \"^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\\\.[A-Za-z]{2,}$\"\n    let emailTest = NSPredicate(format: \"SELF MATCHES %@\", emailRegex)\n    return emailTest.evaluate(with: email)\n}"
  },
  {
    "input": "func stringToArrayByComma(input: String) -> [String] {\n    return input.split(separator: \",\").map { String($0) }\n}",
    "output": "/// Преобразует строку в массив строк, разделённых запятой\n/// - Parameter input: Строка с элементами, разделёнными запятой\n/// - Returns: Массив строк\nfunc stringToArrayByComma(input: String) -> [String] {\n    return input.split(separator: \",\").map { String($0) }\n}"
  },
  {
    "input": "func isInteger(input: String) -> Bool {\n    return Int(input) != nil\n}",
    "output": "/// Проверяет, является ли строка представлением целого числа\n/// - Parameter input: Строка для проверки\n/// - Returns: `true`, если строка является целым числом, иначе `false`\nfunc isInteger(input: String) -> Bool {\n    return Int(input) != nil\n}"
  },
  {
    "input": "func countNonWhitespaceCharacters(in phrase: String) -> Int {\n    return phrase.filter { !$0.isWhitespace }.count\n}",
    "output": "/// Возвращает количество символов в строке без пробелов\n/// - Parameter phrase: Строка для анализа\n/// - Returns: Количество непустых символов\nfunc countNonWhitespaceCharacters(in phrase: String) -> Int {\n    return phrase.filter { !$0.isWhitespace }.count\n}"
  },
  {
    "input": "func startsWithCapital(text: String) -> Bool {\n    return text.first?.isUppercase ?? false\n}",
    "output": "/// Проверяет, начинается ли строка с заглавной буквы\n/// - Parameter text: Строка для проверки\n/// - Returns: `true`, если первый символ — заглавная буква\nfunc startsWithCapital(text: String) -> Bool {\n    return text.first?.isUppercase ?? false\n}"
  },
  {
    "input": "func removeDuplicates(from items: [String]) -> [String] {\n    return Array(Set(items))\n}",
    "output": "/// Удаляет повторяющиеся элементы из массива строк\n/// - Parameter items: Массив строк\n/// - Returns: Массив с уникальными значениями\nfunc removeDuplicates(from items: [String]) -> [String] {\n    return Array(Set(items))\n}"
  },
  {
    "input": "func formatAsCurrency(amount: Double) -> String {\n    let formatter = NumberFormatter()\n    formatter.numberStyle = .currency\n    return formatter.string(from: NSNumber(value: amount)) ?? \"\\(amount)\"\n}",
    "output": "/// Форматирует число как валюту\n/// - Parameter amount: Число для форматирования\n/// - Returns: Строка с валютным представлением\nfunc formatAsCurrency(amount: Double) -> String {\n    let formatter = NumberFormatter()\n    formatter.numberStyle = .currency\n    return formatter.string(from: NSNumber(value: amount)) ?? \"\\(amount)\"\n}"
  },
  {
    "input": "func isAlphabetic(input: String) -> Bool {\n    return !input.isEmpty && input.allSatisfy { $0.isLetter }\n}",
    "output": "/// Проверяет, содержит ли строка только буквы\n/// - Parameter input: Строка для проверки\n/// - Returns: `true`, если строка содержит только буквы\nfunc isAlphabetic(input: String) -> Bool {\n    return !input.isEmpty && input.allSatisfy { $0.isLetter }\n}"
  },
  {
    "input": "func median(of values: [Int]) -> Double? {\n    guard !values.isEmpty else { return nil }\n    let sorted = values.sorted()\n    let count = sorted.count\n    if count % 2 == 0 {\n        return Double(sorted[count / 2 - 1] + sorted[count / 2]) / 2\n    } else {\n        return Double(sorted[count / 2])\n    }\n}",
    "output": "/// Находит медиану массива чисел\n/// - Parameter values: Массив целых чисел\n/// - Returns: Медиана, если массив не пустой\nfunc median(of values: [Int]) -> Double? {\n    guard !values.isEmpty else { return nil }\n    let sorted = values.sorted()\n    let count = sorted.count\n    if count % 2 == 0 {\n        return Double(sorted[count / 2 - 1] + sorted[count / 2]) / 2\n    } else {\n        return Double(sorted[count / 2])\n    }\n}"
  },
  {
    "input": "func joinStrings(_ elements: [String], with separator: String) -> String {\n    return elements.joined(separator: separator)\n}",
    "output": "/// Конкатенирует строки с заданным разделителем\n/// - Parameters:\n///   - elements: Массив строк\n///   - separator: Разделитель\n/// - Returns: Объединённая строка\nfunc joinStrings(_ elements: [String], with separator: String) -> String {\n    return elements.joined(separator: separator)\n}"
  },
  {
    "input": "func containsValue<T: Equatable>(array: [T], value: T) -> Bool {\n    return array.contains(value)\n}",
    "output": "/// Проверяет, содержит ли массив заданный элемент\n/// - Parameters:\n///   - array: Массив значений\n///   - value: Элемент для поиска\n/// - Returns: `true`, если элемент найден\nfunc containsValue<T: Equatable>(array: [T], value: T) -> Bool {\n    return array.contains(value)\n}"
  },
  {
    "input": "func currentDateString() -> String {\n    let formatter = DateFormatter()\n    formatter.dateFormat = \"dd.MM.yyyy\"\n    return formatter.string(from: Date())\n}",
    "output": "/// Возвращает текущую дату в формате \"dd.MM.yyyy\"\n/// - Returns: Строка с текущей датой\nfunc currentDateString() -> String {\n    let formatter = DateFormatter()\n    formatter.dateFormat = \"dd.MM.yyyy\"\n    return formatter.string(from: Date())\n}"
  },
  {
    "input": "func daysBetween(from: Date, to: Date) -> Int {\n    return Calendar.current.dateComponents([.day], from: from, to: to).day ?? 0\n}",
    "output": "/// Вычисляет разницу между двумя датами в днях\n/// - Parameters:\n///   - from: Начальная дата\n///   - to: Конечная дата\n/// - Returns: Количество дней между датами\nfunc daysBetween(from: Date, to: Date) -> Int {\n    return Calendar.current.dateComponents([.day], from: from, to: to).day ?? 0\n}"
  },
  {
    "input": "func parseDate(from dateString: String, format: String) -> Date? {\n    let formatter = DateFormatter()\n    formatter.dateFormat = format\n    return formatter.date(from: dateString)\n}",
    "output": "/// Преобразует строку в дату\n/// - Parameters:\n///   - dateString: Строка с датой\n///   - format: Формат даты\n/// - Returns: Объект `Date`, если возможно\nfunc parseDate(from dateString: String, format: String) -> Date? {\n    let formatter = DateFormatter()\n    formatter.dateFormat = format\n    return formatter.date(from: dateString)\n}"
  },
  {
    "input": "func generateRandomNumbers(count: Int, range: ClosedRange<Int>) -> [Int] {\n    return (0..<count).map { _ in Int.random(in: range) }\n}",
    "output": "/// Генерирует массив случайных чисел\n/// - Parameters:\n///   - count: Количество чисел\n///   - range: Диапазон значений\n/// - Returns: Массив случайных чисел\nfunc generateRandomNumbers(count: Int, range: ClosedRange<Int>) -> [Int] {\n    return (0..<count).map { _ in Int.random(in: range) }\n}"
  },
  {
    "input": "func roundToPlaces(value: Double, places: Int) -> Double {\n    let multiplier = pow(10.0, Double(places))\n    return (value * multiplier).rounded() / multiplier\n}",
    "output": "/// Округляет число до заданного количества знаков после запятой\n/// - Parameters:\n///   - value: Число для округления\n///   - places: Количество знаков после запятой\n/// - Returns: Округлённое число\nfunc roundToPlaces(value: Double, places: Int) -> Double {\n    let multiplier = pow(10.0, Double(places))\n    return (value * multiplier).rounded() / multiplier\n}"
  },
  {
    "input": "func parseJSON(from jsonString: String) -> [String: Any]? {\n    guard let data = jsonString.data(using: .utf8) else { return nil }\n    return try? JSONSerialization.jsonObject(with: data) as? [String: Any]\n}",
    "output": "/// Преобразует строку в JSON-объект\n/// - Parameter jsonString: Строка в формате JSON\n/// - Returns: Словарь с данными, если успешно\nfunc parseJSON(from jsonString: String) -> [String: Any]? {\n    guard let data = jsonString.data(using: .utf8) else { return nil }\n    return try? JSONSerialization.jsonObject(with: data) as? [String: Any]\n}"
  },
  {
    "input": "func removeCharacter(from input: String, character: Character) -> String {\n    return input.filter { $0 != character }\n}",
    "output": "/// Удаляет все вхождения указанного символа из строки\n/// - Parameters:\n///   - input: Исходная строка\n///   - character: Символ для удаления\n/// - Returns: Строка без заданного символа\nfunc removeCharacter(from input: String, character: Character) -> String {\n    return input.filter { $0 != character }\n}"
  },
  {
    "input": "func containsSubstring(text: String, substring: String) -> Bool {\n    return text.range(of: substring) != nil\n}",
    "output": "/// Проверяет, содержит ли строка заданную подстроку\n/// - Parameters:\n///   - text: Исходная строка\n///   - substring: Подстрока для поиска\n/// - Returns: `true`, если подстрока найдена\nfunc containsSubstring(text: String, substring: String) -> Bool {\n    return text.range(of: substring) != nil\n}"
  },
  {
    "input": "func boolToRussianString(_ value: Bool) -> String {\n    return value ? \"Да\" : \"Нет\"\n}",
    "output": "/// Переводит Boolean в строку \"Да\" или \"Нет\"\n/// - Parameter value: Булево значение\n/// - Returns: \"Да\" для `true`, \"Нет\" для `false`\nfunc boolToRussianString(_ value: Bool) -> String {\n    return value ? \"Да\" : \"Нет\"\n}"
  },
  {
    "input": "func endsWith(string: String, suffix: String) -> Bool {\n    return string.hasSuffix(suffix)\n}",
    "output": "/// Проверяет, заканчивается ли строка определённым суффиксом\n/// - Parameters:\n///   - string: Исходная строка\n///   - suffix: Суффикс\n/// - Returns: `true`, если строка заканчивается на суффикс\nfunc endsWith(string: String, suffix: String) -> Bool {\n    return string.hasSuffix(suffix)\n}"
  },
  {
    "input": "func lengths(of strings: [String]) -> [Int] {\n    return strings.map { $0.count }\n}",
    "output": "/// Возвращает массив с длинами строк\n/// - Parameter strings: Массив строк\n/// - Returns: Массив длин строк\nfunc lengths(of strings: [String]) -> [Int] {\n    return strings.map { $0.count }\n}"
  },
  {
    "input": "func isDictionaryEmpty<K, V>(_ dict: [K: V]) -> Bool {\n    return dict.isEmpty\n}",
    "output": "/// Проверяет, пуст ли словарь\n/// - Parameter dict: Словарь для проверки\n/// - Returns: `true`, если словарь пустой\nfunc isDictionaryEmpty<K, V>(_ dict: [K: V]) -> Bool {\n    return dict.isEmpty\n}"
  },
  {
    "input": "func toUpperCase(input: String) -> String {\n    return input.uppercased()\n}",
    "output": "/// Возвращает строку в верхнем регистре\n/// - Parameter input: Строка для преобразования\n/// - Returns: Строка в верхнем регистре\nfunc toUpperCase(input: String) -> String {\n    return input.uppercased()\n}"
  },
  {
    "input": "func isEmpty(text: String) -> Bool {\n    return text.isEmpty\n}",
    "output": "/// Проверяет, является ли строка пустой\n/// - Parameter text: Строка для проверки\n/// - Returns: `true`, если строка пустая, иначе `false`\nfunc isEmpty(text: String) -> Bool {\n    return text.isEmpty\n}"
  },
  {
    "input": "func max(of values: [Int]) -> Int? {\n    return values.max()\n}",
    "output": "/// Возвращает наибольшее число в массиве\n/// - Parameter values: Массив чисел\n/// - Returns: Наибольшее число в массиве\nfunc max(of values: [Int]) -> Int? {\n    return values.max()\n}"
  },
  {
    "input": "func circleArea(radius: Double) -> Double {\n    return .pi * pow(radius, 2)\n}",
    "output": "/// Вычисляет площадь круга\n/// - Parameter radius: Радиус круга\n/// - Returns: Площадь круга\nfunc circleArea(radius: Double) -> Double {\n    return .pi * pow(radius, 2)\n}"
  },
  {
    "input": "func stringToCharacterArray(input: String) -> [Character] {\n    return Array(input)\n}",
    "output": "/// Преобразует строку в массив символов\n/// - Parameter input: Строка для преобразования\n/// - Returns: Массив символов\nfunc stringToCharacterArray(input: String) -> [Character] {\n    return Array(input)\n}"
  },
  {
    "input": "func indexOf<T>(in array: [T], element: T) -> Int? where T: Equatable {\n    return array.firstIndex(of: element)\n}",
    "output": "/// Находит индекс элемента в массиве\n/// - Parameters:\n///   - array: Массив для поиска\n///   - element: Элемент для поиска\n/// - Returns: Индекс элемента или `nil`, если не найден\nfunc indexOf<T>(in array: [T], element: T) -> Int? where T: Equatable {\n    return array.firstIndex(of: element)\n}"
  },
  {
    "input": "func isPositive(number: Int) -> Bool {\n    return number > 0\n}",
    "output": "/// Проверяет, является ли число положительным\n/// - Parameter number: Число для проверки\n/// - Returns: `true`, если число положительное\nfunc isPositive(number: Int) -> Bool {\n    return number > 0\n}"
  },
  {
    "input": "func factorial(of n: Int) -> Int {\n    return n == 0 ? 1 : n * factorial(of: n - 1)\n}",
    "output": "/// Находит факториал числа\n/// - Parameter n: Число для вычисления факториала\n/// - Returns: Факториал числа\nfunc factorial(of n: Int) -> Int {\n    return n == 0 ? 1 : n * factorial(of: n - 1)\n}"
  },
  {
    "input": "func stringToWords(input: String) -> [String] {\n    return input.split(separator: \" \").map { String($0) }\n}",
    "output": "/// Преобразует строку в массив слов\n/// - Parameter input: Строка для преобразования\n/// - Returns: Массив слов\nfunc stringToWords(input: String) -> [String] {\n    return input.split(separator: \" \").map { String($0) }\n}"
  },
  {
    "input": "func average(of numbers: [Double]) -> Double? {\n    guard !numbers.isEmpty else { return nil }\n    let sum = numbers.reduce(0, +)\n    return sum / Double(numbers.count)\n}",
    "output": "/// Возвращает среднее значение элементов массива\n/// - Parameter numbers: Массив чисел\n/// - Returns: Среднее значение\nfunc average(of numbers: [Double]) -> Double? {\n    guard !numbers.isEmpty else { return nil }\n    let sum = numbers.reduce(0, +)\n    return sum / Double(numbers.count)\n}"
  },
  {
    "input": "func stringToIntArray(input: String) -> [Int]? {\n    return input.split(separator: \",\").compactMap { Int($0.trimmingCharacters(in: .whitespaces)) }\n}",
    "output": "/// Преобразует строку в массив чисел, разделённых запятой\n/// - Parameter input: Строка для преобразования\n/// - Returns: Массив чисел\nfunc stringToIntArray(input: String) -> [Int]? {\n    return input.split(separator: \",\").compactMap { Int($0.trimmingCharacters(in: .whitespaces)) }\n}"
  },
  {
    "input": "func isFloat(input: String) -> Bool {\n    return Double(input) != nil\n}",
    "output": "/// Проверяет, является ли строка числом с плавающей запятой\n/// - Parameter input: Строка для проверки\n/// - Returns: `true`, если строка является числом с плавающей запятой\nfunc isFloat(input: String) -> Bool {\n    return Double(input) != nil\n}"
  },
  {
    "input": "func randomNumber(min: Int, max: Int) -> Int {\n    return Int.random(in: min...max)\n}",
    "output": "/// Генерирует случайное число в диапазоне от `min` до `max`\n/// - Parameters:\n///   - min: Минимальное значение диапазона\n///   - max: Максимальное значение диапазона\n/// - Returns: Случайное число в указанном диапазоне\nfunc randomNumber(min: Int, max: Int) -> Int {\n    return Int.random(in: min...max)\n}"
  },
  {
    "input": "func toLowerCase(input: String) -> String {\n    return input.lowercased()\n}",
    "output": "/// Возвращает строку в нижнем регистре\n/// - Parameter input: Строка для преобразования\n/// - Returns: Строка в нижнем регистре\nfunc toLowerCase(input: String) -> String {\n    return input.lowercased()\n}"
  },
  {
    "input": "func isEven(number: Int) -> Bool {\n    return number % 2 == 0\n}",
    "output": "/// Проверяет, является ли число чётным\n/// - Parameter number: Число для проверки\n/// - Returns: `true`, если число чётное, иначе `false`\nfunc isEven(number: Int) -> Bool {\n    return number % 2 == 0\n}"
  },
  {
    "input": "func stringToFloat(input: String) -> Float? {\n    return Float(input)\n}",
    "output": "/// Преобразует строку в число с плавающей запятой\n/// - Parameter input: Строка для преобразования\n/// - Returns: Число с плавающей запятой или `nil`, если преобразование невозможно\nfunc stringToFloat(input: String) -> Float? {\n    return Float(input)\n}"
  },
  {
    "input": "func isPalindrome(input: String) -> Bool {\n    let reversed = String(input.reversed())\n    return input == reversed\n}",
    "output": "/// Проверяет, является ли строка палиндромом\n/// - Parameter input: Строка для проверки\n/// - Returns: `true`, если строка палиндром\nfunc isPalindrome(input: String) -> Bool {\n    let reversed = String(input.reversed())\n    return input == reversed\n}"
  },
  {
    "input": "func min(of numbers: [Int]) -> Int? {\n    return numbers.min()\n}",
    "output": "/// Находит минимальное число в массиве\n/// - Parameter numbers: Массив чисел\n/// - Returns: Минимальное число в массиве\nfunc min(of numbers: [Int]) -> Int? {\n    return numbers.min()\n}"
  },
  {
    "input": "func stringToDate(dateString: String, format: String) -> Date? {\n    let formatter = DateFormatter()\n    formatter.dateFormat = format\n    return formatter.date(from: dateString)\n}",
    "output": "/// Преобразует строку в дату по заданному формату\n/// - Parameters:\n///   - dateString: Строка с датой\n///   - format: Формат строки даты\n/// - Returns: Дата, если возможно преобразовать\nfunc stringToDate(dateString: String, format: String) -> Date? {\n    let formatter = DateFormatter()\n    formatter.dateFormat = format\n    return formatter.date(from: dateString)\n}"
  },
  {
    "input": "func numbersToString(numbers: [Int]) -> String {\n    return numbers.map { String($0) }.joined(separator: \", \")\n}",
    "output": "/// Преобразует массив чисел в строку, разделённую запятыми\n/// - Parameter numbers: Массив чисел\n/// - Returns: Строка с числами, разделёнными запятыми\nfunc numbersToString(numbers: [Int]) -> String {\n    return numbers.map { String($0) }.joined(separator: \", \")\n}"
  },
  {
    "input": "func isValidEmail(input: String) -> Bool {\n    let regex = \"[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\\\.[A-Za-z]{2,}\"\n    let test = NSPredicate(format: \"SELF MATCHES %@\", regex)\n    return test.evaluate(with: input)\n}",
    "output": "/// Проверяет, является ли строка валидным email-адресом\n/// - Parameter input: Строка для проверки\n/// - Returns: `true`, если строка является валидным email\nfunc isValidEmail(input: String) -> Bool {\n    let regex = \"[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\\\.[A-Za-z]{2,}\"\n    let test = NSPredicate(format: \"SELF MATCHES %@\", regex)\n    return test.evaluate(with: input)\n}"
  },
  {
    "input": "func replaceSpacesWithHyphens(input: String) -> String {\n    return input.replacingOccurrences(of: \" \", with: \"-\")\n}",
    "output": "/// Возвращает строку, в которой все пробелы заменены на дефисы\n/// - Parameter input: Строка для преобразования\n/// - Returns: Строка с дефисами вместо пробелов\nfunc replaceSpacesWithHyphens(input: String) -> String {\n    return input.replacingOccurrences(of: \" \", with: \"-\")\n}"
  },
  {
    "input": "func isNegative(number: Int) -> Bool {\n    return number < 0\n}",
    "output": "/// Проверяет, является ли число отрицательным\n/// - Parameter number: Число для проверки\n/// - Returns: `true`, если число отрицательное, иначе `false`\nfunc isNegative(number: Int) -> Bool {\n    return number < 0\n}"
  },
  {
    "input": "func rectangleArea(length: Double, width: Double) -> Double {\n    return length * width\n}",
    "output": "/// Вычисляет площадь прямоугольника\n/// - Parameters:\n///   - length: Длина прямоугольника\n///   - width: Ширина прямоугольника\n/// - Returns: Площадь прямоугольника\nfunc rectangleArea(length: Double, width: Double) -> Double {\n    return length * width\n}"
  },
  {
    "input": "func isNumber(input: String) -> Bool {\n    return Int(input) != nil || Double(input) != nil\n}",
    "output": "/// Проверяет, является ли строка числом\n/// - Parameter input: Строка для проверки\n/// - Returns: `true`, если строка является числом, иначе `false`\nfunc isNumber(input: String) -> Bool {\n    return Int(input) != nil || Double(input) != nil\n}"
  },
  {
    "input": "func removeDigits(from input: String) -> String {\n    return input.filter { !$0.isNumber }\n}",
    "output": "/// Возвращает строку с удалением всех цифр\n/// - Parameter input: Строка для обработки\n/// - Returns: Строка без цифр\nfunc removeDigits(from input: String) -> String {\n    return input.filter { !$0.isNumber }\n}"
  },
  {
    "input": "func minutesToHoursAndMinutes(minutes: Int) -> (Int, Int) {\n    let hours = minutes / 60\n    let remainingMinutes = minutes % 60\n    return (hours, remainingMinutes)\n}",
    "output": "/// Преобразует минут в часы и минуты\n/// - Parameter minutes: Количество минут\n/// - Returns: Кортеж с количеством часов и минут\nfunc minutesToHoursAndMinutes(minutes: Int) -> (Int, Int) {\n    let hours = minutes / 60\n    let remainingMinutes = minutes % 60\n    return (hours, remainingMinutes)\n}"
  },
  {
    "input": "func stringToUppercaseCharacters(input: String) -> [Character] {\n    return input.uppercased().map { $0 }\n}",
    "output": "/// Преобразует строку в массив символов в верхнем регистре\n/// - Parameter input: Строка для преобразования\n/// - Returns: Массив символов в верхнем регистре\nfunc stringToUppercaseCharacters(input: String) -> [Character] {\n    return input.uppercased().map { $0 }\n}"
  },
  {
    "input": "func isValidURL(input: String) -> Bool {\n    return URL(string: input) != nil\n}",
    "output": "/// Проверяет, является ли строка валидным URL\n/// - Parameter input: Строка для проверки\n/// - Returns: `true`, если строка является валидным URL, иначе `false`\nfunc isValidURL(input: String) -> Bool {\n    return URL(string: input) != nil\n}"
  },
  {
    "input": "func randomString() -> String {\n    let characters = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\"\n    return String((0..<8).map { _ in characters.randomElement()! })\n}",
    "output": "/// Генерирует случайную строку длиной 8 символов\n/// - Returns: Случайная строка\nfunc randomString() -> String {\n    let characters = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\"\n    return String((0..<8).map { _ in characters.randomElement()! })\n}"
  },
  {
    "input": "func stringToFloatArray(input: String) -> [Float]? {\n    return input.split(separator: \",\").compactMap { Float($0) }\n}",
    "output": "/// Преобразует строку в массив чисел с плавающей запятой\n/// - Parameter input: Строка с числами\n/// - Returns: Массив чисел с плавающей запятой\nfunc stringToFloatArray(input: String) -> [Float]? {\n    return input.split(separator: \",\").compactMap { Float($0) }\n}"
  },
  {
    "input": "func isPalindromeIgnoringSpacesAndCase(input: String) -> Bool {\n    let cleanedInput = input.replacingOccurrences(of: \" \", with: \"\").lowercased()\n    return cleanedInput == String(cleanedInput.reversed())\n}",
    "output": "/// Проверяет, является ли строка палиндромом (игнорируя пробелы и регистр)\n/// - Parameter input: Строка для проверки\n/// - Returns: `true`, если строка палиндром\nfunc isPalindromeIgnoringSpacesAndCase(input: String) -> Bool {\n    let cleanedInput = input.replacingOccurrences(of: \" \", with: \"\").lowercased()\n    return cleanedInput == String(cleanedInput.reversed())\n}"
  },
  {
    "input": "func sum(of numbers: [Int]) -> Int {\n    return numbers.reduce(0, +)\n}",
    "output": "/// Находит сумму чисел в массиве\n/// - Parameter numbers: Массив чисел\n/// - Returns: Сумма чисел\nfunc sum(of numbers: [Int]) -> Int {\n    return numbers.reduce(0, +)\n}"
  },
  {
    "input": "func stringToCharacterArrayWithSpaces(input: String) -> [Character] {\n    return Array(input)\n}",
    "output": "/// Преобразует строку в массив символов, включая пробелы\n/// - Parameter input: Строка для преобразования\n/// - Returns: Массив символов\nfunc stringToCharacterArrayWithSpaces(input: String) -> [Character] {\n    return Array(input)\n}"
  },
  {
    "input": "func dateToString(date: Date, format: String) -> String {\n    let formatter = DateFormatter()\n    formatter.dateFormat = format\n    return formatter.string(from: date)\n}",
    "output": "/// Преобразует дату в строку с заданным форматом\n/// - Parameters:\n///   - date: Дата для преобразования\n///   - format: Формат даты\n/// - Returns: Строка с датой в нужном формате\nfunc dateToString(date: Date, format: String) -> String {\n    let formatter = DateFormatter()\n    formatter.dateFormat = format\n    return formatter.string(from: date)\n}"
  },
  {
    "input": "func hypotenuseLength(sideA: Double, sideB: Double) -> Double {\n    return sqrt(pow(sideA, 2) + pow(sideB, 2))\n}",
    "output": "/// Вычисляет длину гипотенузы прямоугольного треугольника\n/// - Parameters:\n///   - sideA: Одна из сторон треугольника\n///   - sideB: Другая сторона треугольника\n/// - Returns: Длина гипотенузы\nfunc hypotenuseLength(sideA: Double, sideB: Double) -> Double {\n    return sqrt(pow(sideA, 2) + pow(sideB, 2))\n}"
  },
  {
    "input": "func isInteger(input: String) -> Bool {\n    return Int(input) != nil\n}",
    "output": "/// Проверяет, является ли число целым числом\n/// - Parameter input: Строка для проверки\n/// - Returns: `true`, если строка представляет собой целое число\nfunc isInteger(input: String) -> Bool {\n    return Int(input) != nil\n}"
  },
  {
    "input": "func replaceSpacesWithUnderscores(input: String) -> String {\n    return input.replacingOccurrences(of: \" \", with: \"_\")\n}",
    "output": "/// Возвращает строку с заменой всех пробелов на подчеркивания\n/// - Parameter input: Строка для преобразования\n/// - Returns: Строка с подчеркиваниями вместо пробелов\nfunc replaceSpacesWithUnderscores(input: String) -> String {\n    return input.replacingOccurrences(of: \" \", with: \"_\")\n}"
  },
  {
    "input": "func stringToWordsUsingDashes(input: String) -> [String] {\n    return input.split(separator: \"-\").map { String($0) }\n}",
    "output": "/// Преобразует строку в массив слов, разделённых дефисами\n/// - Parameter input: Строка для преобразования\n/// - Returns: Массив слов\nfunc stringToWordsUsingDashes(input: String) -> [String] {\n    return input.split(separator: \"-\").map { String($0) }\n}"
  },
  {
    "input": "func isHexadecimal(input: String) -> Bool {\n    let hexRegex = \"^[0-9A-Fa-f]+$\"\n    let hexTest = NSPredicate(format: \"SELF MATCHES %@\", hexRegex)\n    return hexTest.evaluate(with: input)\n}",
    "output": "/// Проверяет, является ли строка числом в шестнадцатеричной системе\n/// - Parameter input: Строка для проверки\n/// - Returns: `true`, если строка представляет собой число в шестнадцатеричной системе\nfunc isHexadecimal(input: String) -> Bool {\n    let hexRegex = \"^[0-9A-Fa-f]+$\"\n    let hexTest = NSPredicate(format: \"SELF MATCHES %@\", hexRegex)\n    return hexTest.evaluate(with: input)\n}"
  },
  {
    "input": "func stringToInteger(input: String) -> Int? {\n    return Int(input)\n}",
    "output": "/// Преобразует строку в целое число\n/// - Parameter input: Строка для преобразования\n/// - Returns: Число, если преобразование успешно, иначе `nil`\nfunc stringToInteger(input: String) -> Int? {\n    return Int(input)\n}"
  },
  {
    "input": "func extractLetters(from input: String) -> [Character] {\n    return input.filter { $0.isLetter }\n}",
    "output": "/// Преобразует строку в массив символов, состоящих только из букв\n/// - Parameter input: Строка для преобразования\n/// - Returns: Массив символов, состоящих только из букв\nfunc extractLetters(from input: String) -> [Character] {\n    return input.filter { $0.isLetter }\n}"
  },
  {
    "input": "func extractDigits(from input: String) -> String {\n    return input.filter { $0.isNumber }\n}",
    "output": "/// Возвращает строку, состоящую из цифр, найденных в исходной строке\n/// - Parameter input: Строка для обработки\n/// - Returns: Строка с цифрами\nfunc extractDigits(from input: String) -> String {\n    return input.filter { $0.isNumber }\n}"
  },
  {
    "input": "func isFloatingPoint(input: String) -> Bool {\n    return Float(input) != nil\n}",
    "output": "/// Проверяет, является ли строка числом с плавающей запятой\n/// - Parameter input: Строка для проверки\n/// - Returns: `true`, если строка является числом с плавающей запятой, иначе `false`\nfunc isFloatingPoint(input: String) -> Bool {\n    return Float(input) != nil\n}"
  },
  {
    "input": "func reverseString(input: String) -> String {\n    return String(input.reversed())\n}",
    "output": "/// Возвращает строку в обратном порядке\n/// - Parameter input: Строка для переворота\n/// - Returns: Перевернутая строка\nfunc reverseString(input: String) -> String {\n    return String(input.reversed())\n}"
  },
  {
    "input": "func squarePerimeter(side: Double) -> Double {\n    return 4 * side\n}",
    "output": "/// Вычисляет периметр квадрата\n/// - Parameter side: Длина стороны квадрата\n/// - Returns: Периметр квадрата\nfunc squarePerimeter(side: Double) -> Double {\n    return 4 * side\n}"
  },
  {
    "input": "func min(of values: [Int]) -> Int? {\n    return values.min()\n}",
    "output": "/// Находит наименьшее число в массиве\n/// - Parameter values: Массив чисел\n/// - Returns: Наименьшее число в массиве\nfunc min(of values: [Int]) -> Int? {\n    return values.min()\n}"
  },
  {
    "input": "func isPalindromeIgnoringSpaces(input: String) -> Bool {\n    let cleanedInput = input.replacingOccurrences(of: \" \", with: \"\").lowercased()\n    return cleanedInput == String(cleanedInput.reversed())\n}",
    "output": "/// Проверяет, является ли строка палиндромом (игнорируя пробелы)\n/// - Parameter input: Строка для проверки\n/// - Returns: `true`, если строка является палиндромом\nfunc isPalindromeIgnoringSpaces(input: String) -> Bool {\n    let cleanedInput = input.replacingOccurrences(of: \" \", with: \"\").lowercased()\n    return cleanedInput == String(cleanedInput.reversed())\n}"
  },
  {
    "input": "func toUpperCase(input: String) -> String {\n    return input.uppercased()\n}",
    "output": "/// Преобразует строку в заглавные буквы\n/// - Parameter input: Строка для преобразования\n/// - Returns: Строка с заглавными буквами\nfunc toUpperCase(input: String) -> String {\n    return input.uppercased()\n}"
  },
  {
    "input": "func stringToDate(dateString: String, format: String) -> Date? {\n    let formatter = DateFormatter()\n    formatter.dateFormat = format\n    return formatter.date(from: dateString)\n}",
    "output": "/// Преобразует строку в дату по заданному формату\n/// - Parameters:\n///   - dateString: Строка с датой\n///   - format: Формат строки даты\n/// - Returns: Дата, если возможно преобразовать\nfunc stringToDate(dateString: String, format: String) -> Date? {\n    let formatter = DateFormatter()\n    formatter.dateFormat = format\n    return formatter.date(from: dateString)\n}"
  },
  {
    "input": "func isBlank(input: String) -> Bool {\n    return input.trimmingCharacters(in: .whitespaces).isEmpty\n}",
    "output": "/// Проверяет, является ли строка пустой или состоит только из пробелов\n/// - Parameter input: Строка для проверки\n/// - Returns: `true`, если строка пустая или состоит только из пробелов\nfunc isBlank(input: String) -> Bool {\n    return input.trimmingCharacters(in: .whitespaces).isEmpty\n}"
  },
  {
    "input": "func stringToIntArray(input: String) -> [Int]? {\n    return input.split(separator: \",\").compactMap { Int($0) }\n}",
    "output": "/// Преобразует строку в массив целых чисел\n/// - Parameter input: Строка для преобразования\n/// - Returns: Массив целых чисел\nfunc stringToIntArray(input: String) -> [Int]? {\n    return input.split(separator: \",\").compactMap { Int($0) }\n}"
  },
  {
    "input": "func maskString(input: String) -> String {\n    return String(repeating: \"*\", count: input.count)\n}",
    "output": "/// Возвращает строку, в которой все символы заменены на звёздочки\n/// - Parameter input: Строка для обработки\n/// - Returns: Строка с символами-звёздочками\nfunc maskString(input: String) -> String {\n    return String(repeating: \"*\", count: input.count)\n}"
  },
  {
    "input": "func isDecimal(input: String) -> Bool {\n    return input.range(of: \"^[0-9]+(\\\\.[0-9]+)?$\", options: .regularExpression) != nil\n}",
    "output": "/// Проверяет, является ли строка числом в десятичной системе\n/// - Parameter input: Строка для проверки\n/// - Returns: `true`, если строка является десятичным числом\nfunc isDecimal(input: String) -> Bool {\n    return input.range(of: \"^[0-9]+(\\\\.[0-9]+)?$\", options: .regularExpression) != nil\n}"
  },
  {
    "input": "func firstIndex<T>(of element: T, in array: [T]) -> Int? where T: Equatable {\n    return array.firstIndex(of: element)\n}",
    "output": "/// Находит индекс первого вхождения элемента в массиве\n/// - Parameters:\n///   - array: Массив значений\n///   - element: Элемент для поиска\n/// - Returns: Индекс первого вхождения элемента или `nil`, если не найден\nfunc firstIndex<T>(of element: T, in array: [T]) -> Int? where T: Equatable {\n    return array.firstIndex(of: element)\n}"
  },
  {
    "input": "func secondsToTimeFormat(seconds: Int) -> String {\n    let hours = seconds / 3600\n    let minutes = (seconds % 3600) / 60\n    let remainingSeconds = seconds % 60\n    return String(format: \"%02d:%02d:%02d\", hours, minutes, remainingSeconds)\n}",
    "output": "/// Конвертирует количество секунд в формат \"ЧЧ:ММ:СС\"\n/// - Parameter seconds: Количество секунд\n/// - Returns: Строка в формате \"ЧЧ:ММ:СС\"\nfunc secondsToTimeFormat(seconds: Int) -> String {\n    let hours = seconds / 3600\n    let minutes = (seconds % 3600) / 60\n    let remainingSeconds = seconds % 60\n    return String(format: \"%02d:%02d:%02d\", hours, minutes, remainingSeconds)\n}"
  },
  {
    "input": "func removeSpaces(input: String) -> String {\n    return input.replacingOccurrences(of: \" \", with: \"\")\n}",
    "output": "/// Возвращает строку, состоящую только из символов, не являющихся пробелами\n/// - Parameter input: Строка для обработки\n/// - Returns: Строка без пробелов\nfunc removeSpaces(input: String) -> String {\n    return input.replacingOccurrences(of: \" \", with: \"\")\n}"
  },
  {
    "input": "func stringToWordsArray(input: String) -> [String] {\n    return input.split(separator: \" \").map { String($0) }\n}",
    "output": "/// Преобразует строку в массив строк, разделённых пробелами\n/// - Parameter input: Строка для преобразования\n/// - Returns: Массив строк\nfunc stringToWordsArray(input: String) -> [String] {\n    return input.split(separator: \" \").map { String($0) }\n}"
  },
  {
    "input": "func isValidEmail(input: String) -> Bool {\n    let regex = \"[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\\\.[A-Za-z]{2,}\"\n    let test = NSPredicate(format: \"SELF MATCHES %@\", regex)\n    return test.evaluate(with: input)\n}",
    "output": "/// Проверяет, является ли строка валидным email-адресом\n/// - Parameter input: Строка для проверки\n/// - Returns: `true`, если строка является валидным email\nfunc isValidEmail(input: String) -> Bool {\n    let regex = \"[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\\\.[A-Za-z]{2,}\"\n    let test = NSPredicate(format: \"SELF MATCHES %@\", regex)\n    return test.evaluate(with: input)\n}"
  },
  {
    "input": "func stringToCharacterArrayWithoutPunctuation(input: String) -> [Character] {\n    let punctuationSet = CharacterSet.punctuationCharacters\n    let cleanedInput = input.components(separatedBy: punctuationSet).joined()\n    return Array(cleanedInput)\n}",
    "output": "/// Преобразует строку в массив символов, исключая пробелы и знаки препинания\n/// - Parameter input: Строка для преобразования\n/// - Returns: Массив символов без пробелов и знаков препинания\nfunc stringToCharacterArrayWithoutPunctuation(input: String) -> [Character] {\n    let punctuationSet = CharacterSet.punctuationCharacters\n    let cleanedInput = input.components(separatedBy: punctuationSet).joined()\n    return Array(cleanedInput)\n}"
  },
  {
    "input": "func factorial(of n: Int) -> Int {\n    return (1...max(n,1)).reduce(1, *)\n}",
    "output": "/// Вычисляет факториал целого числа\n/// - Parameter n: Целое число\n/// - Returns: Факториал числа\nfunc factorial(of n: Int) -> Int {\n    return (1...max(n,1)).reduce(1, *)\n}"
  },
  {
    "input": "func isPalindrome(_ text: String) -> Bool {\n    let filtered = text.lowercased().filter { $0.isLetter }\n    return filtered == String(filtered.reversed())\n}",
    "output": "/// Проверяет, является ли строка палиндромом\n/// - Parameter text: Входная строка\n/// - Returns: true, если строка палиндром\nfunc isPalindrome(_ text: String) -> Bool {\n    let filtered = text.lowercased().filter { $0.isLetter }\n    return filtered == String(filtered.reversed())\n}"
  },
  {
    "input": "func celsiusToFahrenheit(_ celsius: Double) -> Double {\n    return celsius * 9 / 5 + 32\n}",
    "output": "/// Преобразует температуру из Цельсия в Фаренгейты\n/// - Parameter celsius: Температура в градусах Цельсия\n/// - Returns: Температура в градусах Фаренгейта\nfunc celsiusToFahrenheit(_ celsius: Double) -> Double {\n    return celsius * 9 / 5 + 32\n}"
  },
  {
    "input": "func generateUsername() -> String {\n    let adjectives = [\"Fast\", \"Cool\", \"Silent\", \"Smart\"]\n    let animals = [\"Fox\", \"Wolf\", \"Bear\", \"Eagle\"]\n    return \"\\(adjectives.randomElement()!)\\(animals.randomElement()!)\\(Int.random(in: 10...99))\"\n}",
    "output": "/// Генерирует случайное имя пользователя\n/// - Returns: Строка с псевдослучайным именем\nfunc generateUsername() -> String {\n    let adjectives = [\"Fast\", \"Cool\", \"Silent\", \"Smart\"]\n    let animals = [\"Fox\", \"Wolf\", \"Bear\", \"Eagle\"]\n    return \"\\(adjectives.randomElement()!)\\(animals.randomElement()!)\\(Int.random(in: 10...99))\"\n}"
  },
  {
    "input": "func sortByLength(_ strings: [String]) -> [String] {\n    return strings.sorted { $0.count < $1.count }\n}",
    "output": "/// Сортирует массив строк по длине\n/// - Parameter strings: Массив строк\n/// - Returns: Отсортированный массив по возрастанию длины\nfunc sortByLength(_ strings: [String]) -> [String] {\n    return strings.sorted { $0.count < $1.count }\n}"
  },
  {
    "input": "func rgbToHex(r: Int, g: Int, b: Int) -> String {\n    return String(format:\"#%02X%02X%02X\", r, g, b)\n}",
    "output": "/// Преобразует RGB в HEX\n/// - Parameters:\n///   - r: Красный компонент (0...255)\n///   - g: Зеленый компонент (0...255)\n///   - b: Синий компонент (0...255)\n/// - Returns: Строка HEX-кода цвета\nfunc rgbToHex(r: Int, g: Int, b: Int) -> String {\n    return String(format:\"#%02X%02X%02X\", r, g, b)\n}"
  },
  {
    "input": "func rectangleArea(width: Double, height: Double) -> Double {\n    return width * height\n}",
    "output": "/// Возвращает площадь прямоугольника\n/// - Parameters:\n///   - width: Ширина\n///   - height: Высота\n/// - Returns: Площадь\nfunc rectangleArea(width: Double, height: Double) -> Double {\n    return width * height\n}"
  },
  {
    "input": "func containsDigit(_ input: String) -> Bool {\n    return input.contains { $0.isNumber }\n}",
    "output": "/// Проверяет, содержит ли строка хотя бы одну цифру\n/// - Parameter input: Строка для проверки\n/// - Returns: true, если найдена цифра\nfunc containsDigit(_ input: String) -> Bool {\n    return input.contains { $0.isNumber }\n}"
  },
  {
    "input": "func countVowels(in input: String) -> Int {\n    let vowels = \"aeiouаеёиоуыэюя\"\n    return input.lowercased().filter { vowels.contains($0) }.count\n}",
    "output": "/// Возвращает количество гласных в строке\n/// - Parameter input: Исходная строка\n/// - Returns: Количество гласных букв\nfunc countVowels(in input: String) -> Int {\n    let vowels = \"aeiouаеёиоуыэюя\"\n    return input.lowercased().filter { vowels.contains($0) }.count\n}"
  },
  {
    "input": "func joinStrings(first: String, second: String, third: String) -> String {\n    return first + second + third\n}",
    "output": "/// Конкатенирует три строки\n/// - Parameters:\n///   - first: Первая строка\n///   - second: Вторая строка\n///   - third: Третья строка\n/// - Returns: Объединенная строка\nfunc joinStrings(first: String, second: String, third: String) -> String {\n    return first + second + third\n}"
  },
  {
    "input": "func isEven(_ number: Int) -> Bool {\n    return number % 2 == 0\n}",
    "output": "/// Проверяет, является ли число четным\n/// - Parameter number: Целое число\n/// - Returns: true, если число четное\nfunc isEven(_ number: Int) -> Bool {\n    return number % 2 == 0\n}"
  },
  {
    "input": "func maxValue(in values: [Double]) -> Double? {\n    return values.max()\n}",
    "output": "/// Находит наибольшее значение в массиве Double\n/// - Parameter values: Массив чисел\n/// - Returns: Максимальное значение или nil, если массив пуст\nfunc maxValue(in values: [Double]) -> Double? {\n    return values.max()\n}"
  },
  {
    "input": "func greetingMessage(for name: String) -> String {\n    return \"Привет, \\(name)!\"\n}",
    "output": "/// Создает приветственное сообщение\n/// - Parameter name: Имя пользователя\n/// - Returns: Строка приветствия\nfunc greetingMessage(for name: String) -> String {\n    return \"Привет, \\(name)!\"\n}"
  },
  {
    "input": "func isLeapYear(_ year: Int) -> Bool {\n    return (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0)\n}",
    "output": "/// Определяет високосный год\n/// - Parameter year: Год\n/// - Returns: true, если год високосный\nfunc isLeapYear(_ year: Int) -> Bool {\n    return (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0)\n}"
  },
  {
    "input": "func average(of numbers: [Double]) -> Double {\n    guard !numbers.isEmpty else { return 0.0 }\n    return numbers.reduce(0, +) / Double(numbers.count)\n}",
    "output": "/// Возвращает среднее арифметическое массива чисел\n/// - Parameter numbers: Массив чисел\n/// - Returns: Среднее значение\nfunc average(of numbers: [Double]) -> Double {\n    guard !numbers.isEmpty else { return 0.0 }\n    return numbers.reduce(0, +) / Double(numbers.count)\n}"
  },
  {
    "input": "func millisecondsToSeconds(_ milliseconds: Int) -> Double {\n    return Double(milliseconds) / 1000.0\n}",
    "output": "/// Преобразует миллисекунды в секунды с точностью до сотых\n/// - Parameter milliseconds: Значение в миллисекундах\n/// - Returns: Значение в секундах\nfunc millisecondsToSeconds(_ milliseconds: Int) -> Double {\n    return Double(milliseconds) / 1000.0\n}"
  },
  {
    "input": "func isSubset<T: Equatable>(subset: [T], of set: [T]) -> Bool {\n    return subset.allSatisfy { set.contains($0) }\n}",
    "output": "/// Определяет, содержатся ли элементы одного массива в другом\n/// - Parameters:\n///   - subset: Массив предполагаемого подмножества\n///   - set: Массив супермножества\n/// - Returns: true, если subset содержится в set\nfunc isSubset<T: Equatable>(subset: [T], of set: [T]) -> Bool {\n    return subset.allSatisfy { set.contains($0) }\n}"
  },
  {
    "input": "func stringToDate(_ dateString: String) -> Date? {\n    let formatter = DateFormatter()\n    formatter.dateFormat = \"yyyy-MM-dd\"\n    return formatter.date(from: dateString)\n}",
    "output": "/// Конвертирует строку в дату\n/// - Parameters:\n///   - dateString: Строка в формате \"yyyy-MM-dd\"\n/// - Returns: Объект Date или nil, если формат неверный\nfunc stringToDate(_ dateString: String) -> Date? {\n    let formatter = DateFormatter()\n    formatter.dateFormat = \"yyyy-MM-dd\"\n    return formatter.date(from: dateString)\n}"
  },
  {
    "input": "func randomColor() -> UIColor {\n    return UIColor(red: .random(in: 0...1),\n                   green: .random(in: 0...1),\n                   blue: .random(in: 0...1),\n                   alpha: 1.0)\n}",
    "output": "/// Генерирует случайный цвет (UIColor)\n/// - Returns: Случайный цвет\nfunc randomColor() -> UIColor {\n    return UIColor(red: .random(in: 0...1),\n                   green: .random(in: 0...1),\n                   blue: .random(in: 0...1),\n                   alpha: 1.0)\n}"
  },
  {
    "input": "func doubleEach(numbers: [Int]) -> [Int] {\n    return numbers.map { $0 * 2 }\n}",
    "output": "/// Удваивает каждое число в массиве\n/// - Parameter numbers: Массив целых чисел\n/// - Returns: Массив с удвоенными значениями\nfunc doubleEach(numbers: [Int]) -> [Int] {\n    return numbers.map { $0 * 2 }\n}"
  },
  {
    "input": "func isArrayUnique<T: Hashable>(_ array: [T]) -> Bool {\n    return Set(array).count == array.count\n}",
    "output": "/// Проверяет, является ли массив уникальным (без повторов)\n/// - Parameter array: Массив элементов\n/// - Returns: true, если все элементы уникальны\nfunc isArrayUnique<T: Hashable>(_ array: [T]) -> Bool {\n    return Set(array).count == array.count\n}"
  },
  {
    "input": "func degreesToRadians(_ degrees: Double) -> Double {\n    return degrees * .pi / 180\n}",
    "output": "/// Преобразует градусы в радианы\n/// - Parameter degrees: Угол в градусах\n/// - Returns: Угол в радианах\nfunc degreesToRadians(_ degrees: Double) -> Double {\n    return degrees * .pi / 180\n}"
  },
  {
    "input": "func currentDateString() -> String {\n    let formatter = DateFormatter()\n    formatter.dateFormat = \"dd.MM.yyyy\"\n    return formatter.string(from: Date())\n}",
    "output": "/// Возвращает строку с текущей датой в формате \"dd.MM.yyyy\"\n/// - Returns: Строка с датой\nfunc currentDateString() -> String {\n    let formatter = DateFormatter()\n    formatter.dateFormat = \"dd.MM.yyyy\"\n    return formatter.string(from: Date())\n}"
  },
  {
    "input": "func toggle(_ value: Bool) -> Bool {\n    return !value\n}",
    "output": "/// Инвертирует булево значение\n/// - Parameter value: Логическое значение\n/// - Returns: Инвертированное значение\nfunc toggle(_ value: Bool) -> Bool {\n    return !value\n}"
  },
  {
    "input": "func joinWithComma(_ elements: [String]) -> String {\n    return elements.joined(separator: \", \")\n}",
    "output": "/// Создает строку из массива строк, разделенных запятой\n/// - Parameter elements: Массив строк\n/// - Returns: Одна строка с разделителем \", \"\nfunc joinWithComma(_ elements: [String]) -> String {\n    return elements.joined(separator: \", \")\n}"
  },
  {
    "input": "func wordCount(in text: String) -> Int {\n    return text.split(separator: \" \").count\n}",
    "output": "/// Возвращает количество слов в строке\n/// - Parameter text: Строка текста\n/// - Returns: Количество слов\nfunc wordCount(in text: String) -> Int {\n    return text.split(separator: \" \").count\n}"
  },
  {
    "input": "func isAlphabetic(_ input: String) -> Bool {\n    return input.allSatisfy { $0.isLetter }\n}",
    "output": "/// Проверяет, содержит ли строка только буквы\n/// - Parameter input: Входная строка\n/// - Returns: true, если только буквы\nfunc isAlphabetic(_ input: String) -> Bool {\n    return input.allSatisfy { $0.isLetter }\n}"
  },
  {
    "input": "func reversedArray<T>(_ array: [T]) -> [T] {\n    return array.reversed()\n}",
    "output": "/// Возвращает массив с элементами в обратном порядке\n/// - Parameter array: Исходный массив\n/// - Returns: Новый массив с реверсированным порядком\nfunc reversedArray<T>(_ array: [T]) -> [T] {\n    return array.reversed()\n}"
  },
  {
    "input": "func createDictionary<K: Hashable, V>(keys: [K], values: [V]) -> [K: V]? {\n    guard keys.count == values.count else { return nil }\n    return Dictionary(uniqueKeysWithValues: zip(keys, values))\n}",
    "output": "/// Создает словарь из двух массивов ключей и значений\n/// - Parameters:\n///   - keys: Массив ключей\n///   - values: Массив значений\n/// - Returns: Словарь, если массивы одинаковой длины\nfunc createDictionary<K: Hashable, V>(keys: [K], values: [V]) -> [K: V]? {\n    guard keys.count == values.count else { return nil }\n    return Dictionary(uniqueKeysWithValues: zip(keys, values))\n}"
  },
  {
    "input": "func isPrime(_ number: Int) -> Bool {\n    guard number > 1 else { return false }\n    for i in 2...Int(sqrt(Double(number))) {\n        if number % i == 0 {\n            return false\n        }\n    }\n    return true\n}",
    "output": "/// Проверяет, является ли число простым\n/// - Parameter number: Целое число\n/// - Returns: true, если число простое\nfunc isPrime(_ number: Int) -> Bool {\n    guard number > 1 else { return false }\n    for i in 2...Int(sqrt(Double(number))) {\n        if number % i == 0 {\n            return false\n        }\n    }\n    return true\n}"
  },
  {
    "input": "func toUpperCase(_ text: String) -> String {\n    return text.uppercased()\n}",
    "output": "/// Преобразует строку в верхний регистр\n/// - Parameter text: Исходная строка\n/// - Returns: Строка в верхнем регистре\nfunc toUpperCase(_ text: String) -> String {\n    return text.uppercased()\n}"
  },
  {
    "input": "func arraysEqual<T: Equatable>(_ a: [T], _ b: [T]) -> Bool {\n    return a == b\n}",
    "output": "/// Сравнивает два массива на эквивалентность\n/// - Parameters:\n///   - a: Первый массив\n///   - b: Второй массив\n/// - Returns: true, если массивы идентичны по содержимому и порядку\nfunc arraysEqual<T: Equatable>(_ a: [T], _ b: [T]) -> Bool {\n    return a == b\n}"
  },
  {
    "input": "func formatTime(seconds: Int) -> String {\n    let hrs = seconds / 3600\n    let mins = (seconds % 3600) / 60\n    let secs = seconds % 60\n    return String(format: \"%02d:%02d:%02d\", hrs, mins, secs)\n}",
    "output": "/// Преобразует секунды в формат времени (чч:мм:сс)\n/// - Parameter seconds: Общее количество секунд\n/// - Returns: Строка времени\nfunc formatTime(seconds: Int) -> String {\n    let hrs = seconds / 3600\n    let mins = (seconds % 3600) / 60\n    let secs = seconds % 60\n    return String(format: \"%02d:%02d:%02d\", hrs, mins, secs)\n}"
  },
  {
    "input": "func filterEven(numbers: [Int]) -> [Int] {\n    return numbers.filter { $0 % 2 == 0 }\n}",
    "output": "/// Возвращает четные числа из массива\n/// - Parameter numbers: Массив целых чисел\n/// - Returns: Только четные числа\nfunc filterEven(numbers: [Int]) -> [Int] {\n    return numbers.filter { $0 % 2 == 0 }\n}"
  },
  {
    "input": "func repeatValue<T>(_ value: T, count: Int) -> [T] {\n    return Array(repeating: value, count: count)\n}",
    "output": "/// Создает массив, повторяя элемент заданное количество раз\n/// - Parameters:\n///   - value: Элемент\n///   - count: Количество повторений\n/// - Returns: Массив с повторами\nfunc repeatValue<T>(_ value: T, count: Int) -> [T] {\n    return Array(repeating: value, count: count)\n}"
  },
  {
    "input": "func mergeDictionaries<K, V>(_ dict1: [K: V], _ dict2: [K: V]) -> [K: V] {\n    return dict1.merging(dict2) { _, new in new }\n}",
    "output": "/// Склеивает два словаря\n/// - Parameters:\n///   - dict1: Первый словарь\n///   - dict2: Второй словарь\n/// - Returns: Объединенный словарь (второй перекрывает первый)\nfunc mergeDictionaries<K, V>(_ dict1: [K: V], _ dict2: [K: V]) -> [K: V] {\n    return dict1.merging(dict2) { _, new in new }\n}"
  },
  {
    "input": "func isInRange(_ value: Int, range: ClosedRange<Int>) -> Bool {\n    return range.contains(value)\n}",
    "output": "/// Проверяет, находится ли число в диапазоне\n/// - Parameters:\n///   - value: Проверяемое число\n///   - range: Диапазон\n/// - Returns: true, если значение в диапазоне\nfunc isInRange(_ value: Int, range: ClosedRange<Int>) -> Bool {\n    return range.contains(value)\n}"
  },
  {
    "input": "func trimmed(_ text: String) -> String {\n    return text.trimmingCharacters(in: .whitespacesAndNewlines)\n}",
    "output": "/// Удаляет пробелы в начале и конце строки\n/// - Parameter text: Исходная строка\n/// - Returns: Обрезанная строка\nfunc trimmed(_ text: String) -> String {\n    return text.trimmingCharacters(in: .whitespacesAndNewlines)\n}"
  },
  {
    "input": "func boolToYesNo(_ value: Bool) -> String {\n    return value ? \"Да\" : \"Нет\"\n}",
    "output": "/// Переводит значение Bool в строку \"Да\" или \"Нет\"\n/// - Parameter value: Булево значение\n/// - Returns: \"Да\" если true, \"Нет\" если false\nfunc boolToYesNo(_ value: Bool) -> String {\n    return value ? \"Да\" : \"Нет\"\n}"
  },
  {
    "input": "func colorSquare(size: CGFloat) -> some View {\n    Color.blue.frame(width: size, height: size)\n}",
    "output": "/// Создает квадратный `Color` view заданного размера\n/// - Parameter size: Размер квадрата\n/// - Returns: View с цветным квадратом\nfunc colorSquare(size: CGFloat) -> some View {\n    Color.blue.frame(width: size, height: size)\n}"
  },
  {
    "input": "func boldText(_ content: String) -> Text {\n    Text(content).bold()\n}",
    "output": "/// Создает текст с жирным шрифтом\n/// - Parameter content: Текстовая строка\n/// - Returns: `Text` с жирным стилем\nfunc boldText(_ content: String) -> Text {\n    Text(content).bold()\n}"
  },
  {
    "input": "func customButton(title: String, action: @escaping () -> Void) -> some View {\n    Button(action: action) {\n        Text(title)\n            .padding()\n            .background(Color.green)\n            .foregroundColor(.white)\n            .cornerRadius(10)\n    }\n}",
    "output": "/// Создает кнопку с заданным действием и заголовком\n/// - Parameters:\n///   - title: Заголовок кнопки\n///   - action: Замыкание действия\n/// - Returns: SwiftUI Button\nfunc customButton(title: String, action: @escaping () -> Void) -> some View {\n    Button(action: action) {\n        Text(title)\n            .padding()\n            .background(Color.green)\n            .foregroundColor(.white)\n            .cornerRadius(10)\n    }\n}"
  },
  {
    "input": "func systemIcon(name: String, color: Color) -> some View {\n    Image(systemName: name).foregroundColor(color)\n}",
    "output": "/// Возвращает иконку с системным именем и цветом\n/// - Parameters:\n///   - name: Название SF Symbol\n///   - color: Цвет иконки\n/// - Returns: View с иконкой\nfunc systemIcon(name: String, color: Color) -> some View {\n    Image(systemName: name).foregroundColor(color)\n}"
  },
  {
    "input": "func flatten<T>(_ matrix: [[T]]) -> [T] {\n    return matrix.flatMap { $0 }\n}",
    "output": "/// Разворачивает двумерный массив в одномерный\n/// - Parameter matrix: Двумерный массив\n/// - Returns: Одномерный массив\nfunc flatten<T>(_ matrix: [[T]]) -> [T] {\n    return matrix.flatMap { $0 }\n}"
  },
  {
    "input": "func groupBy<T, K: Hashable>(_ items: [T], by keySelector: (T) -> K) -> [K: [T]] {\n    Dictionary(grouping: items, by: keySelector)\n}",
    "output": "/// Группирует элементы по указанному признаку\n/// - Parameters:\n///   - items: Массив элементов\n///   - keySelector: Функция определения ключа\n/// - Returns: Словарь групп\nfunc groupBy<T, K: Hashable>(_ items: [T], by keySelector: (T) -> K) -> [K: [T]] {\n    Dictionary(grouping: items, by: keySelector)\n}"
  },
  {
    "input": "func removeDuplicates<T: Hashable>(_ array: [T]) -> [T] {\n    var seen = Set<T>()\n    return array.filter { seen.insert($0).inserted }\n}",
    "output": "/// Удаляет дубликаты из массива, сохраняя порядок\n/// - Parameter array: Исходный массив\n/// - Returns: Массив без дубликатов\nfunc removeDuplicates<T: Hashable>(_ array: [T]) -> [T] {\n    var seen = Set<T>()\n    return array.filter { seen.insert($0).inserted }\n}"
  },
  {
    "input": "func invertDictionary<K: Hashable, V: Hashable>(_ dictionary: [K: V]) -> [V: K] {\n    var result: [V: K] = [:]\n    for (key, value) in dictionary {\n        result[value] = key\n    }\n    return result\n}",
    "output": "/// Переворачивает ключи и значения словаря\n/// - Parameter dictionary: Словарь [K: V]\n/// - Returns: Новый словарь [V: K]\nfunc invertDictionary<K: Hashable, V: Hashable>(_ dictionary: [K: V]) -> [V: K] {\n    var result: [V: K] = [:]\n    for (key, value) in dictionary {\n        result[value] = key\n    }\n    return result\n}"
  },
  {
    "input": "func hypotenuse(a: Double, b: Double) -> Double {\n    return sqrt(a * a + b * b)\n}",
    "output": "/// Возвращает гипотенузу по теореме Пифагора\n/// - Parameters:\n///   - a: Катет A\n///   - b: Катет B\n/// - Returns: Гипотенуза\nfunc hypotenuse(a: Double, b: Double) -> Double {\n    return sqrt(a * a + b * b)\n}"
  },
  {
    "input": "func fibonacci(_ n: Int) -> Int {\n    guard n > 1 else { return n }\n    var a = 0, b = 1\n    for _ in 2...n {\n        (a, b) = (b, a + b)\n    }\n    return b\n}",
    "output": "/// Возвращает число Фибоначчи по индексу\n/// - Parameter n: Индекс\n/// - Returns: n-е число Фибоначчи\nfunc fibonacci(_ n: Int) -> Int {\n    guard n > 1 else { return n }\n    var a = 0, b = 1\n    for _ in 2...n {\n        (a, b) = (b, a + b)\n    }\n    return b\n}"
  },
  {
    "input": "func lcm(_ a: Int, _ b: Int) -> Int {\n    return abs(a * b) / gcd(a, b)\n}",
    "output": "/// Находит наименьший общий кратный двух чисел\n/// - Parameters:\n///   - a: Первое число\n///   - b: Второе число\n/// - Returns: НОК\nfunc lcm(_ a: Int, _ b: Int) -> Int {\n    return abs(a * b) / gcd(a, b)\n}"
  },
  {
    "input": "func gcd(_ a: Int, _ b: Int) -> Int {\n    var a = a, b = b\n    while b != 0 {\n        (a, b) = (b, a % b)\n    }\n    return a\n}",
    "output": "/// Вычисляет наибольший общий делитель (НОД)\n/// - Parameters:\n///   - a: Первое число\n///   - b: Второе число\n/// - Returns: НОД\nfunc gcd(_ a: Int, _ b: Int) -> Int {\n    var a = a, b = b\n    while b != 0 {\n        (a, b) = (b, a % b)\n    }\n    return a\n}"
  },
  {
    "input": "func median(of numbers: [Double]) -> Double? {\n    guard !numbers.isEmpty else { return nil }\n    let sorted = numbers.sorted()\n    let mid = sorted.count / 2\n    return sorted.count % 2 == 0\n        ? (sorted[mid - 1] + sorted[mid]) / 2\n        : sorted[mid]\n}",
    "output": "/// Находит медиану массива\n/// - Parameter numbers: Массив чисел\n/// - Returns: Медианное значение\nfunc median(of numbers: [Double]) -> Double? {\n    guard !numbers.isEmpty else { return nil }\n    let sorted = numbers.sorted()\n    let mid = sorted.count / 2\n    return sorted.count % 2 == 0\n        ? (sorted[mid - 1] + sorted[mid]) / 2\n        : sorted[mid]\n}"
  },
  {
    "input": "func isPowerOfTwo(_ n: Int) -> Bool {\n    return n > 0 && (n & (n - 1)) == 0\n}",
    "output": "/// Проверяет, является ли число степенью двойки\n/// - Parameter n: Число\n/// - Returns: true, если степень двойки\nfunc isPowerOfTwo(_ n: Int) -> Bool {\n    return n > 0 && (n & (n - 1)) == 0\n}"
  },
  {
    "input": "func roundToEven(_ value: Double) -> Int {\n    let rounded = Int(round(value))\n    return rounded % 2 == 0 ? rounded : rounded + 1\n}",
    "output": "/// Округляет число до ближайшего четного\n/// - Parameter value: Вещественное число\n/// - Returns: Ближайшее четное число\nfunc roundToEven(_ value: Double) -> Int {\n    let rounded = Int(round(value))\n    return rounded % 2 == 0 ? rounded : rounded + 1\n}"
  }
]
